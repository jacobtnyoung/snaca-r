{
  "hash": "57d30133660bd0c03e0b43058ea11447",
  "result": {
    "markdown": "\n\n\n# Working with Networks in R {.unnumbered}\n\nIn the [**Network Data Structures**](https://jacobtnyoung.github.io/snaca-textbook/snaca-net-data-structures.html) chapter of the [*Social Network Analysis for Crime Analysts*](https://jacobtnyoung.github.io/snaca-textbook/) textbook, we reviewed how networks can be represented as sociomatrices. These matrices form the basic unit of data analysis in SNA. In this tutorial, we will review how we can build networks in R. Understanding how to work with networks in R is essential for crime analysts because networks provide a powerful lens for analyzing relationships and interactions that drive criminal behavior. Whether you're mapping connections between individuals in a gang, examining the flow of illicit goods, or identifying key actors in a criminal enterprise, networks reveal critical structures and patterns that traditional data analysis might overlook.\n\nAs a reminder, in the tutorials for this textbook, R code appears `like this` and can be copied directly into R or RStudio. Let's start getting our hands dirty (figuratively of course) by building some networks in R!\n\n## Working with matrices\n\nFirst, clear the workspace. To do so, we use the following statement:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm( list = ls() )\n```\n:::\n\n\nLet's start by working with an example of an undirected, binary network. We will create an object that is the *adjacency matrix*.\n\nOne way to create an *adjacency matrix* is to use the `matrix()` function with the `concatenate()` or `c()` function.\\\nWe can look at what these functions do by asking for help using the `help(\"` function name here `\")` or `?(\"` function name here `\")` functions.\n\nThe help window describes the arguments that the function takes and also provides examples.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# help for the matrix() function\n?matrix\n\n# help for the c() function\n?c\n```\n:::\n\n\nNow, let's create the data object:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmat <- matrix(\n  c( 0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0 ),\n  nrow=5,\n  byrow=TRUE\n  )\n```\n:::\n\n\nThis command reads as follows:\n\n-   Combine the following numbers\n\n-   From these combined numbers, create a matrix by reading across the list\n\n-   Create an object called mat. This object will be a matrix with 5 rows.\n\nWe can see the object by just typing the object name: `mat`. *Note* that if the number of elements does not correctly match the dimensions of the matrix, R gives you an error.\n\nFor example:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njunk_1 <- matrix( c( 1,2,3,4,5,6,7 ), nrow=2, byrow=TRUE )  \n\n# Because there are 7 elements here, \n# the 8th element needed for a matrix \n# is replaced with the first value in the vector\n\n# print out the object by just typing the name of the object\njunk_1 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    1\n```\n:::\n:::\n\n\nAfter we have created our object `mat` or `junk_1`, we can examine the dimensions with the dim function: `dim( mat )` or `dim( junk_1 )`.\n\nWe can also attach names to the rows and columns of the matrix by using the `rownames()` and `colnames()` functions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# attach row names\nrownames( mat ) <- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# attach column names\ncolnames( mat ) <- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# print out the object\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n```\n:::\n:::\n\n\nWe can refer to specific elements, rows, or columns by using the `[` and `]` symbols. This reads as: \"object\\[row,column\\]\". Remember from the [Getting Started with R](snaca-r-intro-to-r.html) tutorial that I said we would use indexing a lot? Well, this is where that comes true!\n\nFor example, let's look at the relation Jen sends to Tom.\n\nRecall from the [**Network Data Structures**](https://jacobtnyoung.github.io/snaca-textbook/snaca-net-data-structures.html) chapter that this is element 1,2 in the matrix (i.e. row one, column two). In R code that is: `mat[1,2]`.\n\nThis command reads as follows: for the object `mat`, return the value at row 1 column 2. The row number is the first dimension and the column is the second dimension. **Remember**: \"rows by columns\".\n\nWe can also call the values for an entire row or column:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# this reads: return the first row of data\nmat[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n```\n:::\n\n```{.r .cell-code}\n# this reads: return the first column of data\nmat[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n```\n:::\n:::\n\n\nSince we have defined names for the rows and columns, we can use those as well.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# reference the ROW pertaining to Jen\nmat[\"Jen\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n```\n:::\n\n```{.r .cell-code}\n# reference the COLUMN pertaining to Jen\nmat[,\"Jen\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n```\n:::\n:::\n\n\n*Note*: the following does not work because it needs a character, defined by the `\"\"` symbols around the name.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# returns an error because there is no OBJECT called Jen \nmat[,Jen]\n\n# compare the difference with the prior line\nmat[,\"Jen\"]\n```\n:::\n\n\nWe can also call a series of values:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# return the first three ROWS of the object data\nmat[1:3,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nTom   1   0   1    0   0\nBob   0   1   0    1   1\n```\n:::\n\n```{.r .cell-code}\n# return the first three COLUMNS of the object data\nmat[,1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jen Tom Bob\nJen    0   1   0\nTom    1   0   1\nBob    0   1   0\nLeaf   0   0   1\nJim    0   0   1\n```\n:::\n:::\n\n\nWe can also call a group of values that are non-contiguous using the `c()` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# return the first and second ROWS of the object data\nmat[c(1,3),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nBob   0   1   0    1   1\n```\n:::\n\n```{.r .cell-code}\n# return the first and second COLUMNS of the object data\nmat[,c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jen Bob\nJen    0   0\nTom    1   1\nBob    0   0\nLeaf   0   1\nJim    0   1\n```\n:::\n:::\n\n\nWe can also call a group of values that do not contain specified values by putting a `-` (i.e. a minus sign) in front of the c function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# return the object data without ROWS 1 and 3\nmat[-c(1,3),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jen Tom Bob Leaf Jim\nTom    1   0   1    0   0\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n```\n:::\n\n```{.r .cell-code}\n# return the object data without COLUMNS 1 and 3\nmat[,-c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Tom Leaf Jim\nJen    1    0   0\nTom    0    0   0\nBob    1    1   1\nLeaf   0    0   1\nJim    0    1   0\n```\n:::\n:::\n\n\nGot it? If yes, then GREAT! If no, hang in there: you got this! If you are a bit hesitant with working with indexing, the best way to get better is to practice. Feel free to work back through the section above to get better at this basic skill we will use a LOT in subsequent tutorials.\n\n## Exploring the `network` Package\n\nNow that we have created the `mat` object, let's manipulate it into a network and a graph. To do this, we can use the `network` package. `network` is a package containing tools to create and modify network objects created by [Carter Butts](https://ncasd.org/~buttsc/). See the [network page](http://cran.r-project.org/web/packages/network/index.html) for an overview of package functionality.\n\nFirst, we need to install the package using: `install.packages( \"network\" )`. *Note*: if you have already installed the package, no **do not** need to reinstall it.\n\nIf it is already installed, we should check to make sure we have the most recent version: `update.packages( \"network\" )`\n\nWhenever we start R, we need to load the package because it is not automatically loaded. To do this, use the `library()` function. `library( \"network\" )`\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nTo get a list of the contents of the package, as for help with respect to the package itself use the `help()` function, but tell R we want help on the particular package: `help( package=\"network\" )`.\n\n### Working with *Unidirected*, Binary Networks\n\nNow that the package is loaded, let's create a new object from our matrix that is a network. In R lingo, we will use the `network()` function to create an object that is of *class* `network`. To use some of the functions, it has to be a specific class.\n\nJust like you can't perform calculations on an object that is of class `character` (e.g. a list of names), the functions in this page are designed to work with a `network` object.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# look at our object\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n```\n:::\n\n```{.r .cell-code}\n# what class is the object\nclass( mat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\n# now, coerce the object into \n# an object called net.u that\n# is of class network\nnet_u <- as.network( mat )\n\nnet_u\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 10 \n    missing edges= 0 \n    non-missing edges= 10 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n```\n:::\n:::\n\n\nWhen we enter the object in the command line, summary info about the object is produced: `net_u`. This is because the object is of class `network`. We can use the class function to confirm this: `class( net_u )`.\n\nLet's look at the object again: `net_u`. *What does the summary output of the object tell us?*\n\nNote that the network is treated as **directed**. By default, the function `as.network()` sets the argument `directed =` to `TRUE`. We can see this by looking at the structure of the function in the help page: `?as.network`. *What do we need to change in the `as.network()` function?*\n\nWe need to change the input for the `directed=` argument because our network is **undirected**. In other words, `directed = FALSE`. This tells the function that the matrix we are entering is an undirected network. This is logical: is the object a directed network? False. Therefore, it is an undirected network.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create a new object called net_u_correct\nnet_u_correct <- as.network( \n  mat, \n  directed = FALSE )\n\n# compare the difference since telling the function that the network is directed\nnet_u\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 10 \n    missing edges= 0 \n    non-missing edges= 10 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n```\n:::\n\n```{.r .cell-code}\n# how is this one different?\nnet_u_correct\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 5 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 5 \n    missing edges= 0 \n    non-missing edges= 5 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n```\n:::\n:::\n\n\nThe `summary()` function is a generic function that summarizes objects. We can use it on an object of class `network` to provide more information: `summary( net_u_correct )`. More information about what can be done with the `summary()` function for an object of class network is shown on the `?as.network` page.\n\nWe could also enter the data as an edgelist using the `matrix.type =` argument. By default, the function `as.network()` sets the argument `matrix.type =` to `adjacency`. For an edgelist, we would need to change the input for the `matrix.type =` argument to `edgelist`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# for example, let's make an edgelist called edge\n# it will be a matrix of 5 rows and we are reading off by row\nedge <- matrix(\n  c( \"Jen\",\"Tom\",\"Tom\",\"Bob\",\"Bob\",\"Leaf\",\"Bob\",\"Jim\",\"Leaf\",\"Jim\" ),\n  nrow = 5, \n  byrow = TRUE )\n\n# take a look\nedge\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]   [,2]  \n[1,] \"Jen\"  \"Tom\" \n[2,] \"Tom\"  \"Bob\" \n[3,] \"Bob\"  \"Leaf\"\n[4,] \"Bob\"  \"Jim\" \n[5,] \"Leaf\" \"Jim\" \n```\n:::\n\n```{.r .cell-code}\n# create an object called edge_net_u\n# but change the default to edgelist for the matrix.type argument.\nedge_net_u <- as.network(\n  edge, \n  directed = FALSE, \n  matrix.type = \"edgelist\" ) \n\n# now take a look\nsummary( edge_net_u )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n```\n:::\n\n```{.r .cell-code}\n# The as.network() function will often recognize the matrix type being entered\n# create the object again, but do not toggle the matrix.type argument\nedge_net_u <- as.network( \n  edge,\n  directed = FALSE )\n\n# is it different\n# no, because the function is programmed to \n# read the dimensions of the input object\nsummary( edge_net_u )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n```\n:::\n:::\n\n\n### Working with *Directed*, Binary Networks\n\nNow, let's work with the example of a directed, binary network. We will create an object that is the adjacency matrix.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# these were written in by row\n# so we want it to read by row, byrow=TRUE\nmat_d <- matrix(\n  c( 0,1,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,1,0 ),\n  nrow = 5,\n  byrow = TRUE )\n\n# take a look at the matrix\nmat_d \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    0    0    0\n[2,]    0    0    1    0    0\n[3,]    0    0    0    1    1\n[4,]    0    0    1    0    1\n[5,]    0    0    1    1    0\n```\n:::\n:::\n\n\nNow, let's coerce it to be an object of class network.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnet_d <- as.network( \n  mat_d,\n  directed = TRUE )\n\n# take a look\nsummary( net_d )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n  1 2 3 4 5\n1 0 1 0 0 0\n2 0 0 1 0 0\n3 0 0 0 1 1\n4 0 0 1 0 1\n5 0 0 1 1 0\n```\n:::\n:::\n\n\nJust as before, we could also enter the data as an edgelist. Since we have directed relations, we have more edges. This is because reciprocated ties count twice. So, we have to tell the `matrix()` function that the matrix has 8 rows, instead of 5.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create the edgelist\nedge_d <- matrix(\n  c( \"Jen\",\"Tom\",\"Tom\",\"Bob\",\"Bob\",\"Leaf\",\"Bob\",\"Jim\",\n     \"Leaf\",\"Bob\",\"Leaf\",\"Jim\",\"Jim\",\"Bob\",\"Jim\",\"Leaf\" ),\n  nrow = 8,\n  byrow = TRUE )\n\n# create the network object\nedge_d_net <- as.network(\n  edge_d,\n  directed = TRUE,\n  matrix.type = \"edgelist\" )\n\n# take a look\nsummary( edge_d_net )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   0\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   0   0    0   0\n```\n:::\n\n```{.r .cell-code}\n# I have added the argument print.adj=FALSE\n# what is different?\nsummary( edge_d_net,\n         print.adj = FALSE )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n```\n:::\n:::\n\n\n### Importing Network Data\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nIf we had a large network, these routines (i.e. using the `matrix()` function) would be tedious and most likely result in a few errors. Most of the time, we have a file that is an adjacency matrix or an edgelist that we can import. The `read.csv()` function can be used to read in .csv files that are arranged in this way. Let's take a look at the help for this function: `?read.csv`.\n\nWe will use a file called **data-undirected-example.csv**. To access the file, we can place the url in the `read.csv()` function.\n\nHere is the url: <https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv>.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# define the path\nurl <- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\"\n\n# define the data using the url object\nmat_u <- read.csv( url )\n\n# look at the object\nmat_u\n\n# note that the read.csv function creates an object of class data.frame.\nclass( mat_u )\n```\n:::\n\n\nWe need to adjust the arguments to read in the file how we want it. Specifically, we want to do the following:\n\n-   Set the `as.is =` argument equal to `TRUE` so that it reads the data as it is.\n\n-   Set the `header =` argument to `TRUE` to indicate that there is a header, or column labels.\n\n-   Set the `row.names =` argument equal to 1 to indicate that the name of the rows are in the first column.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# look at the arguments\nmat_u2 <- read.csv( \n  url,\n  as.is = TRUE,\n  header = TRUE,\n  row.names = 1 \n  )\n\nmat_u2\n\n# compare them\nmat_u\nmat_u2\n```\n:::\n\n\nNow, make the object into one of `class` network:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# we have to first coerce the object to a matrix\nmat_u2 <- as.matrix( mat_u2 )\n\n# recall that since this network is undirected\n# we set the directed= argument to FALSE\nnet_u <- as.network( \n  mat_u2,\n  directed = FALSE\n   )\n\nnet_u\n\n# we could combine the as.matrix and as.network functions\nnet_u <- as.network( \n  as.matrix( \n    mat_u2 ), \n  directed = FALSE \n  )\n\nnet_u\n```\n:::\n\n\nWe could also import the file if it is saved locally (i.e. we are not going to the web to get it). *Typically* we do not do this because it is a bad practice. That is, creating a version of a file locally. But, sometimes you might be offline or you have files that cannot be put online.\n\nLet's do this for the directed network. I have saved the file to my desktop. First, look at what directory we are in using the `getwd()` function. This function gets the current working directory.\n\nThen, set the directory where the file is located using the `setwd()` function. You can get the location of the file by right-clicking and in Windows using *Properties* or on Mac using *Get Info*. Note that you have to configure this path to your machine.\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nThen, use `read.csv` as above:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetwd( \"PUT THE CORRECT PATH HERE\" )\n\nmat_d <- read.csv(\n  \"data-directed-example.csv\",\n  as.is=TRUE,\n  header=TRUE,\n  row.names=1\n  )\n\n# Note: we don't need to tell it that \n# the network is directed since \n# this is the default, \n# but a good habit to get into.\nnet_d <- as.network(\n  as.matrix( data_d ),\n  directed=TRUE\n  )\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# now, print the object.\nnet_d\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 8 \n    missing edges= 0 \n    non-missing edges= 8 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n```\n:::\n:::\n\n\n<br>\n\n## Test Your Knowledge Exercises\n\n-   Create a 5x5 adjacency matrix using the `matrix()` function.\n    -   What happens if the number of elements doesn't match the dimensions of the matrix?\n    -   Assign meaningful row and column names to the adjacency matrix using the `rownames()` and `colnames()` functions.\n    -   How can you reference a specific row or column by name?\n-   Use the `[` and `]` symbols to extract specific elements, rows, or columns from a matrix.\\\n-   Coerce an adjacency matrix into a `network` object using the `as.network()` function.\n    -   What argument must you modify to create an undirected network?\\\n-   Create an edgelist for a directed network and convert it to a `network` object. How does this process differ from working with adjacency matrices?\\\n-   Summarize a `network` object using the `summary()` function.\n    -   What insights can you gain from this output?\\\n-   Explain the difference between directed and undirected networks in the context of the `as.network()` function.\n    -   What specific arguments are used to define these properties?\n\n## Tutorial Summary\n\nThis tutorial introduced the basics of working with network data in R, focusing on creating, manipulating, and importing network structures. It began with constructing adjacency matrices using the `matrix()` function, followed by assigning meaningful row and column names for clarity and exploring matrix indexing to extract specific elements, rows, or columns. The tutorial then transitioned to coercing matrices into `network` objects using the `as.network()` function from the `network` package, with special attention to specifying whether a network is directed or undirected. The use of edgelists as an alternative to adjacency matrices was demonstrated, highlighting the importance of specifying the correct matrix type in the `as.network()` function. The tutorial also covered importing network data from external sources, including CSV files from URLs or local directories, and converting them into network objects. The emphasis was on building a solid foundation for working with network data structures, which are essential for analyzing relationships and interactions in crime analysis.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}