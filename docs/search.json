[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Social Network Analysis for Crime Analysts using R",
    "section": "",
    "text": "Preface\nThe field of crime analysis is rapidly evolving, driven by advancements in technology and the growing availability of rich, complex data. Among the most pressing challenges for crime analysts is the need to make sense of these data, particularly when they involve relationships between individuals, groups, or organizations. Social network analysis (SNA) provides a powerful set of tools for mapping and understanding these connections, enabling analysts to uncover patterns, identify key players, and generate actionable insights. This book, Social Network Analysis for Crime Analysts using R, is designed to bridge the gap between theory and application, offering crime analysts a practical guide to using R, an open-source statistical programming language, and RStudio, an integrated development environment that provides a user-friendly interface for coding, data analysis, visualization, and report generation.\nWhy R and RStudio? RStudio is more than just software. It provide a robust ecosystem that empowers users to wrangle, visualize, and analyze data with precision and flexibility. For crime analysts, learning the R language and how to work in RStudio offers a significant advantage: they are free, widely supported by a global community, and capable of handling the types of network data that traditional tools struggle to process. With RStudio, analysts can customize workflows, automate repetitive tasks, and leverage advanced techniques such as clustering algorithms, centrality measures, and visualization methods: all essential for modern SNA. By working in RStudio, even those new to programming can gain the confidence to manipulate data and produce meaningful outputs. The ability to write reproducible code also ensures that analyses are transparent and can be revisited or adapted as cases evolve.\nThis book is written with the unique needs of crime analysts in mind. Using real-world examples and step-by-step instructions, it demonstrates how SNA can be conducted in Rstudio to solve practical problems, from identifying influential actors in a gang network to assessing the vulnerability of criminal enterprises. The focus is not only on teaching the mechanics of RStudio but also on fostering a deeper understanding of the concepts behind social network analysis. Whether you are new to network analysis or seeking to expand your analytic toolkit, this book will provide you with the skills and confidence to harness the power of RStudio and SNA in your work. Together, these tools can transform how crime analysts approach data, enabling them to uncover critical insights and ultimately contribute to safer communities.\nThis book is a companion to Social Network Analysis for Crime Analysts. It is organized as tutorials that show the “how to” of SNA in RStudio that correspond to conceptual chapters in the Social Network Analysis for Crime Analysts textbook.\nEach tutorial in this book will contain R code which is in “code chunks”. You will notice a code chunk because the font will change. Code chunks will have text that looks like this. There is also regular text. The R code chunks can be copied and pasted directly into R and RStudio. As you work through the tutorials, follow along in the software by coping and pasting the code and seeing it work on your end.\nLet’s get to it!"
  },
  {
    "objectID": "snaca-r-intro-to-r.html#things-about-r-to-get-you-started",
    "href": "snaca-r-intro-to-r.html#things-about-r-to-get-you-started",
    "title": "Getting Started with R",
    "section": "10 Things about R to get you started:",
    "text": "10 Things about R to get you started:\n\n1. What is R\nR is a dialect of the S language that was written by John Chambers and others at Bell tutorials in the 70s. In the 90s, R was developed and made avaitutorialle to the public with the GNU general public license. Importantly, R is free, meaning that you don’t have to pay for it (duh), but it is also open source, meaning that you have freedom to use and modify it.\nR is an operating system for data science software. Just as Windows allows you to turn on your computer, open a web browser, moved files around, and write a paper using MS Word, R allows you to install and run packages and manage files while organizing large data projects. Just like Windows would be a very boring piece of software without all of the applications you run while on the computer, R would be a boring language without all of the packages it can run.\n\n\n2. Installing and Starting\nGo to http://cran.r-project.org. Find the “Download R for…” link that is appropriate for your operating system.\nWhen R starts it loads some basic info and provides you with a prompt: &gt;\nThis prompt is the fundamental entry point for communicating with R. We type expressions at the prompt, R evaluates these expressions, and returns output.\n\n\n3. Objects in R\nR is a programming language. That means, it allows us to give instructions to our computer to do stuff. We will see that there is a lot of “stuff” we can do. But, the basic orientation to R is understanding objects.\nWhat is an object? Without getting to philosophical, an object is something we create in the R environment. Think of an R session as a box. We are creating objects and putting them into the box. This is quite different from data analysis programs like SPSS or Stata.\nWe create objects by using the assignment operator: &lt;-\nWhat you type on the right is assigned to what you type on the left. For example:\ny &lt;- 4 (we have assigned the value 4 to the object y)\nx &lt;- 6 (we have assigned the value 6 to the object x)\nz &lt;- y (we have assigned the value of the object y to the object z, i.e. z = 4)\nAfter assigning a value to an object, type the name of the object and hit return/enter to see what the value is.\nObjects can start with a letter or a period. But, you cannot name a object starting with a number (or other symbols used by R).\nSome examples:\nthe.number.two &lt;- 2\n2 &lt;- the.number.two\n2.the.number &lt;- 2\n;.2 &lt;- 2\nR is case sensitive (i.e. A is a different object than a). R is insensitive to white space though.\nThese two examples are treated the same in R:\nx &lt;- 2\nx&lt;-              2\nTo have R ignore text, use the # sign to make comments.\nFor example: x &lt;- 2 # this assigns the value 2 to object x.\nIn R there are no carriage returns (e.g. Stata uses /// in code). Sorry :("
  },
  {
    "objectID": "snaca-r-intro-to-r.html#functions-in-r",
    "href": "snaca-r-intro-to-r.html#functions-in-r",
    "title": "Getting Started with R",
    "section": "4. Functions in R",
    "text": "4. Functions in R\nA major strength of R is the ability to manipulate objects using functions. A function takes an argument (aka input) and returns some value (aka output).\nFor example, suppose we wanted to create a list of numbers, called a vector. We want to create an object that is defined by the list of numbers. In R, there is a preprogrammed function c(), which combines or concatenates values to create a single object. We can create an object x, that is a vector of 1, 2, 3, 4, and 5 using: x &lt;- c(1,2,3,4,5).\nThis reads: the object x is assigned the values 1, 2, 3, 4, and 5. The function is “c” and the argument is 1,2,3,4,5.\nThe number of values (aka elements) a vector contains is referred to as the “length”. We can use the length() function to return this information for us. For example: length(x) shows that the vector x has 5 values or elements.\nReminder: R is a language, so part of the learning curve is getting familiar with the names of functions."
  },
  {
    "objectID": "snaca-r-intro-to-r.html#referencing-and-indexing-objects-in-r",
    "href": "snaca-r-intro-to-r.html#referencing-and-indexing-objects-in-r",
    "title": "Getting Started with R",
    "section": "5. Referencing and Indexing Objects in R",
    "text": "5. Referencing and Indexing Objects in R\nIn R, specific elements in an object are referenced by using brackets (i.e. [ or ]).\nFor example, let’s create a vector and work with it:\n\nx &lt;- c( 1,2,3,4,5 ) # create the vector.\nx\nx[5] # what is the fifth element  in x?  \nx[2:4] # what are the second through fourth elements in x?  \nx[ c( 1,4 )] # what are the first and fourth elements in x?  \n\nNote the difference in use between [#:#] and [c(#,#)]. The colon : means “through” and the comma , means “and”.\nWe can also change values by indexing:\n\nx[5]   &lt;- 3 # change the fifth element in x to 5.  \nx[1:5] &lt;- 0 # change the first through fifth elements in x to 0.  \n\nUsing brackets to identify particular elements, called indexing, is VERY useful. By using indexing, we can create objects from other objects, or reference particular locations. The utility of this will be more obvious later.\n\n6. Types of objects (“classes”) in R\nObjects in R can be of different types or classes. There are four:\n\nnumeric, a number (e.g. 1, 2)\ncharacter, a letter or word (e.g. \"Shelley\", \"Trevor\")\nfactor, a category (e.g. female, male)\nlogical, True or False values (e.g. TRUE, FALSE)\n\nEach type of vector serves different purposes:\n\nnumeric: keep track of quantitative measures, counts, or orders of things\n\ncharacter: store non-numeric data, typically unstructured text\n\nfactor: represent distinct and mutually-exclusive categories\n\nlogical: designate cases that meet some criteria, usually group inclusion\n\nFor example, let’s build a few objects:\n\nnums &lt;- c( 1, 2, 3 )\nnames &lt;- c( \"Shelley\", \"Trevor\" )\nsex &lt;- factor( c( \"female\", \"male\" ) )\nis_female &lt;- sex == \"female\"\n\nNote that numbers do not require \" \" around them but characters do require \" \" around them. Also, that the object is.female is created by stating a condition.\nEach object has a class, which defines the “type” of vector a particular object is:\n\nname_list &lt;- c( \"Hugo\",\"Desmond\",\"Largo\" ) # assign the characters to an object.\nis.character( name_list ) # is the object a character vector?\nis.numeric( name_list ) #is the object a numeric vector?  \nis.factor( name_list ) # is the object a factor vector?\nis.logical( name_list ) # is the object a logical vector?\n\nMissing values are dealt with in R by NA.\n\ny &lt;- c( 3,NA,10 ) # create a vector with a missing value.\n2*y # multiple the vector by 2.  \nis.na( y ) # which positions in y have missing values?  \ny[ is.na( y )] #subset meeting condition.\ny[ !is.na( y )] # subset meeting a different condition.\n\n\n\n7. Matrices in R\nIn addition to vectors, we can create a matrix, which is a 2-dimensional representation of data. A matrix has dimensions r X c which means rows by columns. The number of rows and columns a matrix has is referred to as its “order” or “dimensionality”. This information is returned by using the dim() function. Matrices can be created by combining existing vectors using the rbind() and cbind() functions. The rbind() function means “row bind” and binds together vectors by rows. Think of it as stacking vectors on each other. The cbind() function means “column bind” and binds together vectors by rows. Think of it as placing them side by side. Let’s take a look:\n\nx  &lt;- c( 6,5,4,3,2 )\ny  &lt;- c( 8,7,5,3,1 )\nm1 &lt;- rbind( x,y ) #bind x and y by row to create a 2 X 5 matrix.\nm1 #just enter the name of the object to print it.\nm2 &lt;- cbind( x,y ) #bind x and y by column to create a 5 X 2 matrix.\nm2 #just enter the name of the object to print it.\n\nFor both functions, the dimensions of the vectors must be the same (i.e. same number of rows and columns).\nLet’s see some examples:\n\nl  &lt;- c( 6,5,4,3,2 )\nn  &lt;- c( 8,7,5 )\nm2 &lt;- rbind( l,n ) # returns an error because the dimensions differ.\n\nWe can index the matrix m1 or m2 by using the brackets [ ] with a comma between the two dimensions. Since a matrix is 2-dimensions, we can reference a specific element, an entire row, or an entire column:\n\nm1[2,2] #what is the value of the element in the 2nd row, 2nd column?\nm1[,2]  #what are the values in the second column?\nm1[2,]  #what are the values in the second row?\n\n\nm2[2,2] &lt;- 0 #change the value to zero.\nm2[2,]  &lt;- 0 #change the second row to zeros.\nm2[,2]  &lt;- 0 #change the second column to zeros.\n\nIn the code chunk above, note the difference between [,#] and [#,]. A comma in front of the argument (i.e. [,#]) applies to the columns) and a common after the argument (i.e. [#,]) applies to the rows.\nAlso, notice that m1[2,2], is an object, just as m1 is an object. In effect, we are subsetting the object m1 when we index it.\nMatrices can also be created from a list of numbers using the matrix() and c() functions.\n\nm3 &lt;- matrix( c( 1,0,1,0,0,1,0,1,0 ),nrow=3,ncol=3 )\nm3\n\n\n\n8. One of the most important functions in R: help()\nA useful feature of R is an extensive documentation of each of the functions. To access the main R help archive online, type: help.start()\nThe help() function, or a simple ?, can be used to get help about a specific function. For example: help(c) or ?c returns the help page for the c() function.\nTake a look at the help page. The first line shows you the function and the package it is written for in brackets (more on packages below). The help page provides a description, how to use it (i.e. what are the arguments), and a description of what each argument does. Further details and examples are provided as well.\nLet’s take a look at another function that creates sequences of numbers, the seq( ) function. There are several ways to use the seq( ) function. The most common are:\n\nseq( from=, to=, by= ) # Starts at from, ends at to, steps defined by by.\nseq( from=, to=, length= ) # Starts at from, ends at to, steps defined by length.  \n\nFor example:\nif we want to create an object of 5 values that starts with 1 and ends with 5, we type: seq( from=1, to=5, by=1 ).\nif we want to create an object of 5 values that starts with 1 and ends with 9, we type: seq( from=1, to=9, by=2 ).\nWe could also have used the length= argument: seq( from=1, to=10, length=5 ).\nSince R knows that from= or to= or by= or length= are arguments, we do not have to type them in the syntax: seq( 1, 9, 2 ) is identical to seq( from=1, to=9, by=2 ) (as far as R is concerned).\nFor the help function to work, you need to know the exact name of the function. If you don’t know this, but have a fuzzy idea of what it might be are what you want the function to do, you can use the help.search(\"fuzzy notion\") function (or just put ?? in front of the word).\nFor example, say you want to calculate the standard deviation for an object, but do not know the function name. Try: help.search( \"standarddeviation\" ) or ??standarddeviation (note the absence of a space). This returns the list of help topics that contain the phrase. We see that the standard deviation function is called sd().\n\n\n9. Packages and the install.packages() and library() Functions\nR has MANY preprogrammed functions that are automatically loaded when you open the program. Functions are stored in “packages”. Although there are many preprogrammed functions, there are even MORE functions that you can install on your own. A package in R is a collection of functions, usually written for a specific purpose.\nWe can see the packages available from CRAN at http://cran.r-project.org/. Just click on the “packages” link or go to https://cran.r-project.org/web/packages/index.html. As of writing this there are nearly 13,000 packages. There is a WIDE variety of packages available, this is another reason why R is awesome. If you can think it, someone has probably written a package for it in R (and if not, you can write one and contribute [isn’t it great!]).\nTake a few moments and look through the packages\nIf there is a particular package you want to add, you simply use the install.packages() function like this: install.packages(\"package name\").\nAfter the package is installed on your machine, you do not need to reinstall it each time you open a new session. Rather, you just need to load the package using the library() function like this: library(\"package name\").\nSome packages require other packages for them to work. If there is an error, you need to install the additional packages.\nNote that each time you open R you have to load any packages that you manually loaded using the install.packages() function. In other words, if we closed R and then reopened it, we would need to type library( \"ergm\" ) to load the functions in ergm. Note that we do not have to reinstall the package using install.packages(), we just have to load the library.\nIf you have installed the package, but have not loaded it, R will return an error saying that a particular function is not found.\nFor example, the function rgraph() in the package sna (which is a set of tools for working with social networks that we will use for this course) is used to create random graphs. Type ?rgraph and you get an error stating that there is no documentation avaitutorialle. This is because the sna library has not been loaded (even if you have installed sna). Typing install.packages( \"sna\" ) and library( sna ) prior to ?rgraph() will solve this problem.\nA final point on loading packages. Since anyone can write and contributes packages to R, it is not surprising that some packages occasionally use the same names for functions. When you have loaded libraries for packages that have conflicting functions, R will output a message indicating there is an issue.\nFor example, the sna package and the tnet package both have a function called betweenness, but the functions are programmed differently. When you load tnet after loading sna (or visa versa), R will give you a warning that an “object is being masked”. That means the functionality of betweenness in sna is no longer used. Let’s check it out:\n\ninstall.packages( \"sna\" )\nlibrary( sna )\ninstall.packages( \"tnet\" )\nlibrary( tnet )\n\nThis can be a bit frustrating. In such cases, you can unload the package using the detach() function. See: ?detach for an example.\n\n\n10. R Session Management\nAll variables created in R are stored in the “workspace”. Think of it as a work bench that has a bunch of stuff on it that you have created.\nTo see what exists in the workspace, type: ls().\nWe can remove specific variables with the rm() function. This helps clear up space (i.e. conserve memory). For example:\n\nx &lt;- seq( 1,5,1 ) # create the object.\nls()          # see the objects.\nrm( x )         # remove the object x.\nls()          # no more x.\n\nTo remove everything from the workspace use: rm( list=ls() ). This is helpful for starting a session to make sure everything is cleaned out.\nWhen you start R, it nominates one of the directories on your hard drive as a working directory, which is where it looks for user-written programs and data files.\nTo determine the current directory, type: getwd().\nYou can set the working directory also by typing: setwd(\"your desired directory here\").\nFor example, if you are using Windows OS and want to set your directory to be the “C” drive, type: setwd( \"C:/\" ). NOTE: when you copy and paste filepaths in Windows, the folders are denoted with \\, while R uses /.\nOr, if you are using Mac OS and want to set your directory to be a folder called “Users”, type: setwd( \"/Users\" ).\nOn the Windows OS you can set R to automatically start up in your preferred working directory by right clicking on the program shortcut, choosing properties, and completing the ‘Start in’ field. On the Mac OS you can set the initial working directory using the Preferences menu.\nTo save the workspace use the save.image() function. This function requires a file path, a file name, and the extension “.RData” which is the format for an R workspace file.\nFor example, to save a workspace called “OurFirstTutorial” to the current directory, simply type: save.image(\"OurFirstTutorial.Rdata\"). You can also write in the directory of you want to save it somewhere else. You can also do this by the pull-down menu with the File/Save option.\nTo load a previously saved workspace, you can either click on the file outside of R or use the load() function (e.g. load(\"OurFirstTutorial.Rdata\")). If you get an error, make sure you are referring the correct directory. You can also choose Load Workspace from the pull-down menu.\nNote that only the objects in the workspace are saved, not the text of what you have written.\n\n\n11. (Bonus!) R Studio\nYou may be surprised to discover how little functionality is implemented in the standard R GUI (i.e. graphical user interface). The standard R GUI implements only very rudimentary functionality through menus: reading help, managing multiple graphics windows, editing some source and data files, and some other basic functionality. There are no menu items, buttons, or palettes for loading data, transforming data, plotting data, or doing any real work with data. Commercial applications like SAS, SPSS, and Stata include user interfaces with much more functionality.\nThis was just the nature of working with R until some awesome human beings created RStudio. RStudio is one of several projects to build an easier-to-use GUI for R. It is a free, open-source IDE (i.e. integrated development environment) for working with R. Unlike the standard R GUI, RStudio tiles windows on the screen and puts different windows in different tabs. RStudio can be downloaded from: http://www.rstudio.com.\n\n\nRStudio workthrough\nOk, now open RStudio and let’s take a look!\nNow, that you have RStudio up and running, try rerunning some of the code above. You will see that R operates within the RStudio environment. However, there are more tools available in RStudio which we will use."
  },
  {
    "objectID": "snaca-r-intro-to-r.html#test-your-knowledge-exercises",
    "href": "snaca-r-intro-to-r.html#test-your-knowledge-exercises",
    "title": "Getting Started with R",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nAfter installing R, what does the &gt; prompt represent?\nCreate an object called a with the value 7.\nWhich of the following is a valid object name?\n\n3cats\n.hidden_data\nmy-object\n_underscore\n\nExplain what the following code does: b &lt;- 10?\nWhat is a function in R? Explain using the c() function as an example.\nCreate an object called numbers that contains the values 2, 4, 6, 8, and 10 using the c() function.\nType the following code: length( numbers ). What is the meaning of the number it returns?\nCreate a vector z with the values 10 through 20. Now, write code to retrieve:\n\nThe 3rd element in z.\nThe 2nd through 5th elements in z.\nThe 1st and last elements in z.\n\nWhat is the difference between z[3:5] and z[ c(3,5) ]?\nWhat is the purpose of the install.packages() function? The library() function?\nWhy might you see a “function not found” error when trying to use a function from a package?\nLook through the packages on the CRAN repository. Find one and install it."
  },
  {
    "objectID": "snaca-r-intro-to-r.html#tutorial-summary",
    "href": "snaca-r-intro-to-r.html#tutorial-summary",
    "title": "Getting Started with R",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial provides a quick introduction to R. R is a versatile and open-source programming language designed for data science and statistical analysis. As we will see, it is one of the best environments for working with social network data. We began with an overview of R’s history, emphasizing its unique features, such as being free and customizable through numerous packages. The tutorial then guides readers through essential concepts, including installing R, understanding the R environment, and creating objects, which are fundamental building blocks of any R session. Readers learn how to use functions, reference and manipulate objects, and work with different data types (numeric, character, factor, and logical). The tutorial also covers indexing techniques for accessing specific elements within objects and introduces matrices as a two-dimensional data structure. Practical advice is provided on navigating R’s extensive documentation, installing and loading packages, and managing the R workspace effectively. We also reviewed (briefly) RStudio, a powerful integrated development environment that enhances the R user experience. You are now equipped with foundational skills to explore R further and apply it to real-world data tasks as you continue developing your skills as a crime analyst."
  },
  {
    "objectID": "snaca-r-rmarkdown.html#data-driven-documents",
    "href": "snaca-r-rmarkdown.html#data-driven-documents",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "Data-Driven Documents",
    "text": "Data-Driven Documents\n\nWhat are Data-Driven Documents?\nData-driven documents are formats that combine text and analysis (i.e. data and code). By combining everything in a single file, we promote transparency and reproducibility. For any given table, figure, or model in the document, you should be able to easily discern how it was created, from what data, and what analysis was used.\nWe will use the R Markdown format.\n\nHow do Data-Driven Documents Work?\nAll of the document formats build from a simple text formatting convention called markdown.\nTo create an R Markdown document, you need three things:\n\nA header to specify the document type\nSome text (formatted in markdown)\nSome code (inside a “code chunk”)\n\nLet’s see how it works!"
  },
  {
    "objectID": "snaca-r-rmarkdown.html#rmarkdown-in-rstudio",
    "href": "snaca-r-rmarkdown.html#rmarkdown-in-rstudio",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "RMarkdown in RStudio",
    "text": "RMarkdown in RStudio\nFirst, you need to install the rmarkdown and knitr packages using:\n\ninstall.packages( \"rmarkdown\" )\ninstall.packages( \"knitr\" )\n\nHere is a diagram of how to open an RMarkdown file and create an output file:\n\n\n\n\nsequenceDiagram\n    participant User\n    participant RStudio\n    User-&gt;&gt;RStudio: Open RStudio\n    User-&gt;&gt;RStudio: File &gt; New File &gt; RMarkdown...\n    RStudio--&gt;&gt;User: RMarkdown template setup window\n    User-&gt;&gt;RStudio: Specify title, author, and output format (e.g., HTML, PDF, Word)\n    User-&gt;&gt;RStudio: Click \"OK\"\n    RStudio--&gt;&gt;User: Generates a new RMarkdown file\n    User-&gt;&gt;RStudio: Start editing text and adding code chunks\n    User-&gt;&gt;RStudio: Save the file (.Rmd extension)\n    User-&gt;&gt;RStudio: Click \"Knit\" to generate the output document\n\n\n\n\n\n\nLet’s walk through this. First, you need to open RStudio. Then, using the dropdown menu select File &gt; New File &gt; RMarkdown. This will bring up the RMarkdown template window. In this window, you can specify the title, author, and output format. Click “OK” and RStudio will create a new RMarkdown file. An RMarkdown file has two essential pieces: text and code chunks (discussed more below). The last piece is to click the “Knit” button to create the output document.\n\nA Closer Look\n\nKnitting R Markdown Files\nCode is placed inside of “chunks” in the documents:\n\n\n\n\n\nWhen you “knit” a file RStudio will run all of code, embed the output into your document, and then convert the file to whichever type you have specified in the file header.\n\n\n\nOutput Types\nYou can select from many different document types, including HTML pages, Microsoft word, presentation formats, or dashboards.\nCheck out these examples:\nR Markdown Formats R Markdown Gallery\n\nHTML Pages\n---\noutput: html_document\n---\n\n\n\n\n\n\n\n\nDashboards\n---\noutput: flexdashboard::flex_dashboard:\n---\n\n\n\n\n\n[ dashboard example ] [ source code ] [ blog about the tracker ]\n\n\nPDFs\n---\noutput: pdf_document\n---\n\nA note on PDFs\nIf you would like to knit to PDF you need one additional program. TeX creates publication-quality PDF files. The open-source version is called MiKTeX download page.\nIf you have problems, you can find some nice tutorials like this one: https://www.reed.edu/data-at-reed/software/R/r_studio_pc.html\n\n\n\n\nWorking with Markdown\nMarkdown is a set of simple conventions for formatting text in R Markdown (RMD) files.\nIt makes it easy to create professional documents with minimal effort.\nHere are the basic formatting rules for Markdown:\n\nHeaders\n# Heading One (h1)\n\n## Heading Two (h2)\n\n### Heading Three (h3)\n\n#### Heading Four (h4)\n\n##### Heading Five (h5)\n\n###### Heading Six (h6)\n\n\nText Style\nWith Markdown, it is possible to emphasize words by making them *italicized*, using *astericks* or _underscores_, or making them **bold**, using **double astericks** or __double underscores__. \n\nOf course, you can combine those two formats, with both _**bold and italicized**_ text, using any combination of the above syntax. \n\nYou can also add a strikethrough to text using a ~~double tilde~~.\nWith Markdown, it is possible to emphasize words by making them italicized, using astericks or underscores, or making them bold, using double astericks or double underscores.\nOf course, you can combine those two formats, with both bold and italicized text, using any combination of the above syntax.\nYou can also add a strikethrough to text using a double tilde.\n\n\nLists\n\nUnordered\n* First item\n* Second item\n* Third item\n    * First nested item\n    * Second nested item\n\nFirst item\nSecond item\nThird item\n\nFirst nested item\nSecond nested item\n\n\n\n\nOrdered\n1. First item\n2. Second item\n3. Third item\n    1. First nested item\n    2. Second nested item\n\nFirst item\nSecond item\nThird item\n\nFirst nested item\nSecond nested item\n\n\n\n\n\nHyperlinks\nCreate links by wrapping the link text in square brackets [ ], and the URL in adjacent parentheses ( ).\n[Google News](https://news.google.com)\nGoogle News\n\n\nImages\nInsert images in a similar way, but add an exclamation mark in front of square brackets [ ], and the image file name goes in the parentheses ( ).\n![alt_text_here](image_file.png)\nThe alt text appears when the image cannot be located, or is read by devices for the blind when the mouse hovers over the image. It\nOr you can link directly to an image online using the URL address of the image:\n![](https://www.rodaw.com/wp-content/uploads/2017/02/Mark-Down-MonsterDogLampShade-1.jpg)\n\n\n\nTables\n| Title 1          | Title 2          | Title 3         | Title 4         |\n|------------------|------------------|-----------------|-----------------|\n| First entry      | Second entry     | Third entry     | Fourth entry    |\n| Fifth entry      | Sixth entry      | Seventh entry   | Eight entry     |\n| Ninth entry      | Tenth entry      | Eleventh entry  | Twelfth entry   |\n| Thirteenth entry | Fourteenth entry | Fifteenth entry | Sixteenth entry |\n\n\n\n\n\n\n\n\n\nTitle 1\nTitle 2\nTitle 3\nTitle 4\n\n\n\n\nFirst entry\nSecond entry\nThird entry\nFourth entry\n\n\nFifth entry\nSixth entry\nSeventh entry\nEight entry\n\n\nNinth entry\nTenth entry\nEleventh entry\nTwelfth entry\n\n\nThirteenth entry\nFourteenth entry\nFifteenth entry\nSixteenth entry"
  },
  {
    "objectID": "snaca-r-rmarkdown.html#tutorial-summary",
    "href": "snaca-r-rmarkdown.html#tutorial-summary",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced you to the power of RMarkdown for creating reproducible, data-driven documents using RStudio. By combining narrative text, code, and analytical outputs into a single file, RMarkdown ensures transparency and efficiency in reporting workflows, eliminating the need to switch between multiple programs. This can be a valuable tool for any crime analyst. We (briefly) covered how to generate various output formats, such as HTML, Word, and PDF, which are customizable to suit different professional contexts. The tutorial also covers the basics of Markdown for text formatting, embedding images, creating tables, and hyperlinks, offering a comprehensive foundation for crafting professional documents."
  },
  {
    "objectID": "snaca-r-network-data.html#working-with-matrices",
    "href": "snaca-r-network-data.html#working-with-matrices",
    "title": "Working with Networks in R",
    "section": "Working with matrices",
    "text": "Working with matrices\nFirst, clear the workspace. To do so, we use the following statement:\nLet’s start by working with an example of an undirected, binary network. We will create an object that is the adjacency matrix.\nOne way to create an adjacency matrix is to use the matrix() function with the concatenate() or c() function.\nWe can look at what these functions do by asking for help using the help(\" function name here \") or ?(\" function name here \") functions.\nThe help window describes the arguments that the function takes and also provides examples.\nNow, let’s create the data object:\nThis command reads as follows:\n\nCombine the following numbers\nFrom these combined numbers, create a matrix by reading across the list\nCreate an object called data. This object will be a matrix with 5 rows.\n\nWe can see the object by just typing the object name: mat. Note that if the number of elements does not correctly match the dimensions of the matrix, R gives you an error.\nFor example:\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    1\n\n\nAfter we have created our object mat or junk_1, we can examine the dimensions with the dim function: dim( mat ) or dim( junk_1 ).\nWe can also attach names to the rows and columns of the matrix by using the rownames() and colnames() functions.\n\n\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\nWe can refer to specific elements, rows, or columns by using the [ and ] symbols. This reads as: “object[row,column]”.\nFor example, lets look at the relation Jen sends to Tom.\nRecall from th Network Data Structures chapter that this is element 1,2 in the matrix (i.e. row one, column two). In R code that is: mat[1,2].\nThis command reads as follows: for the object mat, return the value at row 1 column 2. The row number is the first dimension and the column is the second dimension. Remember: “rows by columns”\nWe can also call the values for an entire row or column. A single value is called a scalar.\n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\nSince we have defined names for the rows and columns, we can use those as well.\n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\nNote: the following does not work because it needs a character, defined by the \"\" symbols around the name.\nWe can also call a series of values:\n\n\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nTom   1   0   1    0   0\nBob   0   1   0    1   1\n\n\n     Jen Tom Bob\nJen    0   1   0\nTom    1   0   1\nBob    0   1   0\nLeaf   0   0   1\nJim    0   0   1\n\n\nWe can also call a group of values that are non-contiguous using the c() function:\n\n\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nBob   0   1   0    1   1\n\n\n     Jen Bob\nJen    0   0\nTom    1   1\nBob    0   0\nLeaf   0   1\nJim    0   1\n\n\nWe can also call a group of values that that do not contain specified values by putting a - (i.e. a minus sign) in front of the c function:\n\n\n     Jen Tom Bob Leaf Jim\nTom    1   0   1    0   0\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\n     Tom Leaf Jim\nJen    1    0   0\nTom    0    0   0\nBob    1    1   1\nLeaf   0    0   1\nJim    0    1   0\n\n\nGot it? If yes, then GREAT! If no, hang in there: you got this! If you are a bit hesitant with working with indexing, the best way to get better is to practice. Feel free to work back through the section above to get better at this basic skill we will use a LOT in subsequen tutorials."
  },
  {
    "objectID": "snaca-r-network-data.html#exploring-the-network-package",
    "href": "snaca-r-network-data.html#exploring-the-network-package",
    "title": "Working with Networks in R",
    "section": "Exploring the network Package",
    "text": "Exploring the network Package\nNow that we have our object mat is created, let’s manipulate it into a network and a graph. To do this, we can use the network package. network is a package containing tools to create and modify network objects created by Carter Butts. See the network page for an overview of package functionality.\nFirst, we need to install the package using: install.packages( \"network\" ). Note: if you have already installed the package, no do not need to reinstall it.\nIf it is already installed, we should check to make sure we have the most recent version: update.packages( \"network\" )\nWhenever we start R, we need to load the package because it is not automatically loaded. To do this, use the library() function. library( \"network\" )\nTo get a list of the contents of the package, as for help with respect to the package itself use the help() function, but tell R we want help on the particular package: help( package=\"network\" ).\n\nWorking with Unidirected, Binary Networks\nNow that the package is loaded, lets create a new object from our matrix that is a network. In R lingo, we will use the network() function to create an object that is of class network. To use some of the functions, it has to be a specific class.\nJust like you can’t perform calculations on a object that is of class character (e.g. a list of names), the functions in this page are designed to work with a network object.\n\n\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\n[1] \"matrix\" \"array\" \n\n\nWhen we enter the object in the command line, summary info about the object is produced: net_u. This is because the object is of class network. We can use the class function to confirm this: class( net_u ).\nLet’s look at the object again: net_u. What does the summary output of the object tell us?\nNote that the network is treated as directed. By default, the function as.network() sets the argument directed = to TRUE. We can see this by looking at the structure of the function in the help page: ?as.network. What do we need to change in the as.network() function?\nWe need to change the input for the directed= argument because our network is undirected. In other words, directed = FALSE. This tells the function that the matrix we are entering is an undirected network. This is logical: is the object a directed network? False. Therefore, it is an undirected network.\n\n\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 10 \n    missing edges= 0 \n    non-missing edges= 10 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\n Network attributes:\n  vertices = 5 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 5 \n    missing edges= 0 \n    non-missing edges= 5 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nThe summary() function is a generic function that summarizes objects. We can use it on an object of class network to provide more information: summary( net_u_correct ). More information about what can be done with the summary() function for an object of class network is shown on the ?as.network page.\nWe could also enter the data as an edgelist using the matrix.type = argument. By default, the function as.network() sets the argument matrix.type = to adjacency. For an edgelist, we would need to change the input for the matrix.type = argument to edgelist.\n\n\n     [,1]   [,2]  \n[1,] \"Jen\"  \"Tom\" \n[2,] \"Tom\"  \"Bob\" \n[3,] \"Bob\"  \"Leaf\"\n[4,] \"Bob\"  \"Jim\" \n[5,] \"Leaf\" \"Jim\" \n\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n\n\n\n\nWorking with Directed, Binary Networks\nNow, let’s work with the example of a directed, binary network. We will create an object that is the adjacency matrix.\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    0    0    0\n[2,]    0    0    1    0    0\n[3,]    0    0    0    1    1\n[4,]    0    0    1    0    1\n[5,]    0    0    1    1    0\n\n\nNow, let’s coerce it to be an object of class network.\n\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n  1 2 3 4 5\n1 0 1 0 0 0\n2 0 0 1 0 0\n3 0 0 0 1 1\n4 0 0 1 0 1\n5 0 0 1 1 0\n\n\nJust as before, we could also enter the data as an edgelist. Since we have directed relations, we have more edges. This is because reciprocated ties count twice. So, we have to tell the matrix() function that the matrix has 8 rows, instead of 5.\n\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   0\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   0   0    0   0\n\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\n\n\n\nImporting Network Data\nIf we had a large network, these routines (i.e. using the matrix() function) would be tedious. Most of the time, we have a file that is an adjacency matrix or an edgelist that we can import. The read.csv() function can be used to read in .csv files that are arranged in this way. Let’s take a look at the help for this function: ?read.csv.\nWe will use a file called data-undirected-example.csv. To access the file, we can place the url in the read.csv() function.\nHere is the url: https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv.\n\n# define the path\nurl &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\"\n\n# define the data using the url object\nmat_u &lt;- read.csv( url )\n\n# look at the object\nmat_u\n\n# note that the read.csv function creates an object of class data.frame.\nclass( mat_u )\n\nWe need to adjust the arguments to read in the file how we want it. Specifically, we want to do the following:\n\nSet the as.is = argument equal to TRUE so that it reads the data as it is.\nSet the header = argument to TRUE to indicate that there is a header, or column labels.\nSet the row.names = argument equal to 1 to indicate that the name of the rows are in the first column.\n\n\n# look at the arguments\nmat_u2 &lt;- read.csv( \n  url,\n  as.is = TRUE,\n  header = TRUE,\n  row.names = 1 \n  )\n\nmat_u2\n\n# compare them\nmat_u\nmat_u2\n\nNow, make the object into one of class network:\n\n# we have to first coerce the object to a matrix\nmat_u2 &lt;- as.matrix( mat_u2 )\n\n# recall that since this network is undirected\n# we set the directed= argument to FALSE\nnet_u &lt;- as.network( \n  mat_u2,\n  directed = FALSE\n   )\n\nnet_u\n\n# we could combine the as.matrix and as.network functions\nnet_u &lt;- as.network( \n  as.matrix( \n    mat_u2 ), \n  directed = FALSE \n  )\n\nnet_u\n\nWe could also import the file if it is saved locally (i.e. we are not going to the web to get it). Typically we do not do this because it is a bad practice. That is, creating a version of a file locally. But, sometimes you might be offline or you have files that cannot be put online.\nLet’s do this for the directed network. I have saved the file to my desktop. First, look at what directory we are in using: getwd() function. This function gets the wording directory R is currently looking at.\nThen, set the directory where the file is using the setwd() function. You can get the location of the file by right-clicking and in Windows using Properties or on Mac using Get Info. Note that you have to configure this path to your machine.\nThen, use read.csv as above:\n\nsetwd( \"PUT THE CORRECT PATH HERE\" )\n\nmat_d &lt;- read.csv(\n  \"data-directed-example.csv\",\n  as.is=TRUE,\n  header=TRUE,\n  row.names=1\n  )\n\n# Note: we don't need to tell it that \n# the network is directed since \n# this is the default, \n# but a good habit to get into.\nnet_d &lt;- as.network(\n  as.matrix( data_d ),\n  directed=TRUE\n  )\n\n\n\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 8 \n    missing edges= 0 \n    non-missing edges= 8 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes"
  },
  {
    "objectID": "snaca-r-network-data.html#test-your-knowledge-exercises",
    "href": "snaca-r-network-data.html#test-your-knowledge-exercises",
    "title": "Working with Networks in R",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\n???"
  },
  {
    "objectID": "snaca-r-network-data.html#tutorial-summary",
    "href": "snaca-r-network-data.html#tutorial-summary",
    "title": "Working with Networks in R",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\n???"
  },
  {
    "objectID": "snaca-r-visualization.html#network-visualization",
    "href": "snaca-r-visualization.html#network-visualization",
    "title": "Basics of Network Visualization",
    "section": "Network Visualization",
    "text": "Network Visualization\nOne of the great features of working with network data is the ability to see the data through visualization. Visualizing the structure of a network is helpful for discerning patterns that might be of interest.\nDouglas Luke’s (2015: 47) A User’s Guide to Network Analysis provides several guidelines, or aesthetic principles, for what makes a graphical layout of a network easy to understand and interpret. These are:\n\nMinimize edge crossings\nMaximize the symmetry of the layout of nodes\nMinimize the variability of the edge lengths\nMaximize the angle between edges when they cross or join nodes\nMinimize the total space used for the network display\n\nThink about each of these suggestions. Why do they aid in visualizing the network? How do they assist in avoiding conveying information that is not really there? Ponder these questions for a bit…"
  },
  {
    "objectID": "snaca-r-visualization.html#getting-started",
    "href": "snaca-r-visualization.html#getting-started",
    "title": "Basics of Network Visualization",
    "section": "Getting Started",
    "text": "Getting Started\nNow that you have a sense of what a good visualization should try to do, let’s look at the example Luke uses as an illustration by working with the gplot() function in the sna package.\nFirst, we need to install the sna package using install.packages( \"sna\" ) and load the library using library( sna ).\nRemember, if you have already installed a package then you do not need to use the install.packages() function. But, if you have not installed the package in a while, you should use update.packages() to incorporate any changes that have been made to the page.\nNext, let’s get the UserNetR package from Douglas Luke’s GitHub page. Since this package is not on the CRAN package repository, we need to install it directly from Github. We do this in four steps:\n\nFirst, install the devtools package using install.packages( \"devtools\" )\nAnd then load the library for the package with library( devtools )\nNow, install the UserNetR package install_github( \"DougLuke/UserNetR\" )\nFinally, load the library library( UserNetR )\n\nAltogether, that looks something like this:\n\n# install the packages\ninstall.packages( \"sna\" )\ninstall.packages( \"devtools\" )\n\n# call the libraries\nlibrary( sna )\nlibrary( devtools )\n\n# install from Github\ninstall_github( \"DougLuke/UserNetR\" )\n\n# call that library\nlibrary( UserNetR )\n\nNow, let’s take a look at the Moreno network (see help( Moreno, package = UserNetR ). These data are contained in a sociogram constructed by Jacob Moreno, and published in the New York Times in 1933 (see Moreno, J. L. 1934. Who shall survive? A new approach to the problem of human interrelations. Nervous and mental disease monograph series, no. 58. Washington, DC: Nervous and Mental Disease Publishing Co. for a more extensive discussion).\n\n# Note that we ask the summary() function to not print out the adjacency matrix.\nsummary( Moreno, print.adj = FALSE )\n\nNetwork attributes:\n  vertices = 33\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 46 \n   missing edges = 0 \n   non-missing edges = 46 \n density = 0.08712121 \n\nVertex attributes:\n\n gender:\n   numeric valued attribute\n   attribute summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   1.000   2.000   1.515   2.000   2.000 \n  vertex.names:\n   character valued attribute\n   33 valid vertex names\n\nNo edge attributes\n\n# Now, let's compare two different plot layouts.\n\n# Here is a circle.\ngplot( Moreno, mode = \"circle\" )\n\n\n\n\n\n\n\n# Here is a separate layout.\ngplot( Moreno, mode = \"fruchtermanreingold\" )\n\n\n\n\n\n\n\n\nThink back to the aesthetic elements we discussed above. How do these two plots differ in how well they convey the same information? Which one is better? Why is it better?\nTo think about these questions, let’s plot the two layouts together. To do this we will use the par() function. This allows us to partition the plotting region.\n\n# First, we define the plot layout window.\nop &lt;- par( \n  mar = rep( 2, 4 ), # set the margins\n  mfrow = c( 1, 2 )  # set the dimensions\n  )\n\n# plot the circle layout (add the main() argument for a title)\ngplot( Moreno, mode = \"circle\", main = \"Plotted as a circle\" )\n\n# plot the Fruchterman Reingold layout\ngplot( Moreno, mode = \"fruchtermanreingold\", main = \"Plotted using a spring algorithm\" )\n\n\n\n\n\n\n\n\nAgain, think about our questions: How do these two plots differ in how well they convey the same information? Which one is better? Why is it better?\n\nAdding Attributes\nIf we add information about gender, we can see a bit more that is revealed by the spring algorithm.\nTo do so, we use the vertex.col= argument with the vertex attribute gender. To do so, we need to access the vertex attribute. We can do this with:\n\nthe get.vertex.attribute() function in the sna package. Use library( sna ) and specify the attribute we want, like get.vertex.attribute( Moreno,  \"gender\" )\nor use the shorthand for this with network object %v% atttribute, like Moreno %v% \"gender\"\n\n\nop &lt;- par( mar = rep( 2, 4 ), mfrow = c( 1, 2 ) )\n\ngplot( Moreno,\n      mode = \"circle\",\n      main = \"Plotted as a circle\",\n      vertex.col = get.vertex.attribute( Moreno, \"gender\" ) # use the vertex attribute.\n      )\n\ngplot( Moreno,\n       mode = \"fruchtermanreingold\",\n       main = \"Plotted using a spring algorithm\",\n       vertex.col = Moreno %v% \"gender\" # note the difference here compared to above.\n       )\n\n# let's add a legend to the plot\nlegend(\n  \"bottomleft\",\n  legend = c( \"Male\",\"Female\" ),\n  col = c( \"red\",\"black\" ),\n  title = \"legend\",\n  pt.cex = 0.75,\n  bty = \"n\",\n  pch = 19 \n  )\n\n\n\n\n\n\n\n\nWhat is the primary story that the plot tells? Does a particular layout help us see that better?\nOk, that was a lot. Let’s work our way back through the mechanics of building a plot to better get a sense of what we are doing."
  },
  {
    "objectID": "snaca-r-visualization.html#working-with-the-gplot-function",
    "href": "snaca-r-visualization.html#working-with-the-gplot-function",
    "title": "Basics of Network Visualization",
    "section": "Working with the gplot() Function",
    "text": "Working with the gplot() Function\nLet’s take a look at some of the visualization capabilities of gplot(). Let’s start by looking at the function’s help page: ?gplot.\nTo see the various functionality of the function, let’s work with our example of an undirected network.\n\n# define the path where the data are\nurl &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\"\n\n# define the object\nmat_u &lt;- as.matrix(\n  read.csv( \n    url,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1\n    )\n  )\n\n# now, create the network\nnet_u &lt;- network(\n  mat_u,\n  directed = FALSE\n)\n\n# take a look at the network\nsummary( net_u )\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n#NOTE: we could have wrapped all of this into two statements\nnet_u &lt;- as.network( \n  as.matrix( \n    read.csv( \n      \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\", \n      as.is = TRUE, \n      header = TRUE, \n      row.names = 1 \n      ) \n    ),\n  directed = FALSE \n  )\n\nsummary( net_u )\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\nNow that we have the object built, we can plot it.\n\ngplot( net_u )\n\n\n\n\n\n\n\n\nHold on, this plot shows arrows. But this network is undirected. What gives?\nThat is because gplot() assumes a directed network. We can see this in the help menu, ?gplot, where is shows that for the type of network, the gmode= argument defaults to a directed graph. To fix this we can either:\n\nmanually turn off the display of arrows using the usearrows= argument, gplot( net.u, usearrows = FALSE )\nor indicate that the object to be plotted is a undirected graph or graph, gplot( net.u, gmode = \"graph\" )\n\nThe gplot() function has a number of arguments that can be used to work try and better display the information contained in the network.\nFor example, we can add labels to the vertices using the network.vertex.names() function.\n\ngplot(\n  net_u, \n  gmode = \"graph\", \n  label = network.vertex.names( net_u )\n  )\n\n\n\n\n\n\n\n\nAlternatively, we could add in a string of names for the label:\n\ngplot( net.u, gmode = \"graph\",  label = c( \"Jen\", \"Tom\", \"Bob\", \"Leaf\", \"Jim\" ) )\n\nOr we could read them in as an object:\n\nnames &lt;- c( \"Jen\", \"Tom\", \"Bob\", \"Leaf\", \"Jim\" )\nadd to the plot using gplot( net.u, gmode = \"graph\", label = names )\n\nA great feature of R is that we can tune the graphing parameters. Here are several examples:\n\nLabels:\n\nAdd boxes around the labels, boxed.labels = TRUE\nChange label size using label.cex, such as label.cex = 1.5\nColor the labels using label.col=, such as: label.col = \"blue\"\n\nColors:\n\ndifferent colored names, combine label.col= with the c() function. Such as: label.col = c( \"red\", \"blue\", \"green\", \"orange\", \"grey\" )\ndifferent colored nodes, vertex.col= argument. Such as: vertex.col=c(\"red\",\"blue\",\"green\",\"orange\",\"grey\")\ndifferent colored edges, using edge.col=, such as: edge.col=c(\"red\",\"blue\",\"green\",\"orange\",\"grey\")\n\n\nThere is a LOT of functionality to the gplot() function. See the arguments in the help file: ?gplot. I would encourage you to take some time to look through it and play around with the various features.\n\nAdjusting Plot Layout\nWhen a layout is generated, the results can be saved for later reuse using the coord= argument.\n\n# Set the seed for the random number generator \n# so we can always get the same plot layout.\nset.seed( 605 ) \n\n# Define an object that will be the coordinates we want to use.\ncoords &lt;- gplot( \n  net_u, \n  gmode = \"graph\",\n  label = network.vertex.names( net_u )\n  )\n\n\n\n\n\n\n\n# Show the vertex coordinates.\ncoords\n\n             x         y\n[1,] -5.441389 -1.849797\n[2,] -4.682331 -3.198937\n[3,] -3.171835 -3.157688\n[4,] -2.055885 -2.041756\n[5,] -1.648225 -3.476604\n\n\nTake a close look at the coords object. What do the values represent? Think about how this information is used in the plot.\nNow, we can pass the coordinates into a plot.\n\n# Saved layouts can be used via the coord= argument:\ngplot(\n  net_u, \n  gmode = \"graph\",\n  label = network.vertex.names( net_u ),\n  coord = coords \n  )\n\n\n\n\n\n\n\n\nCool but, why do this? The placement of the nodes shift when we call the gplot() function just due to the operation of the algorithm. Controlling where nodes are plotted in the 2-dimensional space is useful if we want to show different aspects of the plot. Note that we can have different layouts of the nodes. If we like a particular one, we can save the coordinates.\nBut, suppose the default settings are insufficient and we want to make a few small changes. The interactive= argument allows for tweaking.\n\n# First, set up the coordinates you want.\ncoords &lt;- gplot(\n  net_u, \n  gmode = \"graph\",\n  label = network.vertex.names( net_u ),\n  coord = coords, \n  interactive=TRUE \n  )\n\nWhen this renders on your system, move a few of the nodes around. Then, after you close the window it will save the coordinates.\n\n# Then, use these in the plot.\ngplot( \n  net_u, \n  coord = coords, \n  gmode = \"graph\",\n  label=network.vertex.names( net_u )\n  )"
  },
  {
    "objectID": "snaca-r-visualization.html#a-layering-approach",
    "href": "snaca-r-visualization.html#a-layering-approach",
    "title": "Basics of Network Visualization",
    "section": "A Layering Approach",
    "text": "A Layering Approach\nAs we have seen, we can start with a basic plot and add information. Creating graphics in this way is referred to as layering because we are stacking additional layers of elements on top of each other.\nTake a look at this series of plots:\n\n\n\n\n\n\n\n\n\nThe plot uses several layers of information:\n\nthe size of the nodes (vertex.cex)\nthe color of the nodes (vertex.col)\nthe color of the edges (edge.col)\n\nAs we create a plot, we want to think about what information we should convey and how best to convey that information (i.e. colors?, shapes?, size?, all of the above?)"
  },
  {
    "objectID": "snaca-r-visualization.html#plotting-the-powerinfluence-network-from-the-prison-inmate-networks-study-pins",
    "href": "snaca-r-visualization.html#plotting-the-powerinfluence-network-from-the-prison-inmate-networks-study-pins",
    "title": "Basics of Network Visualization",
    "section": "Plotting the Power/Influence Network from the Prison Inmate Networks Study (PINS)",
    "text": "Plotting the Power/Influence Network from the Prison Inmate Networks Study (PINS)\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collect sociometric data in a prison. The researchers collected data on several types of networks.\nLet’s plot the power and influence network, which was created by asking individuals whom they believed was “powerful and influential” on the unit. We will continue working with the gplot() function.\nWe are going to do this in a few steps:\n\nFirst, load the adjacency matrix, data-PINS-power-w1-adj.csv, and create an object of class network.\nSecond, load the file with Age and Race attributes, data-PINS-w1-age-race-attributes.csv, and assign each attribute to the network object.\n\n\n# define the adjacency matrix\nPI_mat &lt;- as.matrix(\n  read.csv( \n    \"https://raw.githubusercontent.com/jacobtnyoung/snaca-r/main/data/data-PINS-power-w1-adj.csv\",\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1\n    )\n  )\n\n# create an object of class network\nPI_net &lt;- network( PI_mat, directed = TRUE )\n\n# define the attributes object\nPI_attrs &lt;- read.csv( \n    \"https://raw.githubusercontent.com/jacobtnyoung/sna-textbook/main/data/data-PINS-w1-age-race-attributes.csv\",\n    as.is = TRUE,\n    header = TRUE \n    )\n\n# assign the attributes to the network\nPI_net %v% \"Age\" &lt;- PI_attrs[,1]\nPI_net %v% \"Race\" &lt;- PI_attrs[,2]\n\nNote that we used a shorthand notation: %v%. This is an assignment operation that tells R to assign something to the network. Specifically, %v% indicates the assignment to a vertex, hence the v.\nThe operate also let’s us pull a specific attribute. We can look at the various vertex data by using the shorthand network %v% \"attribute\". For example:\n\nPI_net %v% \"Age\" shows the age variable.\nPI_._net %v% \"Race\" shows the race variable.\n\n\n# look at the values for age\nPI_net %v% \"Age\" &lt;- PI_attrs[,1]\n\n# look at the values for race\nPI_net %v% \"Race\" &lt;- PI_attrs[,2]\n\nNote that we can also reference edges (i.e. %e%) if a network has an assigned edge. For example, we could pull the information network and assign that to the power influence network:\n\n# define the adjacency matrix\nINFO_mat &lt;- as.matrix(\n  read.csv( \n    \"https://raw.githubusercontent.com/jacobtnyoung/snaca-r/main/data/data-PINS-info-w1-adj.csv\",\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1\n    )\n  )\n\n# assign the matrix as an edge attribute\nPI_net %e% \"info\" &lt;- INFO_mat\n\nThink about what we did on the last line. For the power influence edges, we assigned INFO_._mat as an attribute. This represents whether a power/influence tie was also an information network tie.\nNow, we can use that information in our plot. For example:\n\ngplot( PI_net,\n       arrowhead.cex=0.5,\n       vertex.cex = PI_net %v% \"Age\" )\n\n\n\n\n\n\n\n\nYIKES!!! What is wrong?\nThe problem is that we need to rescale the vertex attribute so that the nodes are not too big. Let’s build a function to do that and then execute the gplot() function:\n\nrescale &lt;- function( nchar, low, high ){\n  min_d &lt;- min( nchar )\n  max_d &lt;- max( nchar )\n  rscl  &lt;- ( ( high - low )*( nchar - min_d ) ) / ( max_d - min_d ) + low\n  rscl\n}\n\nNow, use the function we created to rescale the vertex attribute:\n\n# now execute the plot\ngplot( PI_net, \n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nNote that the plot above has a lot of “whitespace” due to the margins. We can adjust this using the par() function.\n\n# tweak the margins to cut some whitespace\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\n# now execute the plot\ngplot( PI_net, \n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nThat looks better. Let’s drop the isolates (using the displayisolates = FALSE argument) to help with the visualization.\n\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\ngplot( PI_net,\n       displayisolates = FALSE,\n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nHow about we color the edges based on whether there was a information network tie.\n\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\ngplot( PI_net,\n       edge.col = PI_net %e% \"info\" + 1,\n       displayisolates = FALSE,\n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nAs we build layers, we can get a fairly useful graphic that tells us a lot of information:\n\npar( mar = c( 5,0.1,3,0.1 ) )\n\ngplot( PI_net,\n       main=\"PINS Power/Influence Network\", # add a title\n       vertex.col = PI_net %e% \"Race\", # color the nodes by the Race variable\n       edge.col = PI_net %e% \"info\" + 2, # color the edges by the information network attribute\n       displayisolates = FALSE, # don't display the isolated cases\n       arrowhead.cex=0.5, # augment the size of the arrowheads\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ), # size the nodes by the Age variable\n       sub=\"Nodes colored by Race, \\n edges colored by Info net \\n nodes sized by Age\" # add a subtitle\n       )"
  },
  {
    "objectID": "snaca-r-visualization.html#test-your-knowledge-exercises",
    "href": "snaca-r-visualization.html#test-your-knowledge-exercises",
    "title": "Basics of Network Visualization",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nUsing the Moreno dataset, compare the circle layout and the Fruchterman-Reingold layout. Which layout better adheres to the aesthetic principles discussed above? Why?\nModify the Moreno visualization to color nodes by gender. How does this addition change your interpretation of the network structure?\nWhen plotting an undirected network, why might gplot() still display arrows? How can this be resolved?\nExperiment with adding labels to a network plot. What are some ways to customize label appearance? Why might label size or color be important?\nUse the rescale() function to adjust node sizes based on a vertex attribute. Try some different values. How do the difference values influence your understanding of the network?\nExplain why saving node coordinates using the coord= argument can be useful. Demonstrate how to save and reuse coordinates in a network plot.\nDescribe the concept of layering in network visualization. Create a plot that layers at least three attributes (e.g., node size, color, edge attributes).\nCompare a basic network plot of the PINS dataset with one that incorporates multiple attributes. What additional insights does the more detailed visualization provide?"
  },
  {
    "objectID": "snaca-r-visualization.html#tutorial-summary",
    "href": "snaca-r-visualization.html#tutorial-summary",
    "title": "Basics of Network Visualization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThere is nothing like a beautiful network visualization that conveys lots of information and is aesthetically pleasing. Now you know how to get there! As you have seen, there is a ton of flexibility. I would encourage you to spend some time tinkering with the various arguments for the gplot() function to get a feel for what it can do."
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-undirected-binary-graphs",
    "href": "snaca-r-degree-centrality.html#degree-centrality-undirected-binary-graphs",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality (Undirected Binary Graphs)",
    "text": "Degree Centrality (Undirected Binary Graphs)\nIn an undirected binary graph, actor degree centrality measures the extent to which a node connects to all other nodes in a network. In other words, the number of edges incident with a node. This is symbolized as: \\(d(n_i)\\). For an undirected binary graph, the degree \\(d(n_i)\\) is the row or column sum. If we have an object of class(matrix) in the workspace, we can use the colSums() and/or rowSums() functions to return this information.\nFirst, let’s set up our graph from the degree centrality chapter:\n\n# First, clear the workspace\nrm( list = ls() )\n\n# Then, build an object\nu_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ),\n  c( 0,1,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ) )\n\n# Assign the names to the object\nrownames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# Now, plot the graph (remember to load the sna package)\n# The quitely= argument tells R not to print out the info on the package\nlibrary( sna, quietly=TRUE ) \n\n# Let's set up the coordinates to force the nodes\n# to be in the same position throughout the lab\nset.seed( 507 )\ncoords &lt;- gplot( u_mat )\n\n\n\n# Plot the network\ngplot( \n  u_mat, \n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  coord = coords\n  )\n\n\n\n\nSince the graph is undirected, we can print the degree centrality for each node as a vector using the colSums() or rowSums() functions:\n\ncolSums( u_mat )\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\nrowSums( u_mat )\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\n# We could also assign these to an object\ndeg_u_mat &lt;- colSums( u_mat )\n\nThen, we can use that information in the plot by passing the degree object to the vertex.cex= argument. This will make nodes with higher degree larger.\n\ngplot(\n  u_mat,\n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  vertex.cex = deg_u_mat, #HERE: we added the object to size the plot\n  coord = coords\n  )\n\n\n\n\nAnother approach is to shade the nodes. Rather than just the size, we might want to have nodes with larger degree to be darker (or lighter) to better visualize differences in degree. To do this, we could use the RColorBrewer package to shade the nodes.\n\n# install.packages( \"RColorBrewer\" )\nlibrary( RColorBrewer, quietly=TRUE )\n\n# use display.brewer.all() to see the pallettes.\n\n# Let's use the Blues pallette.\ncol_deg  &lt;- brewer.pal( length( unique( deg_u_mat ) ), \"Blues\")[deg_u_mat]\n\n# In this plot, what do darker shades mean?\ngplot(\n  u_mat, \n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  vertex.cex = deg_u_mat,\n  vertex.col = col_deg,\n  coord = coords\n  )\n\n\n\n\n\nStandardized degree centrality, mean degree, and centralization\nActor degree centrality not only reflects each node’s connectivity to other nodes but also depends on the size of the network, g. As a result, larger networks will have a higher maximum possible degree centrality values. This makes comparison across networks problematic. The solution is to take into account the number of nodes and the maximum possible nodes to which i could be connected, g-1.\nLet’s calculate the standardized centrality scores for our undirected graph:\n\n# unstandardized or raw centrality\ndeg_u_mat &lt;- colSums( u_mat )\n\n# to calculate g-1, we need to know the number of nodes in the graph \n# this is the first dimension of the matrix\ng &lt;- dim( u_mat )[1]\n\n# now, divide by g-1\ns_deg_u_mat &lt;- deg_u_mat / ( g-1 )\n\ndeg_u_mat\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\ns_deg_u_mat\n\n Jen  Tom  Bob Leaf  Jim \n0.25 0.50 0.75 0.50 0.50 \n\n\nWe can also examine the average degree of the graph using\n\\[\\frac{\\sum_{i=1}^g d(n_i)}{g}\\] or\n\\[\\frac{2L}{g}\\]\nwhere L is the number of edges in the graph:\n\nmean_deg &lt;- sum( deg_u_mat ) / dim( u_mat )[1] \n\nmean_deg\n\n[1] 2\n\n# Note that we can also use the mean() function to return this information:\nmean( deg_u_mat )\n\n[1] 2\n\n\n\nWe can also calculate how centralized the graph itself is. Group degree centralization measures the extent to which the actors in a social network differ from one another in their individual degree centralities. Following Wasserman & Faust (1994), an index of group degree centralization can be calculated as:\n\\[C_D = \\frac{\\sum\\limits_{i=1}^g [C_D(n^*) - C_D(n_i)]}{[(g-1)(g-2)]}\\]\nfor undirected graphs where \\(C_D(n^*)\\) is the maximum degree in the graph. We can write out the components of the equation using the max() function:\n\n# In separate pieces\ndeviations &lt;- max( deg_u_mat ) - deg_u_mat\nsum_deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-2 )\ngroup_deg_cent &lt;- numerator/denominator\n\ngroup_deg_cent\n\n[1] 0.4166667\n\n# Or, as a single equation.\ngroup_deg_cent &lt;-( sum( ( ( max( deg_u_mat ) - deg_u_mat ) ) ) ) / ( ( g -1 )*( g - 2 ) )\n\ngroup_deg_cent\n\n[1] 0.4166667"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-directed-binary-graphs",
    "href": "snaca-r-degree-centrality.html#degree-centrality-directed-binary-graphs",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality (Directed Binary Graphs)",
    "text": "Degree Centrality (Directed Binary Graphs)\nIn a directed binary graph, actor degree centrality can be broken down into indegree and outdegree centrality. Indegree, \\(C_I(n_i)\\), measures the number of ties that i receives. For the sociomatrix \\(Xij\\), the indegree for i is the column sum. Outdegree, \\(C_O(n_i)\\), measures the number of ties that i sends. For the sociomatrix \\(Xij\\), the outdegree for i is the row sum.\nAs before, if we have an object of class(matrix) in the workspace, we can use the rowSums() and colSums() functions. However, the colSums() function will return the indegree centrality for i and the rowSums() function will return the outdegree centrality for i.\nFirst, let’s set up our directed graph from the degree centrality lecture:\n\n# First, clear the workspace\nrm( list = ls() )\n\n# Then, build the object\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ),\n  c( 0,0,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ) )\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# Let's set up the coordinates to force the nodes\n# to be in the same position throughout the lab\nset.seed( 507 )\n\n# remove the old object named coords\nrm( coords )\n\n# set the new coordinates\ncoords &lt;- gplot( d_mat )\n\n\n\n# Now, plot the graph (remember to load the sna package)\ngplot(\n  d_mat, \n  gmode=\"digraph\",\n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=1.2,\n  coord = coords\n  )\n\n\n\n\n\n# Let's look at the different centrality scores \n# by assigning them to different objects\nideg_d_mat &lt;- colSums( d_mat )\nodeg_d_mat &lt;- rowSums( d_mat )\n\n# print them out to examine them\nideg_d_mat\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    3    2    2 \n\nodeg_d_mat\n\n Jen  Tom  Bob Leaf  Jim \n   1    1    2    2    2 \n\n\nNow, let’s work this information in the plot. We will want to partition the plotting window using the par() function to show two plots and we want to change the margins using the mar= argument. Use ?par and/or ?mar to view the help on how these work.\n\npar( \n  mfrow=c( 1, 2 ), \n  mar=c( 0.1, 0.5, 4, 0.1) \n  )\n\ngplot(\n  d_mat, \n  gmode=\"digraph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=0.8,\n  label.pos=1,\n  vertex.cex = ideg_d_mat+0.2,\n  main=\"Nodes sized by Indegree\",\n  coord = coords\n  )\n\ngplot(\n  d_mat, \n  gmode=\"digraph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=0.8,\n  label.pos=1,\n  vertex.cex = odeg_d_mat,\n  main=\"Nodes sized by Outdegree\",\n  coord = coords\n  )\n\n\n\n\n\n\n\n\nNote the difference. Which nodes are more central in terms of indegree? What about outdegree?\nAgain, let’s use the RColorBrewer package to help with shading.\n\n# create the objects\ncol_ideg  &lt;- brewer.pal( length( unique( ideg_d_mat ) ), \"Greens\")[ideg_d_mat]\ncol_odeg  &lt;- brewer.pal( length( unique( odeg_d_mat ) ), \"Oranges\")[odeg_d_mat]\n\npar( \n  mfrow=c( 1, 2 ), \n  mar=c( 0.1, 0.5, 4, 0.1) \n  )\n\ngplot(\n  d_mat, \n  gmode = \"digraph\", \n  arrowhead.cex = 0.5, \n  edge.col = \"grey40\", \n  label = rownames( d_mat ),\n  label.col = \"red\",\n  label.cex = 0.8,\n  label.pos = 1,\n  vertex.cex = ideg_d_mat+0.2,\n  vertex.col = col_ideg,\n  main = \"Nodes sized &\\n shaded by Indegree\",\n  coord = coords\n  )\n\ngplot(\n  d_mat, \n  gmode = \"digraph\", \n  arrowhead.cex = 0.5, \n  edge.col = \"grey40\", \n  label = rownames( d_mat ),\n  label.col = \"red\",\n  label.cex = 0.8,\n  label.pos = 1,\n  vertex.cex = odeg_d_mat,\n  vertex.col = col_odeg,\n  main = \"Nodes sized &\\n shaded by Outdegree\",\n  coord = coords\n  )\n\n\n\n\n\n\n\n\n\nStandardized degree centrality, mean degree, and centralization\nLet’s calculate the standardized centrality scores for our directed graph:\n\n# unstandardized or raw centrality\nideg_d_mat &lt;- colSums( d_mat )\nodeg_d_mat &lt;- rowSums( d_mat )\n\n# to calculate g-1, we need to know the number of nodes in the graph\n# this is the first dimension of the matrix\ng &lt;- dim( d_mat )[1]\n\n# now, divide by g-1\ns_i_deg_u_mat &lt;- ideg_d_mat / ( g-1 )\ns_o_deg_u_mat &lt;- odeg_d_mat / ( g-1 )\n\nWe can also examine the average degree of the graph using \\(\\frac{\\sum_{i=1}^g C_I(n_i)}{g} = \\frac{\\sum_{i=1}^g C_O(n_i)}{g}\\) or \\(\\frac{L}{g}\\), where L is the number of edges in the graph:\n\nmean_i_deg &lt;- sum( ideg_d_mat ) / dim( d_mat )[1] \nmean_o_deg &lt;- sum( odeg_d_mat ) / dim( d_mat )[1] \nmean_i_deg\n\n[1] 1.6\n\nmean_o_deg\n\n[1] 1.6\n\n# we could also use the mean() function\nmean( ideg_d_mat )\n\n[1] 1.6\n\nmean( odeg_d_mat )\n\n[1] 1.6\n\n\nAgain, following Wasserman and Faust (1994), an index of group indegree/outdegree centralization can be calculated as:\n\\[ C_D = \\frac{\\sum\\limits_{i=1}^g [C_D(n^*) - C_D(n_i)]}{[(g-1)^2]} \\]\nfor undirected graphs where \\(C_D(n^*)\\) is the maximum indegree/outdegree in the graph. We can write out the components of the equation using the max() function:\n\n# In separate pieces\ndeviations &lt;- max( ideg_d_mat ) - ideg_d_mat\nsum_deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-1 )\ngroup_i_deg_cent &lt;- numerator/denominator\ngroup_i_deg_cent\n\n[1] 0.4375\n\ndeviations &lt;- max( odeg_d_mat ) - odeg_d_mat\nsum.deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-1 )\ngroup_o_deg_cent &lt;- numerator/denominator\ngroup_o_deg_cent\n\n[1] 0.4375\n\n# Or, as a single equation\ngroup_i_deg_cent &lt;-( sum( ( ( max( ideg_d_mat ) - ideg_d_mat ) ) ) ) / ( ( g -1 )*( g - 1) )\ngroup_o_deg_cent &lt;-( sum( ( ( max( odeg_d_mat ) - odeg_d_mat ) ) ) ) / ( ( g -1 )*( g - 1 ) )\ngroup_i_deg_cent\n\n[1] 0.4375\n\ngroup_o_deg_cent\n\n[1] 0.125\n\n\nWhat do the centralization scores tell us, conceptually?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-using-the-sna-package",
    "href": "snaca-r-degree-centrality.html#degree-centrality-using-the-sna-package",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality using the sna Package",
    "text": "Degree Centrality using the sna Package\nDid that feel tedious? If no, go back and do it again :)\nAs you probably have guessed, there are functions in the sna package that calculate degree centrality and graph centralization! In the sna package, these are the degree() and centralization() functions, respectively. Let’s take a look at how these work.\n\n# load the library\nlibrary( sna )\n\n# Build the objects to work with\nrm( list = ls() )\n\nu_mat &lt;- rbind( \n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ), \n  c( 0,1,0,1,1 ), \n  c( 0,0,1,0,1 ), \n  c( 0,0,1,1,0 )\n  )\n\nrownames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\ncolnames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ), \n  c( 0,0,0,1,1 ), \n  c( 0,0,1,0,1 ), \n  c( 0,0,1,1,0 )\n  )\n\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n\n# First, let's look at degree\n?degree\n\n# degree for undirected graph\ndeg &lt;- degree( u_mat, gmode=\"graph\" )\n\n# indegree for directed graph\nideg &lt;- degree( d_mat, gmode=\"digraph\", cmode=\"indegree\" )\n\n# outdegree for directed graph\nodeg &lt;- degree( d_mat, gmode=\"digraph\", cmode=\"outdegree\" )\n\n# returns the combined centrality for each node\ndeg_d &lt;- degree( d_mat, gmode=\"digraph\" )\n\n\n# Now, let's look at centralization\n?centralization\n\n# degree centralization for undirected graph\ncent_u &lt;- centralization( u_mat, degree, mode=\"graph\" )\n\n# indegree centralization for directed graph.\ni_cent_d &lt;- centralization( d_mat, degree, mode=\"digraph\", cmode=\"indegree\" ) \n\n# outdegree centralization for directed graph.\no_cent_d &lt;- centralization( d_mat, degree, mode=\"digraph\", cmode=\"outdegree\" )\n\nNow, wasn’t that easier?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-in-pins-get-along-with-and-powerinfluence-networks",
    "href": "snaca-r-degree-centrality.html#degree-centrality-in-pins-get-along-with-and-powerinfluence-networks",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality in PINS Get Along With and Power/Influence Networks",
    "text": "Degree Centrality in PINS Get Along With and Power/Influence Networks\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collection sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:\n\nThe get along with network was created by asking individuals whom they “get along with” on the unit. We can think of this as “friends” in a prison setting. (People don’t really have “friends” in prison, but there are people they “get along with”)\nThe power and influence network was created by asking individuals whom they believed was “powerful and influential” on the unit.\n\nLet’s examine the degree centrality scores for both of these networks.\n\nGet Along With Network (Undirected Network)\nFor the get along with network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. But, we are going to symmetrize the network by only taking ties for which both i and j indicated that the get along with the other person. This will give us an undirected network.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-getalong-w1-adj.csv\"\n\n# read in the .csv file\nga_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# use the symmetrize() function to create an undirected matrix\nga_mat_u &lt;- symmetrize( ga_mat, rule = \"strong\" )\n\n# create the network object\nga_net_u &lt;- as.network( ga_mat_u, directed = FALSE )\n\nNow we have created an undirected network where ties represent “get along with” nominations from both individuals. Let’s calculate the degree centrality scores, the centralization score, and then use the degree centrality scores to size our nodes in a plot using the vertex.cex() argument in the gplot() function.\n\n\n# Set the coordinates\nset.seed( 507 )\ncoords &lt;- gplot( ga_net_u )\n\nNow lets build the objects and the plot:\n\n# get the degrees.\nga_net_deg &lt;- degree( ga_net_u, gmode=\"graph\" )\n\n# now the centralization score.\nga_net_deg_cent &lt;- centralization( ga_net_u, degree, mode=\"graph\" )\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = ga_net_deg,\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\nWoops! Let’s try that again AFTER rescaling the degree. We can use the rescale() function to do this.\n\n# define the rescale function\nrescale &lt;- function( nchar, low, high ){\n  min_d &lt;- min( nchar )\n  max_d &lt;- max( nchar )\n  rscl  &lt;- ( ( high - low )*( nchar - min_d ) ) / ( max_d - min_d ) + low\n  rscl\n}\n\nNow we can plot it after adding in the rescale() function to gplot():\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = rescale( ga_net_deg, 0.2, 4 ),\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\n\n\n\n\nAlmost there! Let’s drop the isolates to help with the size:\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = rescale( ga_net_deg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the degree centralization score of 0.04 indicate?\n\n\n\nPower and Influence Network (Directed Network)\nFor the power and influence network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. We will keep this asymmetry so that we can treat the network as directed.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-power-w1-adj.csv\"\n\n# read in the .csv file\npi_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# create the network object\npi_net_d &lt;- as.network( pi_mat, directed = TRUE )\n\nNow we have created an undirected network where ties represent “get along with” nominations from both individuals. Let’s calculate the degree centrality scores, the centralization score, and then use the degree centrality scores to size our nodes in a plot using the vertex.cex() argument in the gplot() function.\n\n# Set the coordinates\nset.seed( 507 )\ncoords2 &lt;- gplot( pi_net_d )\n\n\n# get the degrees.\npi_net_ideg &lt;- degree( pi_net_d, gmode=\"digraph\", cmode = \"indegree\" )\npi_net_odeg &lt;- degree( pi_net_d, gmode=\"digraph\", cmode = \"outdegree\" )\n\n# now the centralization scores.\npi_net_ideg_cent &lt;- centralization( pi_net_d, degree, mode=\"digraph\", cmode = \"indegree\" )\npi_net_odeg_cent &lt;- centralization( pi_net_d, degree, mode=\"digraph\", cmode = \"outdegree\" )\n\n\npar( mfrow=c( 1, 2 ) )\n\ngplot( \n  pi_net_d, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#693859\",\n  vertex.cex = rescale( pi_net_ideg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords2,\n  main = \"PINS Power/Influnece\\n Network (Directed)\",\n  sub = \"node sized by indegree centrality\"\n  )\n\ngplot( \n  pi_net_d, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#2b868c\",\n  vertex.cex = rescale( pi_net_odeg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords2,\n  main = \"PINS Power/Influnece\\n Network (Directed)\",\n  sub = \"node sized by outdegree centrality\"\n  )\n\n\n\n\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the indegree centralization score of 0.07 indicate?\nWhat does the outdegree centralization score of 0.04 indicate?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#test-your-knowledge-excercises",
    "href": "snaca-r-degree-centrality.html#test-your-knowledge-excercises",
    "title": "Degree Centrality and Centralization",
    "section": "Test Your Knowledge Excercises",
    "text": "Test Your Knowledge Excercises\n\nFor the undirected binary graph u_mat, calculate the degree centrality for each node manually. Verify your results using the colSums() function. What does the degree centrality of each node represent in this network? Which node has the highest degree centrality? Why do you think this is the case?\nIn the example above, nodes were plotted with sizes proportional to their degree centrality. Using the shaded plot, describe the relationship between node size and shade intensity. Which node has the darkest shade? Explain what this represents in terms of degree centrality.\nCalculate the standardized degree centrality for u_mat. How does standardizing degree centrality help in comparing nodes across networks of different sizes?\nCompute the degree centralization for u_mat manually and verify it using the centralization() function. What does the result tell you about the network’s structure?\nFor the directed graph d_mat, compute both indegree and outdegree centrality for each node using colSums() and rowSums(). Plot the graph with nodes sized by indegree and outdegree separately. Which nodes are most central in terms of indegree? What does this imply about their role in the network? Which nodes are most central in terms of outdegree? What does this imply?\nFor the Get Along With network, describe the significance of symmetrizing the network. Interpret the degree centrality scores and the centralization score. What does the structure of this network suggest about relationships in the unit?\nFor the Power/Influence network, compare and contrast the plots sized by indegree and outdegree centrality. What do the indegree and outdegree centralization scores suggest about the distribution of power and influence in the network?\nCompare the degree centralization scores for the undirected Get Along With network and the directed Power/Influence network. Which network is more centralized? How does the type of network (undirected vs. directed) influence the interpretation of centralization?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#tutorial-summary",
    "href": "snaca-r-degree-centrality.html#tutorial-summary",
    "title": "Degree Centrality and Centralization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced the concept of degree centrality, a measure of node importance based on connectivity within a network, and explores its calculation and visualization for both undirected and directed graphs in R. For undirected graphs, degree centrality is computed using row or column sums, and standardized to account for network size. Directed graphs distinguish between indegree and outdegree centrality, reflecting incoming and outgoing connections, respectively. The tutorial demonstrated graph centralization, highlighting the variability in node centrality within a network. Visualization techniques, including node sizing and shading based on centrality scores, were covered, alongside practical applications using real-world data from the Prison Inmate Networks Study (PINS), where networks like “Get Along With” and “Power/Influence” are analyzed. The use of R’s sna package simplifies centrality calculations and graph plotting, enabling users to gain insights into the structure and dynamics of social networks.\n\n\n\n\nWasserman, Stanley, and Katherine Faust. 1994. Social Network Analysis: Methods and Applications. Vol. 8. Structural Analysis in the Social Sciences. Cambridge, UK: Cambridge University Press."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Wasserman, Stanley, and Katherine Faust. 1994. Social Network\nAnalysis: Methods and Applications. Vol. 8. Structural Analysis in\nthe Social Sciences. Cambridge, UK: Cambridge University Press."
  }
]