[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Social Network Analysis for Crime Analysts using R",
    "section": "",
    "text": "Preface\nThe field of crime analysis is rapidly evolving, driven by advancements in technology and the growing availability of rich, complex data. Among the most pressing challenges for crime analysts is the need to make sense of these data, particularly when they involve relationships between individuals, groups, or organizations. Social network analysis (SNA) provides a powerful set of tools for mapping and understanding these connections, enabling analysts to uncover patterns, identify key players, and generate actionable insights. This book, Social Network Analysis for Crime Analysts using R, is designed to bridge the gap between theory and application, offering crime analysts a practical guide to using R, an open-source statistical programming language, and RStudio, an integrated development environment that provides a user-friendly interface for coding, data analysis, visualization, and report generation.\nWhy R and RStudio? RStudio is more than just software. It provide a robust ecosystem that empowers users to wrangle, visualize, and analyze data with precision and flexibility. For crime analysts, learning the R language and how to work in RStudio offers a significant advantage: they are free, widely supported by a global community, and capable of handling the types of network data that traditional tools struggle to process. With RStudio, analysts can customize workflows, automate repetitive tasks, and leverage advanced techniques such as clustering algorithms, centrality measures, and visualization methods: all essential for modern SNA. By working in RStudio, even those new to programming can gain the confidence to manipulate data and produce meaningful outputs. The ability to write reproducible code also ensures that analyses are transparent and can be revisited or adapted as cases evolve.\nThis book is written with the unique needs of crime analysts in mind. Using real-world examples and step-by-step instructions, it demonstrates how SNA can be conducted in Rstudio to solve practical problems, from identifying influential actors in a gang network to assessing the vulnerability of criminal enterprises. The focus is not only on teaching the mechanics of RStudio but also on fostering a deeper understanding of the concepts behind social network analysis. Whether you are new to network analysis or seeking to expand your analytic toolkit, this book will provide you with the skills and confidence to harness the power of RStudio and SNA in your work. Together, these tools can transform how crime analysts approach data, enabling them to uncover critical insights and ultimately contribute to safer communities.\nThis book is a companion to Social Network Analysis for Crime Analysts. It is organized as tutorials that show the “how to” of SNA in RStudio that correspond to conceptual chapters in the Social Network Analysis for Crime Analysts textbook.\nThis book will use a custom R package, SNACpack, that is specifically designed as a companion as you go through the materials. Packages are a fundamental part of the R ecosystem—they allow users to bundle together functions, data, and documentation in a structured and reusable format. Throughout the course, we will rely on a variety of packages, both from the broader R community and those purpose-built to support our specific learning goals. SNACpack contains curated datasets and functions designed to simply learning. By working with packages like SNACpack, you will not only gain proficiency in applied social network analysis, but also build habits and skills that translate to broader data science practices in R.\nEach tutorial in this book will contain R code which is in “code chunks”. You will notice a code chunk because the font will change. Code chunks will have text that looks like this. There is also regular text. The R code chunks can be copied and pasted directly into R and RStudio. As you work through the tutorials, follow along in the software by coping and pasting the code and seeing it work on your end.\nLet’s get to it!",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "snaca-r-intro-to-r.html",
    "href": "snaca-r-intro-to-r.html",
    "title": "Getting Started with R",
    "section": "",
    "text": "10 Things about R to get you started:\nIn this tutorial, you will be introduced to the programming language R. The tutorial is designed for those who have no experience with R. We begin with what R is, how you install it, and work through how to navigate the environment. We will also cover RStudio. Even if you have used R and/or RStudio before (awesome!), I would encourage you to review the tutorial as a refresher.\nAs a reminder, this tutorial (and the tutorials throughout this book) will contain R code which is in “code chunks”. You will notice a code chunk because the font will change. Code chunks will have text that looks like this. There is also regular text. The R code chunks can be copied and pasted directly into R and RStudio. As you work through the tutorials, follow along in the software by copying and pasting the code and seeing it work on your end.",
    "crumbs": [
      "Getting Started with R"
    ]
  },
  {
    "objectID": "snaca-r-intro-to-r.html#things-about-r-to-get-you-started",
    "href": "snaca-r-intro-to-r.html#things-about-r-to-get-you-started",
    "title": "Getting Started with R",
    "section": "",
    "text": "1. What is R\nR is a dialect of the S language that was written by John Chambers and others at Bell labs in the 70s. In the 90s, R was developed and made available to the public with the GNU general public license. Importantly, R is free, meaning that you don’t have to pay for it (duh), but it is also open source, meaning that you have freedom to use and modify it.\nThink of R as an operating system. Just as Windows allows you to turn on your computer, open a web browser, move files around, and write a paper using MS Word, R allows you to install and run packages, perform analyses, and manage files while organizing data for crime analyst projects. Just like Windows would be a very boring piece of software without all of the applications you run while on the computer, R would be a boring language without all of the packages it can run.\n\n\n2. Installing and Starting\nGo to http://cran.r-project.org. Find the “Download R for…” link that is appropriate for your operating system.\nWhen R starts it loads some basic info and provides you with a prompt: &gt;\nThis prompt is the fundamental entry point for communicating with R. We type expressions at the prompt, R evaluates these expressions, and returns output.\n\n\n3. Objects in R\nR is a programming language. That means, it allows us to give instructions to our computer to do stuff. We will see that there is a lot of “stuff” we can do. But, the basic orientation to R is understanding objects.\nWhat is an object? Without getting too philosophical, an object is something we create in the R environment. To help, consider this analogy: think of an R session as a box. As we give different instructions to R, we are creating objects and putting them into the box. We are also telling R to do different things to these objects. This may seem unusual at first as it is quite different from data analysis programs like SPSS or Stata which are spreadsheet oriented.\nWe create objects by using the assignment operator: &lt;-\nWhat you type on the right is assigned to what you type on the left. For example:\ny &lt;- 4 (we have assigned the value 4 to the object y)\nx &lt;- 6 (we have assigned the value 6 to the object x)\nz &lt;- y (we have assigned the value of the object y to the object z, i.e. z = 4)\nAfter assigning a value to an object, type the name of the object and hit return/enter to see what the value is.\nObjects can start with a letter or a period. But, you cannot name an object starting with a number (or other symbols used by R).\nSome examples:\nthe.number.two &lt;- 2\n2 &lt;- the.number.two\n2.the.number &lt;- 2\n;.2 &lt;- 2\nR is case sensitive (i.e. A is a different object than a). R is insensitive to white space though.\nThese two examples are treated the same in R:\nx &lt;- 2\nx&lt;-              2\nTo have R ignore text, use the # sign to make comments.\nFor example: x &lt;- 2 # this assigns the value 2 to object x.\nIn R there are no carriage returns (e.g. Stata uses /// in code). Sorry :(",
    "crumbs": [
      "Getting Started with R"
    ]
  },
  {
    "objectID": "snaca-r-intro-to-r.html#functions-in-r",
    "href": "snaca-r-intro-to-r.html#functions-in-r",
    "title": "Getting Started with R",
    "section": "4. Functions in R",
    "text": "4. Functions in R\nA major strength of R is the ability to manipulate objects using functions. A function takes an argument (aka input) and returns some value (aka output).\nFor example, suppose we wanted to create a list of numbers, called a vector. We want to create an object that is defined by the list of numbers. In R, there is a preprogrammed function c(), which combines or concatenates values to create a single object. We can create an object x, that is a vector of 1, 2, 3, 4, and 5 using: x &lt;- c(1,2,3,4,5).\nThis reads: the object x is assigned the values 1, 2, 3, 4, and 5. The function is “c” and the argument is 1,2,3,4,5.\nThe number of values (aka elements) a vector contains is referred to as the “length”. We can use the length() function to return this information for us. For example: length(x) shows that the vector x has 5 values or elements.\nReminder: R is a language, so part of the learning curve is getting familiar with the names of functions.",
    "crumbs": [
      "Getting Started with R"
    ]
  },
  {
    "objectID": "snaca-r-intro-to-r.html#referencing-and-indexing-objects-in-r",
    "href": "snaca-r-intro-to-r.html#referencing-and-indexing-objects-in-r",
    "title": "Getting Started with R",
    "section": "5. Referencing and Indexing Objects in R",
    "text": "5. Referencing and Indexing Objects in R\nIn R, specific elements in an object are referenced by using brackets (i.e. [ or ]).\nFor example, let’s create a vector and work with it:\n\nx &lt;- c( 1,2,3,4,5 ) # create the vector.\nx\nx[5] # what is the fifth element  in x?  \nx[2:4] # what are the second through fourth elements in x?  \nx[ c( 1,4 )] # what are the first and fourth elements in x?  \n\nNote the difference in use between [#:#] and [c(#,#)]. The colon : means “through” and the comma , means “and”.\nWe can also change values by indexing:\n\nx[5]   &lt;- 3 # change the fifth element in x to 5.  \nx[1:5] &lt;- 0 # change the first through fifth elements in x to 0.  \n\nUsing brackets to identify particular elements, called indexing, is VERY useful. By using indexing, we can create objects from other objects, or reference particular locations. The utility of this will be more obvious later.\n\n6. Types of objects (“classes”) in R\nObjects in R can be of different types or classes. There are four:\n\nnumeric, a number (e.g. 1, 2)\ncharacter, a letter or word (e.g. \"Shelley\", \"Trevor\")\nfactor, a category (e.g. female, male)\nlogical, True or False values (e.g. TRUE, FALSE)\n\nEach type of vector serves different purposes:\n\nnumeric: keep track of quantitative measures, counts, or orders of things\n\ncharacter: store non-numeric data, typically unstructured text\n\nfactor: represent distinct and mutually-exclusive categories\n\nlogical: designate cases that meet some criteria, usually group inclusion\n\nFor example, let’s build a few objects:\n\nnums &lt;- c( 1, 2, 3 )\nnames &lt;- c( \"Shelley\", \"Trevor\" )\nsex &lt;- factor( c( \"female\", \"male\" ) )\nis_female &lt;- sex == \"female\"\n\nNote that numbers do not require \" \" around them but characters do require \" \" around them. Also, that the object is.female is created by stating a condition.\nEach object has a class, which defines the “type” of vector a particular object is:\n\nname_list &lt;- c( \"Hugo\",\"Desmond\",\"Largo\" ) # assign the characters to an object.\nis.character( name_list ) # is the object a character vector?\nis.numeric( name_list ) #is the object a numeric vector?  \nis.factor( name_list ) # is the object a factor vector?\nis.logical( name_list ) # is the object a logical vector?\n\nMissing values are dealt with in R by NA.\n\ny &lt;- c( 3,NA,10 ) # create a vector with a missing value.\n2*y # multiple the vector by 2.  \nis.na( y ) # which positions in y have missing values?  \ny[ is.na( y )] #subset meeting condition.\ny[ !is.na( y )] # subset meeting a different condition.\n\n\n\n7. Matrices in R\nIn addition to vectors, we can create a matrix, which is a 2-dimensional representation of data. A matrix has dimensions r X c which means rows by columns. The number of rows and columns a matrix has is referred to as its “order” or “dimensionality”. This information is returned by using the dim() function. Matrices can be created by combining existing vectors using the rbind() and cbind() functions. The rbind() function means “row bind” and binds together vectors by rows. Think of it as stacking vectors on each other. The cbind() function means “column bind” and binds together vectors by rows. Think of it as placing them side by side. Let’s take a look:\n\nx  &lt;- c( 6,5,4,3,2 )\ny  &lt;- c( 8,7,5,3,1 )\nm1 &lt;- rbind( x,y ) #bind x and y by row to create a 2 X 5 matrix.\nm1 #just enter the name of the object to print it.\nm2 &lt;- cbind( x,y ) #bind x and y by column to create a 5 X 2 matrix.\nm2 #just enter the name of the object to print it.\n\nFor both functions, the dimensions of the vectors must be the same (i.e. same number of rows and columns).\nLet’s see some examples:\n\nl  &lt;- c( 6,5,4,3,2 )\nn  &lt;- c( 8,7,5 )\nm2 &lt;- rbind( l,n ) # returns an error because the dimensions differ.\n\nWe can index the matrix m1 or m2 by using the brackets [ ] with a comma between the two dimensions. Since a matrix is 2-dimensions, we can reference a specific element, an entire row, or an entire column:\n\nm1[2,2] #what is the value of the element in the 2nd row, 2nd column?\nm1[,2]  #what are the values in the second column?\nm1[2,]  #what are the values in the second row?\n\n\nm2[2,2] &lt;- 0 #change the value to zero.\nm2[2,]  &lt;- 0 #change the second row to zeros.\nm2[,2]  &lt;- 0 #change the second column to zeros.\n\nIn the code chunk above, note the difference between [,#] and [#,]. A comma in front of the argument (i.e. [,#]) applies to the columns) and a common after the argument (i.e. [#,]) applies to the rows.\nAlso, notice that m1[2,2], is an object, just as m1 is an object. In effect, we are subsetting the object m1 when we index it.\nMatrices can also be created from a list of numbers using the matrix() and c() functions.\n\nm3 &lt;- matrix( c( 1,0,1,0,0,1,0,1,0 ),nrow=3,ncol=3 )\nm3\n\n\n\n8. One of the most important functions in R: help()\nA useful feature of R is an extensive documentation of each of the functions. To access the main R help archive online, type: help.start()\nThe help() function, or a simple ?, can be used to get help about a specific function. For example: help(c) or ?c returns the help page for the c() function.\nTake a look at the help page. The first line shows you the function and the package it is written for in brackets (more on packages below). The help page provides a description, how to use it (i.e. what are the arguments), and a description of what each argument does. Further details and examples are provided as well.\nLet’s take a look at another function that creates sequences of numbers, the seq( ) function. There are several ways to use the seq( ) function. The most common are:\n\nseq( from=, to=, by= ) # Starts at from, ends at to, steps defined by by.\nseq( from=, to=, length= ) # Starts at from, ends at to, steps defined by length.  \n\nFor example:\nif we want to create an object of 5 values that starts with 1 and ends with 5, we type: seq( from=1, to=5, by=1 ).\nif we want to create an object of 5 values that starts with 1 and ends with 9, we type: seq( from=1, to=9, by=2 ).\nWe could also have used the length= argument: seq( from=1, to=10, length=5 ).\nSince R knows that from= or to= or by= or length= are arguments, we do not have to type them in the syntax: seq( 1, 9, 2 ) is identical to seq( from=1, to=9, by=2 ) (as far as R is concerned).\nFor the help function to work, you need to know the exact name of the function. If you don’t know this, but have a fuzzy idea of what it might be or what you want the function to do, you can use the help.search(\"fuzzy notion\") function (or just put ?? in front of the word).\nFor example, say you want to calculate the standard deviation for an object, but do not know the function name. Try: help.search( \"standarddeviation\" ) or ??standarddeviation (note the absence of a space). This returns the list of help topics that contain the phrase. We see that the standard deviation function is called sd().\n\n\n9. Packages and the install.packages() and library() Functions\nR has MANY preprogrammed functions that are automatically loaded when you open the program. Functions are stored in “packages”. Although there are many preprogrammed functions, there are even MORE functions that you can install on your own. A package in R is a collection of functions, usually written for a specific purpose.\nWe can see the packages available from CRAN at http://cran.r-project.org/. Just click on the “packages” link or go to https://cran.r-project.org/web/packages/index.html. There is a WIDE variety of packages available (tens of thousands of packages are available!), this is another reason why R is awesome. If you can think it, someone has probably written a package for it in R (and if not, you can write one and contribute). Isn’t it great!!! What a time to be alive!\nTake a few moments and look through the packages by following this link: packages by name.\nIf there is a particular package you want to add, you simply use the install.packages() function like this: install.packages(\"package name\").\nAfter the package is installed on your machine, you do not (I repeat NOT) need to reinstall the package each time you open a new session. Rather, you just need to load the package using the library() function like this: library(\"package name\"). The install.packages() function is getting the package contents and installing it on your machine. The library() function is simply loading the package.\nNote that each time you open R you have to load any packages that you manually loaded using the install.packages() function. In other words, if we closed R and then reopened it, we would need to type library( \"sna\" ) to load the functions in sna. Note that we do not have to reinstall the package using install.packages(), we just have to load the library.\nIf you have installed the package, but have not loaded it, R will return an error saying that a particular function is not found.\nFor example, the function rgraph() in the package sna (which is a set of tools for working with social networks) is used to create random graphs. Type ?rgraph and you get an error stating that there is no documentation available. This is because the sna library has not been loaded (even if you have installed sna). Typing install.packages( \"sna\" ) and library( sna ) prior to ?rgraph() will solve this problem.\n\nInstalling Packages from Other Locations: SNACpack Package\nWhen you use the install.packages() function, you are access packages that are stored on CRAN’s website. As you become more accustomed with using R, you will notice that there are a lot of packages that are not on CRAN. As was mentioned in the Preface, SNACpack is an R package specifically designed for the Social Network Analysis for Crime Analysts using R book. This package is not on CRAN, rather it is located on Github, which is an online repository for storing code and various projects. To install the SNACpack package, we need to first install a package called devtools because it has a function install_github() that we will use to install the SNACpack package. (If this seems like a lot of info, it is!, but hang in there!).\nTo install SNACpack, let’s use the following code chunk:\n\n# first install the devtools package\ninstall.packages( \"devtools\" )\n\n# now, load the devtools package\nlibrary( devtools )\n\nOk, no we are ready to use the install_github() function. For this function to work, you need to know the location of the package you want to install. The location of the SNACpack package is: jacobtnyoung/SNACpack. If you want, you can access the repository using this link: https://github.com/jacobtnyoung/SNACpack. Now that we have the location, we can install it:\n\n# install the package\ninstall_github( \"jacobtnyoung/SNACpack\" )\n\n# now, load the library\nlibrary( SNACpack )\n\nDone! Take a look at the package using help( package = \"SNACpack\" ) to get a sense of what it contains (don’t worry, we will be going through this in more detail throughout the tutorials).\n\n\nPackage Dependence\nSome packages require other packages for them to work. If there is an error, you need to install the additional packages. Usually these will install automatically. For example, when you installed SNACpack above, you might have noticed a line stating that it also installed plotrix. This is a package that is used by one of the functions in SNACpack, so it installs it for you.\nA final point on loading packages. Since anyone can write and contribute packages to R, it is not surprising that some packages occasionally use the same names for functions. When you have loaded libraries for packages that have conflicting functions, R will output a message indicating there is an issue.\nFor example, the sna package and the tnet package both have a function called betweenness, but the functions are programmed differently. When you load tnet after loading sna (or visa versa), R will give you a warning that an “object is being masked”. That means the functionality of betweenness in sna is no longer used. Let’s check it out:\n\ninstall.packages( \"sna\" )\nlibrary( sna )\n\ninstall.packages( \"tnet\" )\nlibrary( tnet )\n\nThis can be a bit frustrating. In such cases, you can unload the package using the detach() function. See: ?detach for an example.\n\n\n\n10. R Session Management\nAll variables created in R are stored in the “workspace”. Think of it as a work bench that has a bunch of stuff on it that you have created.\nTo see what exists in the workspace, type: ls().\nWe can remove specific variables with the rm() function. This helps clear up space (i.e. conserve memory). For example:\n\nx &lt;- seq( 1,5,1 ) # create the object.\nls()          # see the objects.\nrm( x )         # remove the object x.\nls()          # no more x.\n\nTo remove everything from the workspace use: rm( list=ls() ). This is helpful for starting a session to make sure everything is cleaned out.\nWhen you start R, it nominates one of the directories on your hard drive as a working directory, which is where it looks for user-written programs and data files.\nTo determine the current directory, type: getwd().\nYou can set the working directory also by typing: setwd(\"your desired directory here\").\nFor example, if you are using Windows OS and want to set your directory to be the “C” drive, type: setwd( \"C:/\" ). NOTE: when you copy and paste filepaths in Windows, the folders are denoted with \\, while R uses /.\nOr, if you are using Mac OS and want to set your directory to be a folder called “Users”, type: setwd( \"/Users\" ).\nOn the Windows OS you can set R to automatically start up in your preferred working directory by right clicking on the program shortcut, choosing properties, and completing the ‘Start in’ field. On the Mac OS you can set the initial working directory using the Preferences menu.\nTo save the workspace use the save.image() function. This function requires a file path, a file name, and the extension “.RData” which is the format for an R workspace file.\nFor example, to save a workspace called “OurFirstTutorial” to the current directory, simply type: save.image(\"OurFirstTutorial.Rdata\"). You can also write in the directory of you want to save it somewhere else. You can also do this by the pull-down menu with the File/Save option.\nTo load a previously saved workspace, you can either click on the file outside of R or use the load() function (e.g. load(\"OurFirstTutorial.Rdata\")). If you get an error, make sure you are referring the correct directory. You can also choose Load Workspace from the pull-down menu.\nNote that only the objects in the workspace are saved, not the text of what you have written.\n\n\n11. (Bonus!) RStudio\nYou may be surprised to discover how little functionality is implemented in the standard R GUI (i.e. graphical user interface). The standard R GUI implements only very rudimentary functionality through menus: reading help, managing multiple graphics windows, editing some source and data files, and some other basic functionality. There are no menu items, buttons, or palettes for loading data, transforming data, plotting data, or doing any real work with data. Commercial applications like SAS, SPSS, and Stata include user interfaces with much more functionality.\nThis was just the nature of working with R until some awesome human beings created RStudio. RStudio is one of several projects to build an easier-to-use GUI for R. It is a free, open-source IDE (i.e. integrated development environment) for working with R. Unlike the standard R GUI, RStudio tiles windows on the screen and puts different windows in different tabs. RStudio can be downloaded from: http://www.rstudio.com.\n\n\nRStudio workthrough\nOk, now open RStudio and let’s take a look!\nNow that you have RStudio up and running, try rerunning some of the code above. You will see that R operates within the RStudio environment. So, you can do everything in RStudio that we did above in R. However, there are more tools available in RStudio.",
    "crumbs": [
      "Getting Started with R"
    ]
  },
  {
    "objectID": "snaca-r-intro-to-r.html#test-your-knowledge-exercises",
    "href": "snaca-r-intro-to-r.html#test-your-knowledge-exercises",
    "title": "Getting Started with R",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nAfter installing R, what does the &gt; prompt represent?\nCreate an object called a with the value 7.\nWhich of the following is a valid object name?\n\n3cats\n.hidden_data\nmy-object\n_underscore\n\nExplain what the following code does: b &lt;- 10?\nWhat is a function in R? Explain using the c() function as an example.\nCreate an object called numbers that contains the values 2, 4, 6, 8, and 10 using the c() function.\nType the following code: length( numbers ). What is the meaning of the number it returns?\nCreate a vector z with the values 10 through 20. Now, write code to retrieve:\n\nThe 3rd element in z.\nThe 2nd through 5th elements in z.\nThe 1st and last elements in z.\n\nWhat is the difference between z[3:5] and z[ c(3,5) ]?\nWhat is the purpose of the install.packages() function? The library() function?\nWhy might you see a “function not found” error when trying to use a function from a package?\nLook through the packages on the CRAN repository. Find one and install it.",
    "crumbs": [
      "Getting Started with R"
    ]
  },
  {
    "objectID": "snaca-r-intro-to-r.html#tutorial-summary",
    "href": "snaca-r-intro-to-r.html#tutorial-summary",
    "title": "Getting Started with R",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial provides a quick introduction to R and RStudio. R is a versatile and open-source programming language that is well-suited for social network analysis. As we will see, it is one of the best environments for crime analysts to work with social network data and conduct analyses. We began with an overview of R’s history, emphasizing its unique features, such as being free and customizable through numerous packages. The tutorial then guides readers through essential concepts, including installing R, understanding the R environment, and creating objects, which are fundamental building blocks of any R session. Readers learn how to use functions, reference and manipulate objects, and work with different data types (numeric, character, factor, and logical). The tutorial also covers indexing techniques for accessing specific elements within objects and introduces matrices as a two-dimensional data structure. Practical advice is provided on navigating R’s extensive documentation, installing and loading packages, and managing the R workspace effectively. We also installed the SNACpack package that we will use throughtout the tutorials. Finally, we reviewed (briefly) RStudio, a powerful integrated development environment that enhances the R user experience. You are now equipped with foundational skills to explore R further and apply it to real-world data tasks as you continue developing your skills as a crime analyst.",
    "crumbs": [
      "Getting Started with R"
    ]
  },
  {
    "objectID": "snaca-r-rmarkdown.html",
    "href": "snaca-r-rmarkdown.html",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "",
    "text": "Data-Driven Documents\nIn this tutorial, you will be introduced to RMarkdown using RStudio. Learning RMarkdown is essential for crime analysts in criminal justice professions because it allows you to create dynamic, data-driven documents that seamlessly integrate narrative text, statistical analysis, and data visualizations. One of the standout features of RStudio is its ability to produce “reproducible” documents, where all text, analysis syntax, and outputs are maintained in a single file. This eliminates the need to bounce between multiple programs, reducing the risk of errors, and ensuring that your work is fully transparent and repeatable. For crime analysts working with publicly available datasets or collaborating across agencies, this reproducibility is invaluable—it streamlines workflows, fosters accountability, and allows for easy sharing of both the analysis process and results. Mastering RMarkdown not only enhances the efficiency of your reporting but also elevates the integrity and clarity of your analytical work. I hope that sells you on the value of it, so let’s get started!",
    "crumbs": [
      "Creating Data-Driven Documents using RMarkdown"
    ]
  },
  {
    "objectID": "snaca-r-rmarkdown.html#data-driven-documents",
    "href": "snaca-r-rmarkdown.html#data-driven-documents",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "",
    "text": "What are Data-Driven Documents?\nData-driven documents are formats that combine text and analysis (i.e. data and code). By combining everything in a single file, we promote transparency and reproducibility. For any given table, figure, or model in the document, you should be able to easily discern how it was created, from what data, and what analysis was used.\nWe will use the R Markdown format.\nAll of the document formats build from a simple text formatting convention called markdown.\nTo create an R Markdown document, you need three things:\n\nA header to specify the document type\nSome text (formatted in markdown)\nSome code (inside a “code chunk”)\n\nLet’s see how it works!",
    "crumbs": [
      "Creating Data-Driven Documents using RMarkdown"
    ]
  },
  {
    "objectID": "snaca-r-rmarkdown.html#rmarkdown-in-rstudio",
    "href": "snaca-r-rmarkdown.html#rmarkdown-in-rstudio",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "RMarkdown in RStudio",
    "text": "RMarkdown in RStudio\nFirst, you need to install the rmarkdown and knitr packages using:\n\ninstall.packages( \"rmarkdown\" )\ninstall.packages( \"knitr\" )\n\nHere is a diagram of how to open an RMarkdown file and create an output file:\n\n\n\n\n\nsequenceDiagram\n    participant User\n    participant RStudio\n    User-&gt;&gt;RStudio: Open RStudio\n    User-&gt;&gt;RStudio: File &gt; New File &gt; RMarkdown...\n    RStudio--&gt;&gt;User: RMarkdown template setup window\n    User-&gt;&gt;RStudio: Specify title, author, and output format (e.g., HTML, PDF, Word)\n    User-&gt;&gt;RStudio: Click \"OK\"\n    RStudio--&gt;&gt;User: Generates a new RMarkdown file\n    User-&gt;&gt;RStudio: Start editing text and adding code chunks\n    User-&gt;&gt;RStudio: Save the file (.Rmd extension)\n    User-&gt;&gt;RStudio: Click \"Knit\" to generate the output document\n\n\n\n\n\n\n\nLet’s walk through this. First, you need to open RStudio. Then, using the dropdown menu select File &gt; New File &gt; RMarkdown. This will bring up the RMarkdown template window. In this window, you can specify the title, author, and output format. Click “OK” and RStudio will create a new RMarkdown file. An RMarkdown file has two essential pieces: text and code chunks (discussed more below). The last piece is to click the “Knit” button to create the output document.\n\nA Closer Look\n\nKnitting R Markdown Files\nCode is placed inside of “chunks” in the documents:\n\nWhen you “knit” a file RStudio will run all of code, embed the output into your document, and then convert the file to whichever type you have specified in the file header.\n\n\n\nOutput Types\nYou can select from many different document types, including HTML pages, Microsoft word, presentation formats, or dashboards.\nCheck out these examples:\nR Markdown Formats R Markdown Gallery\n\nHTML Pages\n---\noutput: html_document\n---\n\n\n\n\nDashboards\n---\noutput: flexdashboard::flex_dashboard:\n---\n\n\n\nPDFs\n---\noutput: pdf_document\n---\n\nA note on PDFs\nIf you would like to knit to PDF you need one additional program. TeX creates publication-quality PDF files. The open-source version is called MiKTeX download page.\nIf you have problems, you can find some nice tutorials like this one: https://www.reed.edu/data-at-reed/software/R/r_studio_pc.html\n\n\n\n\nWorking with Markdown\nMarkdown is a set of simple conventions for formatting text in R Markdown (.RMD) files. It makes it easy to create professional documents with minimal effort. Here are the basic formatting rules for Markdown:\n\nHeaders\n# Heading One (h1)\n\n## Heading Two (h2)\n\n### Heading Three (h3)\n\n#### Heading Four (h4)\n\n##### Heading Five (h5)\n\n###### Heading Six (h6)\n\n\nText Style\nWith Markdown, it is possible to emphasize words by making them *italicized*, using *asterisks* or _underscores_, or making them **bold**, using **double asterisks** or __double underscores__. \n\nOf course, you can combine those two formats with both _**bold and italicized**_ text using any combination of the above syntax. \n\nYou can also add a strikethrough to text using a ~~double tilde~~.\nWith Markdown, it is possible to emphasize words by making them italicized, using asterisks or underscores, or making them bold, using double asterisks or double underscores.\nOf course, you can combine those two formats, with both bold and italicized text, using any combination of the above syntax.\nYou can also add a strikethrough to text using a double tilde.\n\n\nLists\n\nUnordered\n* First item\n* Second item\n* Third item\n    * First nested item\n    * Second nested item\n\nFirst item\nSecond item\nThird item\n\nFirst nested item\nSecond nested item\n\n\n\n\nOrdered\n1. First item\n2. Second item\n3. Third item\n    1. First nested item\n    2. Second nested item\n\nFirst item\nSecond item\nThird item\n\nFirst nested item\nSecond nested item\n\n\n\n\n\nHyperlinks\nCreate links by wrapping the link text in square brackets [ ], and the URL in adjacent parentheses ( ).\n[Google News](https://news.google.com)\nGoogle News\n\n\nImages\nInsert images in a similar way, but add an exclamation mark in front of square brackets [ ], and the image file name goes in the parentheses ( ).\n![alt_text_here](image_file.png)\nThe alt text appears when the image cannot be located, or is read by devices for the blind when the mouse hovers over the image. It\nOr you can link directly to an image online using the URL address of the image:\n![](https://www.rodaw.com/wp-content/uploads/2017/02/Mark-Down-MonsterDogLampShade-1.jpg)\n\n\n\nTables\n| Title 1          | Title 2          | Title 3         | Title 4         |\n|------------------|------------------|-----------------|-----------------|\n| First entry      | Second entry     | Third entry     | Fourth entry    |\n| Fifth entry      | Sixth entry      | Seventh entry   | Eight entry     |\n| Ninth entry      | Tenth entry      | Eleventh entry  | Twelfth entry   |\n| Thirteenth entry | Fourteenth entry | Fifteenth entry | Sixteenth entry |\n\n\n\n\n\n\n\n\n\nTitle 1\nTitle 2\nTitle 3\nTitle 4\n\n\n\n\nFirst entry\nSecond entry\nThird entry\nFourth entry\n\n\nFifth entry\nSixth entry\nSeventh entry\nEight entry\n\n\nNinth entry\nTenth entry\nEleventh entry\nTwelfth entry\n\n\nThirteenth entry\nFourteenth entry\nFifteenth entry\nSixteenth entry",
    "crumbs": [
      "Creating Data-Driven Documents using RMarkdown"
    ]
  },
  {
    "objectID": "snaca-r-rmarkdown.html#tutorial-summary",
    "href": "snaca-r-rmarkdown.html#tutorial-summary",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced you to the power of RMarkdown for creating reproducible, data-driven documents using RStudio. By combining narrative text, code, and analytical outputs into a single file, RMarkdown ensures transparency and efficiency in reporting workflows, eliminating the need to switch between multiple programs. This can be a valuable tool for any crime analyst. We (briefly) covered how to generate various output formats, such as HTML, Word, and PDF, which are customizable to suit different professional contexts. The tutorial also covers the basics of Markdown for text formatting, embedding images, creating tables, and hyperlinks, offering a comprehensive foundation for crafting professional documents.",
    "crumbs": [
      "Creating Data-Driven Documents using RMarkdown"
    ]
  },
  {
    "objectID": "snaca-r-network-data.html",
    "href": "snaca-r-network-data.html",
    "title": "Working with Networks in R",
    "section": "",
    "text": "Working with matrices\nIn the Network Data Structures chapter of the Social Network Analysis for Crime Analysts textbook, we reviewed how networks can be represented as sociomatrices. These matrices form the basic unit of data analysis in SNA. In this tutorial, we will review how we can build networks in R. Why? Understanding how to work with networks in R is essential for crime analysts because networks provide a powerful lens for analyzing relationships and interactions that drive criminal behavior. Whether you’re mapping connections between individuals in a gang, examining the flow of illicit goods, or identifying key actors in a criminal enterprise, networks reveal critical structures and patterns that traditional data analysis might overlook.\nAs a reminder, in the tutorials for this textbook, R code appears like this and can be copied directly into R or RStudio. Let’s start getting our hands dirty (figuratively of course) by building some networks in R!\nFirst, clear the workspace. To do so, we use the following statement:\nrm( list = ls() )\nLet’s start by working with an example of an undirected, binary network. We will create an object that is the adjacency matrix.\nOne way to create an adjacency matrix is to use the matrix() function with the concatenate() or c() function.\nWe can look at what these functions do by asking for help using the help(\" function name here \") or ?(\" function name here \") functions.\nThe help window describes the arguments that the function takes and also provides examples.\n# help for the matrix() function\n?matrix\n\n# help for the c() function\n?c\nNow, let’s create the data object:\nmat &lt;- matrix(\n  c( 0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0 ),\n  nrow=5,\n  byrow=TRUE\n  )\nThis command reads as follows:\nWe can see the object by just typing the object name: mat. Note that if the number of elements does not correctly match the dimensions of the matrix, R gives you an error.\nFor example:\njunk_1 &lt;- matrix( c( 1,2,3,4,5,6,7 ), nrow=2, byrow=TRUE )  \n\n# Because there are 7 elements here, \n# the 8th element needed for a matrix \n# is replaced with the first value in the vector\n\n# print out the object by just typing the name of the object\njunk_1 \n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    1\nAfter we have created our object mat or junk_1, we can examine the dimensions with the dim function: dim( mat ) or dim( junk_1 ).\nWe can also attach names to the rows and columns of the matrix by using the rownames() and colnames() functions.\n# attach row names\nrownames( mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# attach column names\ncolnames( mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# print out the object\nmat\n\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\nWe can refer to specific elements, rows, or columns by using the [ and ] symbols. This reads as: “object[row,column]”. Remember from the Getting Started with R tutorial that I said we would use indexing a lot? Well, this is where that comes true!\nFor example, let’s look at the relation Jen sends to Tom.\nRecall from the Network Data Structures chapter that this is element 1,2 in the matrix (i.e. row one, column two). In R code that is: mat[1,2].\nThis command reads as follows: for the object mat, return the value at row 1 column 2. The row number is the first dimension and the column is the second dimension. Remember: “rows by columns”.\nWe can also call the values for an entire row or column:\n# this reads: return the first row of data\nmat[1,]\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n# this reads: return the first column of data\nmat[,1]\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0\nSince we have defined names for the rows and columns, we can use those as well.\n# reference the ROW pertaining to Jen\nmat[\"Jen\",]\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n# reference the COLUMN pertaining to Jen\nmat[,\"Jen\"]\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0\nNote: the following does not work because it needs a character, defined by the \"\" symbols around the name.\n# returns an error because there is no object called Jen \nmat[,Jen]\n\n# compare the difference with the prior line\nmat[,\"Jen\"]\nWe can also call a series of values:\n# return the first three ROWS of the object data\nmat[1:3,]\n\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nTom   1   0   1    0   0\nBob   0   1   0    1   1\n\n# return the first three COLUMNS of the object data\nmat[,1:3]\n\n     Jen Tom Bob\nJen    0   1   0\nTom    1   0   1\nBob    0   1   0\nLeaf   0   0   1\nJim    0   0   1\nWe can also call a group of values that are non-contiguous using the c() function:\n# return the first and second ROWS of the object data\nmat[c(1,3),]\n\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nBob   0   1   0    1   1\n\n# return the first and second COLUMNS of the object data\nmat[,c(1,3)]\n\n     Jen Bob\nJen    0   0\nTom    1   1\nBob    0   0\nLeaf   0   1\nJim    0   1\nWe can also call a group of values that do not contain specified values by putting a - (i.e. a minus sign) in front of the c function:\n# return the object data without ROWS 1 and 3\nmat[-c(1,3),]\n\n     Jen Tom Bob Leaf Jim\nTom    1   0   1    0   0\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n# return the object data without COLUMNS 1 and 3\nmat[,-c(1,3)]\n\n     Tom Leaf Jim\nJen    1    0   0\nTom    0    0   0\nBob    1    1   1\nLeaf   0    0   1\nJim    0    1   0\nGot it? If yes, then GREAT! If no, hang in there: you got this! If you are a bit hesitant with working with indexing, the best way to get better is to practice. Feel free to work back through the section above to get better at this basic skill that we will use a LOT in subsequent tutorials.",
    "crumbs": [
      "Working with Networks in R"
    ]
  },
  {
    "objectID": "snaca-r-network-data.html#working-with-matrices",
    "href": "snaca-r-network-data.html#working-with-matrices",
    "title": "Working with Networks in R",
    "section": "",
    "text": "Combine the following numbers\nFrom these combined numbers, create a matrix by reading across the list\nCreate an object called mat. This object will be a matrix with 5 rows.",
    "crumbs": [
      "Working with Networks in R"
    ]
  },
  {
    "objectID": "snaca-r-network-data.html#exploring-the-network-package",
    "href": "snaca-r-network-data.html#exploring-the-network-package",
    "title": "Working with Networks in R",
    "section": "Exploring the network Package",
    "text": "Exploring the network Package\nNow that we have created the mat object, let’s manipulate it into a network and a graph. To do this, we can use the network package. network is a package containing tools to create and modify network objects created by Carter Butts. See the network package page for an overview of its functionality.\nFirst, we need to install the package using: install.packages( \"network\" ). Note: if you have already installed the package, no do not need to reinstall it.\nIf it is already installed, we should check to make sure we have the most recent version: update.packages( \"network\" )\nWhenever we start R, we need to load the package because it is not automatically loaded. To do this, use the library() function. library( \"network\" )\nTo get a list of the contents of the package, as for help with respect to the package itself use the help() function, but tell R we want help on the particular package: help( package = \"network\" ).\n\nWorking with Unidirected, Binary Networks\nNow that the package is loaded, let’s create a new object from our matrix that is a network. In R lingo, we will use the network() function to create an object that is of class network. To use some of the functions, it has to be a specific class.\nJust like you can’t perform calculations on an object that is of class character (e.g. a list of names), the functions in this page are designed to work with a network object.\n\n# look at our object\nmat\n\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n# what class is the object\nclass( mat )\n\n[1] \"matrix\" \"array\" \n\n# now, coerce the object into \n# an object called net.u that\n# is of class network\nnet_u &lt;- as.network( mat )\n\nnet_u\n\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 10 \n    missing edges= 0 \n    non-missing edges= 10 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nWhen we enter the object in the command line, summary info about the object is produced: net_u. This is because the object is of class network. We can use the class function to confirm this: class( net_u ).\nLet’s look at the object again: net_u. What does the summary output of the object tell us?\nNote that the network is treated as directed. By default, the function as.network() sets the argument directed = to TRUE. We can see this by looking at the structure of the function in the help page: ?as.network. What do we need to change in the as.network() function?\nWe need to change the input for the directed= argument because our network is undirected. In other words, directed = FALSE. This tells the function that the matrix we are entering is an undirected network. This is logical: is the object a directed network? False. Therefore, it is an undirected network.\n\n# create a new object called net_u_correct\nnet_u_correct &lt;- as.network( \n  mat, \n  directed = FALSE )\n\n# compare the difference since telling the function that the network is directed\nnet_u\n\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 10 \n    missing edges= 0 \n    non-missing edges= 10 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n# how is this one different?\nnet_u_correct\n\n Network attributes:\n  vertices = 5 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 5 \n    missing edges= 0 \n    non-missing edges= 5 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nThe summary() function is a generic function that summarizes objects. We can use it on an object of class network to provide more information: summary( net_u_correct ). More information about what can be done with the summary() function for an object of class network is shown on the ?as.network page.\nWe could also enter the data as an edgelist using the matrix.type = argument. By default, the function as.network() sets the argument matrix.type = to adjacency. For an edgelist, we would need to change the input for the matrix.type = argument to edgelist.\n\n# for example, let's make an edgelist called edge\n# it will be a matrix of 5 rows and we are reading off by row\nedge &lt;- matrix(\n  c( \"Jen\",\"Tom\",\"Tom\",\"Bob\",\"Bob\",\"Leaf\",\"Bob\",\"Jim\",\"Leaf\",\"Jim\" ),\n  nrow = 5, \n  byrow = TRUE )\n\n# take a look\nedge\n\n     [,1]   [,2]  \n[1,] \"Jen\"  \"Tom\" \n[2,] \"Tom\"  \"Bob\" \n[3,] \"Bob\"  \"Leaf\"\n[4,] \"Bob\"  \"Jim\" \n[5,] \"Leaf\" \"Jim\" \n\n\nWe can see that there are two columns and five rows. Recall that in an edgelist, each row corresponds to an edge in the network. So, the first row of edge, or edge[1,], is the tie between Jen and Tom. From this edgelist, we can build a network:\n\n# create an object called edge_net_u\n# but change the default to edgelist for the matrix.type argument.\n\nedge_net_u &lt;- as.network(\n  edge, \n  directed = FALSE, \n  matrix.type = \"edgelist\" ) \n\n\n# now take a look\n\nsummary( edge_net_u )\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n\n# The as.network() function will often recognize the matrix type being entered\n# create the object again, but do not toggle the matrix.type argument\n\nedge_net_u &lt;- as.network( \n  edge,\n  directed = FALSE )\n\n\n# is it different\n# no, because the function is programmed to \n# read the dimensions of the input object\n\nsummary( edge_net_u )\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n\n\n\n\nWorking with Directed, Binary Networks\nNow, let’s work with the example of a directed, binary network. We will create an object that is the adjacency matrix.\n\n# these were written in by row\n# so we want it to read by row, byrow=TRUE\n\nmat_d &lt;- matrix(\n  c( 0,1,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,1,0 ),\n  nrow = 5,\n  byrow = TRUE )\n\n\n# take a look at the matrix\n\nmat_d \n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    0    0    0\n[2,]    0    0    1    0    0\n[3,]    0    0    0    1    1\n[4,]    0    0    1    0    1\n[5,]    0    0    1    1    0\n\n\nNow, let’s coerce it to be an object of class network.\n\nnet_d &lt;- as.network( \n  mat_d,\n  directed = TRUE )\n\n\n# take a look\n\nsummary( net_d )\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n  1 2 3 4 5\n1 0 1 0 0 0\n2 0 0 1 0 0\n3 0 0 0 1 1\n4 0 0 1 0 1\n5 0 0 1 1 0\n\n\nJust as before, we could also enter the data as an edgelist. Since we have directed relations, we have more edges. This is because reciprocated ties count twice. So, we have to tell the matrix() function that the matrix has 8 rows, instead of 5.\n\n# create the edgelist\n\nedge_d &lt;- matrix(\n  c( \"Jen\",\"Tom\",\"Tom\",\"Bob\",\"Bob\",\"Leaf\",\"Bob\",\"Jim\",\n     \"Leaf\",\"Bob\",\"Leaf\",\"Jim\",\"Jim\",\"Bob\",\"Jim\",\"Leaf\" ),\n  nrow = 8,\n  byrow = TRUE )\n\n\n# create the network object\n\nedge_d_net &lt;- as.network(\n  edge_d,\n  directed = TRUE,\n  matrix.type = \"edgelist\" )\n\n\n# take a look\n\nsummary( edge_d_net )\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   0\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   0   0    0   0\n\n# I have added the argument print.adj=FALSE\n# what is different?\n\nsummary( edge_d_net,\n         print.adj = FALSE )\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\n\n\n\nImporting Network Data\nIf we had a large network, these routines (i.e. using the matrix() function) would be tedious and most likely result in a few errors. Most of the time, we have a file that is an adjacency matrix or an edgelist that we can import. The read.csv() function can be used to read in .csv files that are arranged in this way. Let’s take a look at the help for this function: ?read.csv.\nWe will use a file called data-undirected-example.csv. To access the file, we can place the url in the read.csv() function.\nHere is the url: https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv.\n\n# define the path\n\nurl &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\"\n\n\n# define the data using the url object\n\nmat_u &lt;- read.csv( url )\n\n\n# look at the object\n\nmat_u\n\n\n# note that the read.csv function creates an object of class data.frame.\n\nclass( mat_u )\n\nWe need to adjust the arguments to read in the file how we want it. Specifically, we want to do the following:\n\nSet the as.is = argument equal to TRUE so that it reads the data as it is.\nSet the header = argument to TRUE to indicate that there is a header, or column labels.\nSet the row.names = argument equal to 1 to indicate that the name of the rows are in the first column.\n\n\n# look at the arguments\n\nmat_u2 &lt;- read.csv( \n  url,\n  as.is = TRUE,\n  header = TRUE,\n  row.names = 1 \n  )\n\nmat_u2\n\n\n# compare them\n\nmat_u\n\nmat_u2\n\nNow, make the object into one of class network:\n\n# we have to first coerce the object to a matrix\n\nmat_u2 &lt;- as.matrix( mat_u2 )\n\n\n# recall that since this network is undirected\n# we set the directed= argument to FALSE\n\nnet_u &lt;- as.network( \n  mat_u2,\n  directed = FALSE\n   )\n\nnet_u\n\n\n# we could combine the as.matrix and as.network functions\n\nnet_u &lt;- as.network( \n  as.matrix( \n    mat_u2 ), \n  directed = FALSE \n  )\n\nnet_u\n\nWe could also import the file if it is saved locally (i.e. we are not going to the web to get it). Typically we do not do this because it is a bad practice. That is, creating a version of a file locally. But, sometimes you might be offline or you have files that cannot be put online.\nLet’s do this for the directed network. I have saved the file to my desktop. First, look at what directory we are in using the getwd() function. This function gets the current working directory.\nThen, set the directory where the file is located using the setwd() function. You can get the location of the file by right-clicking and in Windows using Properties or on Mac using Get Info. Note that you have to configure this path to your machine.\nThen, use read.csv as above:\n\nsetwd( \"PUT THE CORRECT PATH HERE\" )\n\nmat_d &lt;- read.csv(\n  \"data-directed-example.csv\",\n  as.is=TRUE,\n  header=TRUE,\n  row.names=1\n  )\n\n\n# Note: we don't need to tell it that \n# the network is directed since \n# this is the default, \n# but a good habit to get into.\n\nnet_d &lt;- as.network(\n  as.matrix( data_d ),\n  directed=TRUE\n  )\n\n\n# now, print the object\n\nnet_d\n\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 8 \n    missing edges= 0 \n    non-missing edges= 8 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\n\n\nCalling Network Data in SNACpack\nWe have seen how you can build a network object manually and how you can import one. As we will see throughout the tutorials, the SNACpack package contains several prebuilt data sets for you to use. To access these, we need to make sure we have the SNACpack package installed. We covered this in the Getting Started with R tutorial, but we will review it here.\nRecall that this package is not on CRAN, rather it is located on Github, which is an online repository for storing code and various projects. To install the SNACpack package, we need to first install a package called devtools because it has a function install_github() that we will use to install the SNACpack package. Remember, if you have already installed devtools and SNACpack you do not need to reinstall them.\nTo install SNACpack, let’s use the following code chunk:\n\n# first install the devtools package\n\ninstall.packages( \"devtools\" )\n\n\n# now, load the devtools package\n\nlibrary( devtools )\n\nOk, no we are ready to use the install_github() function. For this function to work, you need to know the location of the package you want to install. The location of the SNACpack package is: jacobtnyoung/SNACpack. If you want, you can access the repository using this link: https://github.com/jacobtnyoung/SNACpack. Now that we have the location, we can install it:\n\n# install the package\n\ninstall_github( \"jacobtnyoung/SNACpack\" )\n\n\n# now, load the library\n\nlibrary( SNACpack )\n\nDone! Take a look at the package using help( package = \"SNACpack\" ) to get a sense of what it contains (don’t worry, we will be going through this in more detail throughout the tutorials).\nThe networks in SNACpack are stored as objects of class network. R recongizes this, and loads the network package for you. So, to examine the network object, you just have to type it out. Let’s look at a network of cocaine dealers:\n\n# examine the network\n\ncocaine_dealing_net\n\n Network attributes:\n  vertices = 28 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 40 \n    missing edges= 0 \n    non-missing edges= 40 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nWhat do we see? Well, there are 28 vertices (i.e. nodes), and 40 edges (ties). We also see that the network is directed. To learn more about the network, we can call the help file for the object by using ?cocaine_dealing_net.\nAs mentioned, we will use data in SNACpack throughout the book, so you will get more practice working with these objects.",
    "crumbs": [
      "Working with Networks in R"
    ]
  },
  {
    "objectID": "snaca-r-network-data.html#test-your-knowledge-exercises",
    "href": "snaca-r-network-data.html#test-your-knowledge-exercises",
    "title": "Working with Networks in R",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nCreate a 5x5 adjacency matrix using the matrix() function.\n\nWhat happens if the number of elements doesn’t match the dimensions of the matrix?\nAssign meaningful row and column names to the adjacency matrix using the rownames() and colnames() functions.\nHow can you reference a specific row or column by name?\n\nUse the [ and ] symbols to extract specific elements, rows, or columns from a matrix.\n\nCoerce an adjacency matrix into a network object using the as.network() function.\n\nWhat argument must you modify to create an undirected network?\n\n\nCreate an edgelist for a directed network and convert it to a network object. How does this process differ from working with adjacency matrices?\n\nSummarize a network object using the summary() function.\n\nWhat insights can you gain from this output?\n\n\nExplain the difference between directed and undirected networks in the context of the as.network() function.\n\nWhat specific arguments are used to define these properties?",
    "crumbs": [
      "Working with Networks in R"
    ]
  },
  {
    "objectID": "snaca-r-network-data.html#tutorial-summary",
    "href": "snaca-r-network-data.html#tutorial-summary",
    "title": "Working with Networks in R",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced the basics of working with network data in R, focusing on creating, manipulating, and importing network structures. It began with constructing adjacency matrices using the matrix() function, followed by assigning meaningful row and column names for clarity and exploring matrix indexing to extract specific elements, rows, or columns. The tutorial then transitioned to coercing matrices into network objects using the as.network() function from the network package, with special attention to specifying whether a network is directed or undirected. The use of edgelists as an alternative to adjacency matrices was demonstrated, highlighting the importance of specifying the correct matrix type in the as.network() function. The tutorial also covered importing network data from external sources, including CSV files from URLs or local directories, and converting them into network objects. The emphasis was on building a solid foundation for working with network data structures, which are essential for analyzing relationships and interactions in crime analysis.",
    "crumbs": [
      "Working with Networks in R"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html",
    "href": "snaca-r-visualization.html",
    "title": "Basics of Network Visualization",
    "section": "",
    "text": "Network Visualization\nLet’s be honest, network analysis is awesome. Where does that awesomeness come from? One sure reason is visualization! There is nothing like a beautiful network visualization that conveys lots of information and is aesthetically pleasing. Right?\nNot convinced? Examine the plot below. Without me giving you any information about this figure (which is from James Moody and Peter Mucha’s paper, Portrait of Political Party Polarization), what does it tell you?\nWhat about this one showing political blogs? (from David Lazer and colleagues paper Computational Social Science). What does the visualization “say” or “tell you”?\nIn this tutorial, you will be introduced to the basics of visualizing networks using the gplot() function in the sna package. We will also look at some approaches to building plots to help guide you in honing your SNA toolkit.\nOne of the great features of working with network data is the ability to see the data through visualization. Visualizing the structure of a network is helpful for discerning patterns that might be of interest.\nDouglas Luke’s (2015: 47) A User’s Guide to Network Analysis provides several guidelines, or aesthetic principles, for what makes a graphical layout of a network easy to understand and interpret. These are:\nThink about each of these suggestions. Why do they aid in visualizing the network? How do they assist in avoiding conveying information that is not really there? Ponder these questions for a bit…",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html#network-visualization",
    "href": "snaca-r-visualization.html#network-visualization",
    "title": "Basics of Network Visualization",
    "section": "",
    "text": "Minimize edge crossings\nMaximize the symmetry of the layout of nodes\nMinimize the variability of the edge lengths\nMaximize the angle between edges when they cross or join nodes\nMinimize the total space used for the network display",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html#getting-started",
    "href": "snaca-r-visualization.html#getting-started",
    "title": "Basics of Network Visualization",
    "section": "Getting Started",
    "text": "Getting Started\nNow that you have a sense of what a good visualization should try to do, let’s look at an example to help illustrate working with the gplot() function in the sna package.\nFirst, we need to install the sna package using install.packages( \"sna\" ) and load the library using library( sna ).\nRemember, if you have already installed a package then you do not need to use the install.packages() function. But, if you have not installed the package in a while, you should use update.packages() to incorporate any changes that have been made to the page.\nNext, let’s use a network of phone calls among members of the Sicilian Mafia as discussed by Cavallaro et al. (2020). This network is available in the SNACpack package and is called: mafia_calls_net. To learn more about the data, use ?mafia_calls_net to pull up the help page.\nAltogether, that looks something like this:\n\n# install the packages\ninstall.packages( \"sna\" )\n\n# call the sna library\nlibrary( sna )\n\n# call the SNACpack library (NOTE the case sensitivity!)\nlibrary( SNACpack )\n\n# if you need to reinstall SNACpack for whatever reason, remember\n# to use devtools like this:\n# devtools::install_github(\"jacobtnyoung/SNACpack\")\n\nNow that we have sna and SNACpack loaded, we can examine the mafia_calls_net (to learn more about the data, use ?mafia_calls_net to pull up the help page). We can do this just by typing out the name of the network:\n\nmafia_calls_net\n\n Network attributes:\n  vertices = 98 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 123 \n    missing edges= 0 \n    non-missing edges= 123 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nTake a look at what is printed out. We see that there are 98 vertices (i.e., nodes) and 123 edges (i.e. ties). So, the network represents 123 phone calls between 98 individuals. Note that it is undirected.\nLet’s plot it!\n\n# Compare two different plot layouts.\n\n# Here is a circle.\ngplot( mafia_calls_net, gmode = \"graph\", mode = \"circle\" )\n\n\n\n\n\n\n\n# Here is a separate layout.\ngplot( mafia_calls_net, gmode = \"graph\", mode = \"fruchtermanreingold\" )\n\n\n\n\n\n\n\n\nThink back to the aesthetic elements we discussed above. How do these two plots differ in how well they convey the same information? Which one is better? Why is it better?\nTo think about these questions, let’s plot the two layouts together. To do this we will use the par() function. This allows us to partition the plotting region.\n\n# plot the circle layout (add the main() argument for a title)\ngplot( mafia_calls_net, gmode = \"graph\", mode = \"circle\", main = \"Plotted as a circle\" )\n\n\n\n\n\n\n\n# plot the Fruchterman Reingold layout\ngplot( mafia_calls_net, gmode = \"graph\", mode = \"fruchtermanreingold\", main = \"Plotted using a spring algorithm\" )\n\n\n\n\n\n\n\n\nAgain, think about our questions: How do these two plots differ in how well they convey the same information? Which one is better? Why is it better?\nOk, that was a lot. Let’s work our way back through the mechanics of building a plot to better get a sense of what we are doing.",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html#working-with-the-gplot-function",
    "href": "snaca-r-visualization.html#working-with-the-gplot-function",
    "title": "Basics of Network Visualization",
    "section": "Working with the gplot() Function",
    "text": "Working with the gplot() Function\nLet’s take a look at some of the visualization capabilities of gplot(). Let’s start by looking at the function’s help page: ?gplot.\nTo see the various functionality of the function, let’s work with our example of an undirected network. Remember that the network undirected_example_net is available in SNACpack. Let’s plot it.\n\ngplot( undirected_example_net )\n\n\n\n\n\n\n\n\nHold on, this plot shows arrows. But this network is undirected. What gives?\nThat is because gplot() assumes a directed network. We can see this in the help menu, ?gplot, where is shows that for the type of network, the gmode= argument defaults to a directed graph. To fix this we can either:\n\nmanually turn off the display of arrows using the usearrows= argument, gplot( undirected_example_net, usearrows = FALSE )\nor indicate that the object to be plotted is a undirected graph or graph, gplot( undirected_example_net, gmode = \"graph\" )\n\nThe gplot() function has a number of arguments that can be used to better display the information contained in the network.\nFor example, we can add labels to the vertices using the network.vertex.names() function.\n\ngplot(\n  undirected_example_net, \n  gmode = \"graph\", \n  label = network.vertex.names( undirected_example_net )\n  )\n\n\n\n\n\n\n\n\nAlternatively, we could add in a string of names for the label:\n\ngplot( undirected_example_net, gmode = \"graph\",  label = c( \"Jen\", \"Tom\", \"Bob\", \"Leaf\", \"Jim\" ) )\n\nOr we could define them as an object:\n\nnames &lt;- c( \"Jen\", \"Tom\", \"Bob\", \"Leaf\", \"Jim\" )\nadd to the plot using gplot( undirected_example_net, gmode = \"graph\", label = names )\n\nThere is no “right” way to do this, so figure out what works best for you!\nA great feature of R is that we can tune the graphing parameters. Here are several examples:\n\nLabels:\n\nAdd boxes around the labels, boxed.labels = TRUE\nChange label size using label.cex, such as label.cex = 1.5\nColor the labels using label.col=, such as: label.col = \"blue\"\n\nColors:\n\ndifferent colored names, combine label.col= with the c() function. Such as: label.col = c( \"red\", \"blue\", \"green\", \"orange\", \"grey\" )\ndifferent colored nodes, vertex.col= argument. Such as: vertex.col=c(\"red\",\"blue\",\"green\",\"orange\",\"grey\")\ndifferent colored edges, using edge.col=, such as: edge.col=c(\"red\",\"blue\",\"green\",\"orange\",\"grey\")\n\n\nThere is a LOT of functionality to the gplot() function. See the arguments in the help file: ?gplot. I would encourage you to take some time to look through it and play around with the various features.\n\nAdjusting Plot Layout\nWhen a layout is generated, the results can be saved for later reuse using the coord= argument.\n\n# Set the seed for the random number generator \n# so we can always get the same plot layout\nset.seed( 507 ) \n\n# Define an object that will be the coordinates we want to use\ncoords &lt;- gplot( \n  undirected_example_net, \n  gmode = \"graph\",\n  label = network.vertex.names( undirected_example_net )\n  )\n\n\n\n\n\n\n\n# Show the vertex coordinates\ncoords\n\n            x        y\n[1,] 3.240723 6.485256\n[2,] 4.008480 5.193206\n[3,] 3.087186 3.921695\n[4,] 1.572750 3.503118\n[5,] 2.600828 2.449065\n\n\nTake a close look at the coords object. What do the values represent? Think about how this information is used in the plot.\nNow, we can pass the coordinates into a plot.\n\n# Saved layouts can be used via the coord= argument:\ngplot(\n  undirected_example_net, \n  gmode = \"graph\",\n  label = network.vertex.names( undirected_example_net ),\n  coord = coords \n  )\n\n\n\n\n\n\n\n\nCool but, why do this? The placement of the nodes shift when we call the gplot() function just due to the operation of the algorithm. Controlling where nodes are plotted in the 2-dimensional space is useful if we want to show different aspects of the plot. Note that we can have different layouts of the nodes. If we like a particular one, we can save the coordinates.\nBut, suppose the default settings are insufficient and we want to make a few small changes. The interactive= argument allows for tweaking.\n\n# First, set up the coordinates you want\ncoords &lt;- gplot(\n  undirected_example_net, \n  gmode = \"graph\",\n  label = network.vertex.names( undirected_example_net ),\n  coord = coords, \n  interactive=TRUE \n  )\n\nWhen this renders on your system, move a few of the nodes around. Then, after you close the window it will save the coordinates.\n\n# Then, use these in the plot\ngplot( \n  undirected_example_net, \n  coord = coords, # use the coords object in the \"coord=\" argument\n  gmode = \"graph\",\n  label=network.vertex.names( undirected_example_net )\n  )",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html#a-layering-approach",
    "href": "snaca-r-visualization.html#a-layering-approach",
    "title": "Basics of Network Visualization",
    "section": "A Layering Approach",
    "text": "A Layering Approach\nAs we have seen, we can start with a basic plot and add information. Creating graphics in this way is referred to as layering because we are stacking additional layers of elements on top of each other.\nTake a look at this series of plots:\n\n\n\n\n\n\n\n\n\nThe plot uses several layers of information:\n\nthe size of the nodes (vertex.cex)\nthe color of the nodes (vertex.col)\nthe color of the edges (edge.col)\n\nAs we create a plot, we want to think about what information we should convey and how best to convey that information (i.e. colors?, shapes?, size?, all of the above?)",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html#plotting-the-powerinfluence-network-from-the-prison-inmate-networks-study-pins",
    "href": "snaca-r-visualization.html#plotting-the-powerinfluence-network-from-the-prison-inmate-networks-study-pins",
    "title": "Basics of Network Visualization",
    "section": "Plotting the Power/Influence Network from the Prison Inmate Networks Study (PINS)",
    "text": "Plotting the Power/Influence Network from the Prison Inmate Networks Study (PINS)\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collect sociometric data in a prison. The researchers collected data on several types of networks.\nLet’s plot the power and influence network, which was created by asking individuals whom they believed was “powerful and influential” on the unit. This network is available in SNACpack and is called: pins_pi_net.\nFirst, take a look at the network:\n\npins_pi_net\n\n Network attributes:\n  vertices = 205 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 161 \n    missing edges= 0 \n    non-missing edges= 161 \n\n Vertex attribute names: \n    age race time_in_prison vertex.names \n\nNo edge attributes\n\n\nWe see that it has 205 vertices (nodes), 161 edges (trust nominations), and is directed.\nWe also see that there are several attributes. To learn more about the attributes, review the help documentation for the network by using ?pins_pi_net.\nWe can access network attributes using a shorthand notation: %v%. The operate let’s us pull a specific attribute. We can look at the various vertex data by using the shorthand network %v% \"attribute\". For example:\n\npins_pi_net %v% \"age\" shows the age variable.\npins_pi_net %v% \"race\" shows the race variable.\n\n\n# look at the values for age\npins_pi_net %v% \"age\"\n\n  [1] 30 60 43 33 54 40 52 54 42 49 24 30 49 43 45 25 43 61 44 29 48 49 41 36 33\n [26] 22 32 35 33 32 30 28 22 37 35 47 62 40 44 50 29 51 50 33 34 44 53 24 34 65\n [51] 27 49 25 29 48 39 53 23 37 56 50 27 45 47 37 27 37 43 40 68 46 41 24 53 50\n [76] 26 40 45 43 37 38 59 32 35 28 37 33 30 47 30 37 48 42 37 30 55 36 31 31 29\n[101] 26 55 39 30 52 29 50 69 37 39 39 42 47 38 54 41 28 21 33 47 51 44 51 35 28\n[126] 30 54 26 60 58 31 32 46 37 45 23 39 35 40 39 52 32 57 24 24 52 61 33 51 47\n[151] 39 29 30 51 52 47 28 69 51 21 49 55 72 23 25 44 45 36 40 24 23 50 53 32 28\n[176] 29 46 40 32 39 30 30 26 25 44 57 42 30 43 42 33 36 26 24 26 33 37 34 33 24\n[201] 24 37 42 47 32\n\n# look at the values for race\npins_pi_net %v% \"race\"\n\n  [1] 1 2 1 2 2 2 1 2 2 3 2 1 1 1 1 2 1 2 1 2 3 1 1 3 4 2 1 1 3 2 2 2 2 1 2 2 2\n [38] 3 1 2 2 1 1 3 1 2 2 3 2 1 1 1 2 3 1 1 1 1 3 1 2 1 1 2 2 3 2 1 2 1 1 1 2 2\n [75] 1 1 2 2 3 2 2 1 3 1 1 1 2 2 2 1 2 2 2 3 1 1 1 2 2 2 2 1 3 2 2 2 1 1 3 2 1\n[112] 1 1 2 2 1 3 2 2 1 2 1 2 1 1 2 1 2 1 2 1 2 3 3 2 2 3 3 3 3 2 2 2 3 2 1 1 2\n[149] 2 3 2 1 2 1 1 1 2 2 2 3 2 2 1 1 1 2 2 2 1 2 1 1 1 2 2 1 1 1 1 2 2 2 1 2 2\n[186] 2 1 2 1 1 1 3 2 2 2 1 2 2 2 3 2 3 3 2 2\n\n\nNow, we can use that information in our plot. For example:\n\ngplot( pins_pi_net,\n       arrowhead.cex=0.5,\n       vertex.cex = pins_pi_net %v% \"age\" )\n\n\n\n\n\n\n\n\nYIKES!!! What is wrong?\nThe problem is that we need to rescale the vertex attribute so that the nodes are not too big. Essentially, we want to be able to rework the values of the attribute so the plot sizes make sense. In SNACpack there is a function called vertex_rescale that does just that! I take a vector for plotting, and it allows you to specify the minimum and maximum values. Use ?vertex_rescale for more information.\nWe can use the vertex_rescale function to rescale the vertex attribute so it looks better:\n\n# now execute the plot\ngplot( pins_pi_net, \n       arrowhead.cex=0.5,\n       vertex.cex = vertex_rescale( \n         pins_pi_net %v% \"age\", # the attribute we want to plot\n         0.5,  # the minimum size of a node\n         1.5   # the maximum size of a node\n         ) \n       )\n\n\n\n\n\n\n\n\nNote that the plot above has a lot of “whitespace” due to the margins. We can adjust this using the par() function.\n\n# tweak the margins to cut some whitespace\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\n# now execute the plot\ngplot( pins_pi_net, \n       arrowhead.cex=0.5,\n       vertex.cex = vertex_rescale( pins_pi_net %v% \"age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nTry adjusting the minimum and maximum values in the vertex_rescale function and see how it changes the plot.\nOur plot is looking better, but there is still room for improvement. Let’s drop the isolates (using the displayisolates = FALSE argument) to help with the visualization.\n\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\ngplot( pins_pi_net,\n       displayisolates = FALSE,\n       arrowhead.cex=0.5,\n       vertex.cex = vertex_rescale( pins_pi_net %v% \"age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nAs we build layers, we can get a fairly useful graphic that tells us a lot of information:\n\npar( mar = c( 5,0.1,3,0.1 ) )\n\ngplot( pins_pi_net,\n       main=\"PINS Power & Influence Network\", # add a title\n       vertex.col = pins_pi_net %v% \"race\",      # color the nodes by the race variable\n       displayisolates = FALSE,             # don't display the isolated cases\n       arrowhead.cex = 0.5,                 # augment the size of the arrowheads\n       vertex.cex = vertex_rescale( pins_pi_net %v% \"age\", 0.5, 1.5 ), # size the nodes by the Age variable\n       sub = \"Nodes colored by Race, \\n edges colored by Info net \\n nodes sized by Age\" # add a subtitle\n       )",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html#test-your-knowledge-exercises",
    "href": "snaca-r-visualization.html#test-your-knowledge-exercises",
    "title": "Basics of Network Visualization",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nUsing the Moreno dataset, compare the circle layout and the Fruchterman-Reingold layout. Which layout better adheres to the aesthetic principles discussed above? Why?\nModify the Moreno visualization to color nodes by gender. How does this addition change your interpretation of the network structure?\nWhen plotting an undirected network, why might gplot() still display arrows? How can this be resolved?\nExperiment with adding labels to a network plot. What are some ways to customize label appearance? Why might label size or color be important?\nUse the vertex_rescale() function to adjust node sizes based on a vertex attribute. Try some different values. How do the different values influence your understanding of the network?\nExplain why saving node coordinates using the coord= argument can be useful. Demonstrate how to save and reuse coordinates in a network plot.\nDescribe the concept of layering in network visualization. Create a plot that layers at least three attributes (e.g., node size, color, edge attributes).\nCompare a basic network plot of the PINS dataset with one that incorporates multiple attributes. What additional insights does the more detailed visualization provide?",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-visualization.html#tutorial-summary",
    "href": "snaca-r-visualization.html#tutorial-summary",
    "title": "Basics of Network Visualization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThere is nothing like a beautiful network visualization that conveys lots of information and is aesthetically pleasing. Now you know how to get there! As you have seen, there is a ton of flexibility. I would encourage you to spend some time tinkering with the various arguments for the gplot() function to get a feel for what it can do.\n\n\n\n\nCavallaro, L., A. Ficara, P. De Meo, G. Fiumara, S. Catanese, and O. Bagdasar. 2020. “Disrupting Resilient Criminal Networks Through Data Analysis: The Case of Sicilian Mafia.” PLOS ONE 15 (8): e0236476. https://doi.org/10.1371/journal.pone.0236476.",
    "crumbs": [
      "Basics of Network Visualization"
    ]
  },
  {
    "objectID": "snaca-r-degree-centrality.html",
    "href": "snaca-r-degree-centrality.html",
    "title": "Degree Centrality and Centralization",
    "section": "",
    "text": "Degree Centrality (Undirected Binary Graphs)\nHow do we know whether a node is important in a network? As was discussed in the textbook chapter on Degree Centrality, one of the most popular concepts in network analysis is centrality. That is, important nodes are those who are central. Also, we can compare networks by examining how they differ (or are similar) based on the distribution of centrality scores. In this lab, we will examine how to calculate degree centrality and centralization scores in R using the degree() and centralization() functions in the sna package.\nIn an undirected binary graph, actor degree centrality measures the extent to which a node connects to all other nodes in a network. In other words, the number of edges incident with a node. This is symbolized as: \\(d(n_i)\\). For an undirected binary graph, the degree \\(d(n_i)\\) is the row or column sum. If we have an object of class(matrix) in the workspace, we can use the colSums() and/or rowSums() functions to return this information.\nFirst, let’s set up our graph from the degree centrality chapter:\n# First, clear the workspace\nrm( list = ls() )\n\n# Then, build an object\nu_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ),\n  c( 0,1,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ) )\n\n# Assign the names to the object\nrownames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# Now, plot the graph (remember to load the sna package)\n# The quitely= argument tells R not to print out the info on the package\nlibrary( sna, quietly=TRUE ) \n\n# Let's set up the coordinates to force the nodes\n# to be in the same position throughout the lab\nset.seed( 507 )\ncoords &lt;- gplot( u_mat )\n\n\n\n\n\n\n\n# Plot the network\ngplot( \n  u_mat, \n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  coord = coords\n  )\nSince the graph is undirected, we can print the degree centrality for each node as a vector using the colSums() or rowSums() functions:\ncolSums( u_mat )\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\nrowSums( u_mat )\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\n# We could also assign these to an object\ndeg_u_mat &lt;- colSums( u_mat )\nThen, we can use that information in the plot by passing the degree object to the vertex.cex= argument. This will make nodes with higher degree larger.\ngplot(\n  u_mat,\n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  vertex.cex = deg_u_mat, #HERE: we added the object to size the plot\n  coord = coords\n  )\nAnother approach is to shade the nodes. Rather than just the size, we might want to have nodes with larger degree to be darker (or lighter) to better visualize differences in degree. To do this, we could use the RColorBrewer package to shade the nodes.\n# install.packages( \"RColorBrewer\" )\nlibrary( RColorBrewer, quietly=TRUE )\n\n# use display.brewer.all() to see the pallettes.\n\n# Let's use the Blues pallette.\ncol_deg  &lt;- brewer.pal( length( unique( deg_u_mat ) ), \"Blues\")[deg_u_mat]\n\n# In this plot, what do darker shades mean?\ngplot(\n  u_mat, \n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  vertex.cex = deg_u_mat,\n  vertex.col = col_deg,\n  coord = coords\n  )",
    "crumbs": [
      "Degree Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-undirected-binary-graphs",
    "href": "snaca-r-degree-centrality.html#degree-centrality-undirected-binary-graphs",
    "title": "Degree Centrality and Centralization",
    "section": "",
    "text": "Standardized degree centrality, mean degree, and centralization\nActor degree centrality not only reflects each node’s connectivity to other nodes but also depends on the size of the network, g. As a result, larger networks will have a higher maximum possible degree centrality values. This makes comparison across networks problematic. The solution is to take into account the number of nodes and the maximum possible nodes to which i could be connected, g-1.\nLet’s calculate the standardized centrality scores for our undirected graph:\n\n# unstandardized or raw centrality\ndeg_u_mat &lt;- colSums( u_mat )\n\n# to calculate g-1, we need to know the number of nodes in the graph \n# this is the first dimension of the matrix\ng &lt;- dim( u_mat )[1]\n\n# now, divide by g-1\ns_deg_u_mat &lt;- deg_u_mat / ( g-1 )\n\ndeg_u_mat\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\ns_deg_u_mat\n\n Jen  Tom  Bob Leaf  Jim \n0.25 0.50 0.75 0.50 0.50 \n\n\nWe can also examine the average degree of the graph using\n\\[\\frac{\\sum_{i=1}^g d(n_i)}{g}\\] or\n\\[\\frac{2L}{g}\\]\nwhere L is the number of edges in the graph:\n\nmean_deg &lt;- sum( deg_u_mat ) / dim( u_mat )[1] \n\nmean_deg\n\n[1] 2\n\n# Note that we can also use the mean() function to return this information:\nmean( deg_u_mat )\n\n[1] 2\n\n\nIn the code above, we used the sum() function. This function sums over the entire matrix. In this case, that sum represents \\(2L\\), not \\(L\\). Why? Because \\(L\\) is the number of edges in the graph. When we create the adjacency matrix, we duplicate each edge. So, when we sum this matrix, we are count each edge twice. This is why the sum represents \\(2L\\).\n\nWe can also calculate how centralized the graph itself is. Group degree centralization measures the extent to which the actors in a social network differ from one another in their individual degree centralities. Following Wasserman and Faust (1994), an index of group degree centralization can be calculated as:\n\\[C_D = \\frac{\\sum\\limits_{i=1}^g [C_D(n^*) - C_D(n_i)]}{[(g-1)(g-2)]}\\]\nfor undirected graphs where \\(C_D(n^*)\\) is the maximum degree in the graph. We can write out the components of the equation using the max() function:\n\n# In separate pieces\ndeviations &lt;- max( deg_u_mat ) - deg_u_mat\nsum_deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-2 )\ngroup_deg_cent &lt;- numerator/denominator\n\ngroup_deg_cent\n\n[1] 0.4166667\n\n# Or, as a single equation.\ngroup_deg_cent &lt;-( sum( ( ( max( deg_u_mat ) - deg_u_mat ) ) ) ) / ( ( g -1 )*( g - 2 ) )\n\ngroup_deg_cent\n\n[1] 0.4166667",
    "crumbs": [
      "Degree Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-directed-binary-graphs",
    "href": "snaca-r-degree-centrality.html#degree-centrality-directed-binary-graphs",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality (Directed Binary Graphs)",
    "text": "Degree Centrality (Directed Binary Graphs)\nIn a directed binary graph, actor degree centrality can be broken down into indegree and outdegree centrality. Indegree, \\(C_I(n_i)\\), measures the number of ties that i receives. For the sociomatrix \\(Xij\\), the indegree for i is the column sum. Outdegree, \\(C_O(n_i)\\), measures the number of ties that i sends. For the sociomatrix \\(Xij\\), the outdegree for i is the row sum.\nAs before, if we have an object of class(matrix) in the workspace, we can use the rowSums() and colSums() functions. However, the colSums() function will return the indegree centrality for i and the rowSums() function will return the outdegree centrality for i.\nFirst, let’s set up our directed graph from the degree centrality lecture:\n\n# First, clear the workspace\nrm( list = ls() )\n\n# Then, build the object\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ),\n  c( 0,0,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ) )\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# Let's set up the coordinates to force the nodes\n# to be in the same position throughout the lab\nset.seed( 507 )\n\n# remove the old object named coords\nrm( coords )\n\n# set the new coordinates\ncoords &lt;- gplot( d_mat )\n\n\n\n\n\n\n\n# Now, plot the graph (remember to load the sna package)\ngplot(\n  d_mat, \n  gmode=\"digraph\",\n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=1.2,\n  coord = coords\n  )\n\n\n\n\n\n\n\n\n\n# Let's look at the different centrality scores \n# by assigning them to different objects\nideg_d_mat &lt;- colSums( d_mat )\nodeg_d_mat &lt;- rowSums( d_mat )\n\n# print them out to examine them\nideg_d_mat\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    3    2    2 \n\nodeg_d_mat\n\n Jen  Tom  Bob Leaf  Jim \n   1    1    2    2    2 \n\n\nNow, let’s work this information in the plot. We will want to partition the plotting window using the par() function to show two plots and we want to change the margins using the mar= argument. Use ?par and/or ?mar to view the help on how these work.\n\npar( \n  mfrow=c( 1, 2 ), \n  mar=c( 0.1, 0.5, 4, 0.1) \n  )\n\ngplot(\n  d_mat, \n  gmode=\"digraph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=0.8,\n  label.pos=1,\n  vertex.cex = ideg_d_mat+0.2,\n  main=\"Nodes sized by Indegree\",\n  coord = coords\n  )\n\ngplot(\n  d_mat, \n  gmode=\"digraph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=0.8,\n  label.pos=1,\n  vertex.cex = odeg_d_mat,\n  main=\"Nodes sized by Outdegree\",\n  coord = coords\n  )\n\n\n\n\n\n\n\n\nNote the difference. Which nodes are more central in terms of indegree? What about outdegree?\nAgain, let’s use the RColorBrewer package to help with shading.\n\n# create the objects\ncol_ideg  &lt;- brewer.pal( length( unique( ideg_d_mat ) ), \"Greens\")[ideg_d_mat]\ncol_odeg  &lt;- brewer.pal( length( unique( odeg_d_mat ) ), \"Oranges\")[odeg_d_mat]\n\npar( \n  mfrow=c( 1, 2 ), \n  mar=c( 0.1, 0.5, 4, 0.1) \n  )\n\ngplot(\n  d_mat, \n  gmode = \"digraph\", \n  arrowhead.cex = 0.5, \n  edge.col = \"grey40\", \n  label = rownames( d_mat ),\n  label.col = \"red\",\n  label.cex = 0.8,\n  label.pos = 1,\n  vertex.cex = ideg_d_mat+0.2,\n  vertex.col = col_ideg,\n  main = \"Nodes sized &\\n shaded by Indegree\",\n  coord = coords\n  )\n\ngplot(\n  d_mat, \n  gmode = \"digraph\", \n  arrowhead.cex = 0.5, \n  edge.col = \"grey40\", \n  label = rownames( d_mat ),\n  label.col = \"red\",\n  label.cex = 0.8,\n  label.pos = 1,\n  vertex.cex = odeg_d_mat,\n  vertex.col = col_odeg,\n  main = \"Nodes sized &\\n shaded by Outdegree\",\n  coord = coords\n  )\n\n\n\n\n\n\n\n\n\nStandardized degree centrality, mean degree, and centralization\nLet’s calculate the standardized centrality scores for our directed graph:\n\n# unstandardized or raw centrality\nideg_d_mat &lt;- colSums( d_mat )\nodeg_d_mat &lt;- rowSums( d_mat )\n\n# to calculate g-1, we need to know the number of nodes in the graph\n# this is the first dimension of the matrix\ng &lt;- dim( d_mat )[1]\n\n# now, divide by g-1\ns_i_deg_u_mat &lt;- ideg_d_mat / ( g-1 )\ns_o_deg_u_mat &lt;- odeg_d_mat / ( g-1 )\n\nWe can also examine the average degree of the graph using \\(\\frac{\\sum_{i=1}^g C_I(n_i)}{g} = \\frac{\\sum_{i=1}^g C_O(n_i)}{g}\\) or \\(\\frac{L}{g}\\), where L is the number of edges in the graph:\n\nmean_i_deg &lt;- sum( ideg_d_mat ) / dim( d_mat )[1] \nmean_o_deg &lt;- sum( odeg_d_mat ) / dim( d_mat )[1] \nmean_i_deg\n\n[1] 1.6\n\nmean_o_deg\n\n[1] 1.6\n\n# we could also use the mean() function\nmean( ideg_d_mat )\n\n[1] 1.6\n\nmean( odeg_d_mat )\n\n[1] 1.6\n\n\nAgain, following Wasserman and Faust (1994), an index of group indegree/outdegree centralization can be calculated as:\n\\[ C_D = \\frac{\\sum\\limits_{i=1}^g [C_D(n^*) - C_D(n_i)]}{[(g-1)^2]} \\]\nfor undirected graphs where \\(C_D(n^*)\\) is the maximum indegree/outdegree in the graph. We can write out the components of the equation using the max() function:\n\n# In separate pieces\ndeviations &lt;- max( ideg_d_mat ) - ideg_d_mat\nsum_deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-1 )\ngroup_i_deg_cent &lt;- numerator/denominator\ngroup_i_deg_cent\n\n[1] 0.4375\n\ndeviations &lt;- max( odeg_d_mat ) - odeg_d_mat\nsum.deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-1 )\ngroup_o_deg_cent &lt;- numerator/denominator\ngroup_o_deg_cent\n\n[1] 0.4375\n\n# Or, as a single equation\ngroup_i_deg_cent &lt;-( sum( ( ( max( ideg_d_mat ) - ideg_d_mat ) ) ) ) / ( ( g -1 )*( g - 1) )\ngroup_o_deg_cent &lt;-( sum( ( ( max( odeg_d_mat ) - odeg_d_mat ) ) ) ) / ( ( g -1 )*( g - 1 ) )\ngroup_i_deg_cent\n\n[1] 0.4375\n\ngroup_o_deg_cent\n\n[1] 0.125\n\n\nWhat do the centralization scores tell us, conceptually?",
    "crumbs": [
      "Degree Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-using-the-sna-package",
    "href": "snaca-r-degree-centrality.html#degree-centrality-using-the-sna-package",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality using the sna Package",
    "text": "Degree Centrality using the sna Package\nDid that feel tedious? If no, go back and do it again :)\nAs you probably have guessed, there are functions in the sna package that calculate degree centrality and graph centralization! In the sna package, these are the degree() and centralization() functions, respectively. Let’s take a look at how these work.\n\n# load the library\nlibrary( sna )\n\n# Build the objects to work with\nrm( list = ls() )\n\nu_mat &lt;- rbind( \n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ), \n  c( 0,1,0,1,1 ), \n  c( 0,0,1,0,1 ), \n  c( 0,0,1,1,0 )\n  )\n\nrownames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\ncolnames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ), \n  c( 0,0,0,1,1 ), \n  c( 0,0,1,0,1 ), \n  c( 0,0,1,1,0 )\n  )\n\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n\n# First, let's look at degree\n?degree\n\n# degree for undirected graph\ndeg &lt;- degree( u_mat, gmode=\"graph\" )\n\n# indegree for directed graph\nideg &lt;- degree( d_mat, gmode=\"digraph\", cmode=\"indegree\" )\n\n# outdegree for directed graph\nodeg &lt;- degree( d_mat, gmode=\"digraph\", cmode=\"outdegree\" )\n\n# returns the combined centrality for each node\ndeg_d &lt;- degree( d_mat, gmode=\"digraph\" )\n\n\n# Now, let's look at centralization\n?centralization\n\n# degree centralization for undirected graph\ncent_u &lt;- centralization( u_mat, degree, mode=\"graph\" )\n\n# indegree centralization for directed graph.\ni_cent_d &lt;- centralization( d_mat, degree, mode=\"digraph\", cmode=\"indegree\" ) \n\n# outdegree centralization for directed graph.\no_cent_d &lt;- centralization( d_mat, degree, mode=\"digraph\", cmode=\"outdegree\" )\n\nNow, wasn’t that easier?",
    "crumbs": [
      "Degree Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-in-pins-get-along-with-and-powerinfluence-networks",
    "href": "snaca-r-degree-centrality.html#degree-centrality-in-pins-get-along-with-and-powerinfluence-networks",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality in PINS Get Along With and Power/Influence Networks",
    "text": "Degree Centrality in PINS Get Along With and Power/Influence Networks\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collect sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:\n\nThe get along with network was created by asking individuals whom they “get along with” on the unit. We can think of this as “friends” in a prison setting. (People don’t really have “friends” in prison, but there are people they “get along with”)\nThe power and influence network was created by asking individuals whom they believed was “powerful and influential” on the unit\n\nBoth of these networks are available in SNACpack. The get along with network is called: pins_ga_net, and the power and influence network is called: pins_pi_net. Let’s examine the degree centrality scores for both of these networks.\n\nGet Along With Network (Undirected Network)\nFor the get along with network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. But, we are going to symmetrize the network by only taking ties for which both i and j indicated that the get along with the other person. This will give us an undirected network.\n\n# load the SNACpack package\n\nlibrary( SNACpack )\n\n\n# use the symmetrize() function to create an undirected matrix\n# you will notice that this creates an object of class \"matrix\"\n\nga_mat_u &lt;- symmetrize( pins_ga_net, rule = \"strong\" )\n\n\n# create the network object\n\nga_net_u &lt;- as.network( ga_mat_u, directed = FALSE )\n\nNow we have created an undirected network where ties represent “get along with” nominations from both individuals. Let’s calculate the degree centrality scores, the centralization score, and then use the degree centrality scores to size our nodes in a plot using the vertex.cex() argument in the gplot() function.\n\n\n# Set the coordinates\nset.seed( 507 )\ncoords &lt;- gplot( ga_net_u )\n\nNow lets build the objects and the plot:\n\n# get the degrees.\nga_net_deg &lt;- degree( ga_net_u, gmode=\"graph\" )\n\n# now the centralization score.\nga_net_deg_cent &lt;- centralization( ga_net_u, degree, mode=\"graph\" )\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = ga_net_deg,\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\n\n\n\n\nWhoops! Let’s try that again AFTER rescaling the degree. We can use the vertex_rescale() function to do this. Now we can plot it after adding in the vertex_rescale() function to gplot():\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = vertex_rescale( ga_net_deg, 0.2, 4 ),\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\n\n\n\n\nAlmost there! Let’s drop the isolates to help with the size:\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = vertex_rescale( ga_net_deg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the degree centralization score of 0.04 indicate?\n\n\n\nPower and Influence Network (Directed Network)\nFor the power and influence network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. We will keep this asymmetry so that we can treat the network as directed. As mentioned above, the power and influence exists in SNACpack as pins_pi_net:\n\npins_pi_net\n\n Network attributes:\n  vertices = 205 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 161 \n    missing edges= 0 \n    non-missing edges= 161 \n\n Vertex attribute names: \n    age race time_in_prison vertex.names \n\nNo edge attributes\n\n\n\n# Set the coordinates\nset.seed( 507 )\ncoords2 &lt;- gplot( pins_pi_net )\n\n\n# get the degrees.\npi_net_ideg &lt;- degree( pins_pi_net, gmode=\"digraph\", cmode = \"indegree\" )\npi_net_odeg &lt;- degree( pins_pi_net, gmode=\"digraph\", cmode = \"outdegree\" )\n\n# now the centralization scores.\npi_net_ideg_cent &lt;- centralization( pins_pi_net, degree, mode=\"digraph\", cmode = \"indegree\" )\npi_net_odeg_cent &lt;- centralization( pins_pi_net, degree, mode=\"digraph\", cmode = \"outdegree\" )\n\n\npar( mfrow=c( 1, 2 ) )\n\ngplot( \n  pins_pi_net, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#693859\",\n  vertex.cex = vertex_rescale( pi_net_ideg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords2,\n  main = \"PINS Power/Influnece\\n Network (Directed)\",\n  sub = \"node sized by indegree centrality\"\n  )\n\ngplot( \n  pins_pi_net, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#2b868c\",\n  vertex.cex = vertex_rescale( pi_net_odeg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords2,\n  main = \"PINS Power/Influnece\\n Network (Directed)\",\n  sub = \"node sized by outdegree centrality\"\n  )\n\n\n\n\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the indegree centralization score of 0.07 indicate?\nWhat does the outdegree centralization score of 0.04 indicate?",
    "crumbs": [
      "Degree Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-degree-centrality.html#test-your-knowledge-excercises",
    "href": "snaca-r-degree-centrality.html#test-your-knowledge-excercises",
    "title": "Degree Centrality and Centralization",
    "section": "Test Your Knowledge Excercises",
    "text": "Test Your Knowledge Excercises\n\nFor the undirected binary graph u_mat, calculate the degree centrality for each node manually. Verify your results using the colSums() function. What does the degree centrality of each node represent in this network? Which node has the highest degree centrality? Why do you think this is the case?\nIn the example above, nodes were plotted with sizes proportional to their degree centrality. Using the shaded plot, describe the relationship between node size and shade intensity. Which node has the darkest shade? Explain what this represents in terms of degree centrality.\nCalculate the standardized degree centrality for u_mat. How does standardizing degree centrality help in comparing nodes across networks of different sizes?\nCompute the degree centralization for u_mat manually and verify it using the centralization() function. What does the result tell you about the network’s structure?\nFor the directed graph d_mat, compute both indegree and outdegree centrality for each node using colSums() and rowSums(). Plot the graph with nodes sized by indegree and outdegree separately. Which nodes are most central in terms of indegree? What does this imply about their role in the network? Which nodes are most central in terms of outdegree? What does this imply?\nFor the Get Along With network, describe the significance of symmetrizing the network. Interpret the degree centrality scores and the centralization score. What does the structure of this network suggest about relationships in the unit?\nFor the Power/Influence network, compare and contrast the plots sized by indegree and outdegree centrality. What do the indegree and outdegree centralization scores suggest about the distribution of power and influence in the network?\nCompare the degree centralization scores for the undirected Get Along With network and the directed Power/Influence network. Which network is more centralized? How does the type of network (undirected vs. directed) influence the interpretation of centralization?",
    "crumbs": [
      "Degree Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-degree-centrality.html#tutorial-summary",
    "href": "snaca-r-degree-centrality.html#tutorial-summary",
    "title": "Degree Centrality and Centralization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced the concept of degree centrality, a measure of node importance based on connectivity within a network, and explores its calculation and visualization for both undirected and directed graphs in R. For undirected graphs, degree centrality is computed using row or column sums, and standardized to account for network size. Directed graphs distinguish between indegree and outdegree centrality, reflecting incoming and outgoing connections, respectively. The tutorial demonstrated graph centralization, highlighting the variability in node centrality within a network. Visualization techniques, including node sizing and shading based on centrality scores, were covered, alongside practical applications using real-world data from the Prison Inmate Networks Study (PINS), where networks like “Get Along With” and “Power/Influence” are analyzed. The use of R’s sna package simplifies centrality calculations and graph plotting, enabling users to gain insights into the structure and dynamics of social networks.\n\n\n\n\nWasserman, Stanley, and Katherine Faust. 1994. Social Network Analysis: Methods and Applications. Vol. 8. Structural Analysis in the Social Sciences. Cambridge, UK: Cambridge University Press.",
    "crumbs": [
      "Degree Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-closeness-centrality.html",
    "href": "snaca-r-closeness-centrality.html",
    "title": "Closeness Centrality and Centralization",
    "section": "",
    "text": "Closeness Centrality (Undirected Binary Graphs)\nHow do we know whether a node is important in a network? As was discussed at the beginning of the chapter on Degree Centrality, one of the most popular concepts in network analysis is centrality. In that chapter, we covered how centrality can be measured by the number of edges incident on a node. But, that is not the only way that a node can be central. The chapter on Closeness Centrality discussed an alternative conceptualization, closeness, where important nodes are those who are “close” to other nodes in the network.\nIn this tutorial, we will examine how to calculate closeness centrality and centralization scores in R using the closeness() and centralization() functions in the sna package.\nHow close is a node to other nodes?\nIn an undirected binary graph, closeness centrality measures how near a node is to the other nodes in the network. This is based on the inverse of the distance of each actor to every other actor.\nTerminology:\nCloseness centrality is calculated as:\n\\[C_C(n_i) = [\\sum\\limits_{j=1}^g d(n_i,n_j)]^{-1}\\]\nor\n\\[\\frac{1}{[\\sum\\limits_{j=1}^g d(n_i,n_j)]}\\] Here is what the equation is doing:",
    "crumbs": [
      "Closeness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#closeness-centrality-undirected-binary-graphs",
    "href": "snaca-r-closeness-centrality.html#closeness-centrality-undirected-binary-graphs",
    "title": "Closeness Centrality and Centralization",
    "section": "",
    "text": "The distance, \\(d(n_i,n_j)\\), is the length of the path between i and j. For example, suppose Sally is friends with Tom, Ulrica, and Violet; Violet is friends with Tom and Walter. What are the paths from Violet to Ulrica? Walter from Ulrica?\nA geodesic is the shortest path between two nodes. What is the shortest path (i.e. geodesic) from Violet to Ulrica?\n\n\n\n\n\n\nfirst identify the distances between i and j (i.e. \\(d(n_i,n_j)\\)) and sum them.\nNote that \\(\\sum\\limits_{j=1}^g\\) is indicating that for i, we want to sum over all the js in the graph, g.\nthen take the inverse of this quantity.\n\n\nManually Calculating Closeness Centrality\nWe can manually calculate the distance matrix using the geodist() function in the sna package. Be sure to load the sna library using library( sna ) Let’s take a look:\n\n# now, take a look at the geodist() function\n?geodist\n\nLet’s go ahead and set up a simple matrix and examine the geodesics for that matrix.\n\n# set up the matrix\nu_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ),\n  c( 0,1,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ))\n\n# now set the names\nmat_names &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\nrownames( u_mat ) &lt;- mat_names\ncolnames( u_mat ) &lt;- mat_names\n\n# let's look at what the geodist() function creates\nu_mat_geodist &lt;- geodist( u_mat )\nclass( u_mat_geodist )\n\n[1] \"list\"\n\nu_mat_geodist\n\n$counts\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    1    1    1    1\n[2,]    1    1    1    1    1\n[3,]    1    1    1    1    1\n[4,]    1    1    1    1    1\n[5,]    1    1    1    1    1\n\n$gdist\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]    1    0    1    2    2\n[3,]    2    1    0    1    1\n[4,]    3    2    1    0    1\n[5,]    3    2    1    1    0\n\n\nWe can see that the function creates an object of class list. In the object, there are two arrays, $counts and $gdist. The $counts array is a matrix containing the number of geodesics between each pair of vertices. The $gdist array is a matrix containing the geodesic distances between each pair of vertices.\nTo get the geodesic distances, we use the $ sign to select a single array from the list:\n\n# print out the distances\nu_mat_geodist$gdist\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]    1    0    1    2    2\n[3,]    2    1    0    1    1\n[4,]    3    2    1    0    1\n[5,]    3    2    1    1    0\n\n# if we take the row sum of this object, we get the distances\ndistance &lt;- rowSums( u_mat_geodist$gdist )\ndistance\n\n[1] 9 6 5 7 7\n\n\nNow, let’s plot the graph so we can visualize what the distance score is showing. To make it easier to see, let’s add the centrality info to the labels and size the nodes by centrality. That will make it easier to visualize.\n\n# create a vector of labels that combines the name with the distances\n# use the paste() function to put characters and numbers together\nnames_dist &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( distance, 0 ), # add the rounded distance\n  sep = \"\" ) # remove the space between the two inputs \n\n# change the margins using the mar= argument\npar( mar=c( 0.1, 0.5, 1, 0.1 ) )\n\n# set the seed to reproduce the same layout\nset.seed( 507 )\n\n# render the plot\ngplot( \n  u_mat,\n  gmode = \"graph\",\n  label = names_dist,\n  label.cex = 0.6,\n  vertex.col = \"lightblue\"\n  )\n\n\n\n\n\n\n\n\nIn this plot, we see that Jen has a distance score of 9. (She is so far away!) To see how we get that score, let’s do the calculation:\n\nrecall that \\(d(n_i,n_j)\\) is the length of the path from i to j\n\nJen -&gt; Tom (\\(d(Jen,Tom)\\)) is 1\nJen -&gt; Bob (\\(d(Jen,Bob)\\)) is 2\nJen -&gt; Leaf (\\(d(Jen,Leaf)\\)) and Jen -&gt; Jim (\\(d(Jen,Jim)\\)) are both 3\nSo that is \\(\\sum\\limits_{Jen}^g d(Jen,Tom/Bob/Leaf/Jim) = 1+2+3+3=9\\).\n\n\nTo get the closeness centrality score, we divide that quantity by 1.\n\n# take the reciprocal\nclose_cent &lt;- 1 / rowSums( u_mat_geodist$gdist )\nclose_cent\n\n[1] 0.1111111 0.1666667 0.2000000 0.1428571 0.1428571\n\n# we can calculate the standardized closeness centrality by multiplying by g-1\ng &lt;- dim( u_mat )[1]\nclose_cent_s &lt;- ( g-1 ) * close_cent\nclose_cent_s\n\n[1] 0.4444444 0.6666667 0.8000000 0.5714286 0.5714286\n\n# put it all together in a table\ndist_close_table &lt;- round( rbind( distance, close_cent, close_cent_s ), 2 )\nrownames( dist_close_table ) &lt;- c( \"distance\", \"closeness\", \"stand.close\" )\ncolnames( dist_close_table ) &lt;- mat_names\ndist_close_table\n\n             Jen  Tom Bob Leaf  Jim\ndistance    9.00 6.00 5.0 7.00 7.00\ncloseness   0.11 0.17 0.2 0.14 0.14\nstand.close 0.44 0.67 0.8 0.57 0.57\n\n\nNow, let’s take a look at this info in a series of plots. To render these, let’s use a for loop:\n\nnames_close &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( close_cent, 2 ), # add the rounded closeness centrality score\n  sep = \"\" ) # remove the space between the two inputs \n\nnames_s_close &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( close_cent_s, 2 ), # add the rounded closeness centrality score\n  sep = \"\" ) # remove the space between the two inputs \n\n# create the inputs for the loop\ntitles &lt;- c( \"Distance\", \"Closeness\", \"Standardized Closeness\")\ncols &lt;- c( \"lightblue\", \"lightgreen\", \"orange\" )\nnames &lt;- rbind( names_dist, names_close, names_s_close )\n\n# change the margins using the mar= argument\npar( \n  mfrow=c( 2,2 ),\n  mar=c( 0.1, 0.5, 1, 0.1 ) \n  )\n\nfor( i in 1:3 ){\n  \n  # set the seed\n  set.seed( 507 )\n\n  # render the plot\n  gplot( \n  u_mat,\n  gmode = \"graph\",\n  label = names[i,],\n  label.cex = 0.6,\n  vertex.col = cols[i],\n  main = titles[i]\n  )\n\n}\n\n\n\n\n\n\n\n\n\n\nUsing the sna Package\nAlternatively, we could just use the closeness() function in the sna package. First, take a look at the function using ?closeness. Note that the standardized closeness centrality is reported by default. If we want the unstandardized closeness, we can just divide the result returned by closeness() by g-1.\n\n# standardized\ncloseness( u_mat,gmode=\"graph\")\n\n[1] 0.4444444 0.6666667 0.8000000 0.5714286 0.5714286\n\n# raw\ncloseness( u_mat,gmode=\"graph\" ) / ( g-1 )\n\n[1] 0.1111111 0.1666667 0.2000000 0.1428571 0.1428571\n\n\n\n\nCloseness Centralization\nWe can also summarize the entire network in terms of how close nodes are to each other. Group closeness centralization tells us how much variation there is in the closeness scores. As we saw in the textbook chapters on Degree Centrality and Closeness Centrality, this measure is bound between 0 and 1 where a value of 0 indicates complete uniformity across nodes in their centrality scores and a value of 1 indicates that one node has the highest possible centrality score, and all others are at the minimum.\nThis is calculated as: \\(C_C = \\frac{\\sum\\limits_{i=1}^g[C'_C(n^*)-C'_C(n_i)]}{[(g-2)(g-1)]/(2g-3)}\\).\nWhere \\(C'_C(n^*)\\) is the maximum or largest standardized closeness centrality score. For a more elaborate discussion of this equation, see (Wasserman and Faust 1994, 8:191–92). To calculate the group closeness centrality, we can use the centralization() function in sna and specify closeness in the FUN argument.\n\n?centralization\n\ncentralization( u_mat, closeness, mode=\"graph\" )\n\n[1] 0.5518519\n\n\nWhat does the centralization score of 0.55 tell us?",
    "crumbs": [
      "Closeness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#closeness-centrality-directed-binary-graphs",
    "href": "snaca-r-closeness-centrality.html#closeness-centrality-directed-binary-graphs",
    "title": "Closeness Centrality and Centralization",
    "section": "Closeness Centrality (Directed Binary Graphs)",
    "text": "Closeness Centrality (Directed Binary Graphs)\nIn a directed binary graph, closeness centrality has the same interpretation (i.e. it is the inverse of the average distance between nodes), but it takes into account the directional nature of the graph.\nFor example, consider two scenarios:\n\nSuppose Laura sends a tie to Miguel and he sends a tie to Bruce (i.e. Laura -&gt; Miguel -&gt; Bruce). Here, Laura is of distance 2 from Bruce.\nNow suppose Laura sends a tie to Miguel and Bruce sends a tie to Miguel (i.e. Laura -&gt; Miguel &lt;- Bruce).\nHow far is Laura from Bruce now?\n\nLet’s take a look at this using the network from the Closeness Centrality chapter.\n\n# Build the object\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ),\n  c( 0,0,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 )\n  )\n\n# name the rows and columns\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# define g\ng &lt;- dim( d_mat )[1]\n\n\nManually Calculating Closeness Centrality\nWe can manually calculate the distance matrix using the geodist() function in the sna package as we did above.\n\n# calculate distances\ndistances &lt;- geodist( d_mat )\n\n# get the geodesics\ngeodesics &lt;- distances$gdist\n\n# take a look\ngeodesics\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]  Inf    0    1    2    2\n[3,]  Inf  Inf    0    1    1\n[4,]  Inf  Inf    1    0    1\n[5,]  Inf  Inf    1    1    0\n\n\nSomething look different?\nLet’s recode those Inf values to be zero and chug on.\n\n# code Inf values as zero\ngeodesics[geodesics == Inf] &lt;- 0 \n\n# take a look now\ngeodesics\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]    0    0    1    2    2\n[3,]    0    0    0    1    1\n[4,]    0    0    1    0    1\n[5,]    0    0    1    1    0\n\n\n\n# unstandardized closeness\n1/rowSums( geodesics ) \n\n[1] 0.1111111 0.2000000 0.5000000 0.5000000 0.5000000\n\n# standardized closeness\n( 1/rowSums( geodesics ) ) * ( g - 1 )\n\n[1] 0.4444444 0.8000000 2.0000000 2.0000000 2.0000000\n\n\n\n\nUsing the sna Package\nAlternatively, we could (again) just use the closeness() function in the sna package. Remember that the standardized closeness centrality is reported by default. If we want the unstandardized closeness, we can just divide the result returned by closeness() by g-1.\n\n# standardized closeness\ncloseness( d_mat, gmode=\"digraph\" )\n\n[1] 0.4444444 0.0000000 0.0000000 0.0000000 0.0000000\n\n# unstandardized closeness\ncloseness( d_mat, gmode=\"digraph\" ) / ( g-1 )\n\n[1] 0.1111111 0.0000000 0.0000000 0.0000000 0.0000000\n\n\n\n\nCloseness Centralization\nAs discussed in (Wasserman and Faust 1994, 8:200–201), the denominator is not defined for closeness centralization for directed graphs. Yet, score can be computed using the centralization() function.\n\ncentralization( d_mat, closeness, mode=\"digraph\" )\n\n[1] 0.5555556\n\n\nWhat does the centralization score of 0.56 tell us?",
    "crumbs": [
      "Closeness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#closeness-centrality-in-pins-get-along-with-network",
    "href": "snaca-r-closeness-centrality.html#closeness-centrality-in-pins-get-along-with-network",
    "title": "Closeness Centrality and Centralization",
    "section": "Closeness Centrality in PINS Get Along With Network",
    "text": "Closeness Centrality in PINS Get Along With Network\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collect sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:\n\nThe get along with network was created by asking individuals whom they “get along with” on the unit. We can think of this as “friends” in a prison setting. (People don’t really have “friends” in prison, but there are people they “get along with”)\nThe power and influence network was created by asking individuals whom they believed was “powerful and influential” on the unit.\n\nAs we saw in the prior tutorial, both of these networks are available in SNACpack. The get along with network is called: pins_ga_net, and the power and influence network is called: pins_pi_net. Let’s examine the closeness centrality scores for both of these networks.\n\nGet Along with Network (Undirected Network)\nFor the get along with network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. But, we are going to symmetrize the network by only taking ties for which both i and j indicated that the get along with the other person. This will give us an undirected network.\n\n# load the SNACpack package\nlibrary( SNACpack )\n\n# use the symmetrize() function to create an undirected matrix\n# you will notice that this creates an object of class \"matrix\"\nga_mat_u &lt;- symmetrize( pins_ga_net, rule = \"strong\" )\n\n\n# create the network object\n\nga_net_u &lt;- as.network( ga_mat_u, directed = FALSE )\n\n\nNow, we have created an undirected network where ties represent “get along with” nominations from both individuals.\nBefore we calculate the closeness scores, recall that in a graph with multiple components (i.e. disconnected subgraphs) individuals who cannot be reached will have a closeness score of zero. So, what do we do? Call it a day and go home? (We could, but we have some options)\nWhat often happens in practice when we have multiple components in a network is that researchers will take the “first component” and analyze the closeness scores for that graph. The first component is the largest subgraph in a graph. We can see this visually in the following plot:\n\n\n\n\n\n\n\n\n\nIn the plot above, the first component (i.e. the largest subgraph) is colored green. To get the closeness centrality scores, we can use a function called get.inducedSubgraph() in the sna package to extract a subgraph that meets a condition. In this case, we want to take those cases who are in the first component. Let’s walk through the pieces.\n\n# find the component membership\ncd &lt;- component.dist( as.matrix( ga_net_u ), connected=\"weak\" )\n\n\n# find which component is the largest\nsort( table( cd$membership ) )\n\n\n  1   2   3   5   6   7   8   9  10  12  13  14  16  17  19  20  21  22  23  25 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 26  27  29  30  31  32  33  34  35  36  38  40  41  42  43  44  45  47  49  50 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 51  52  53  55  56  58  60  61  63  64  65  66  67  68  69  70  71  73  74  76 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112 114 115 116 117 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n119 120 121 122 123 124 125 126 127 128 129  18  28  39  46  48  57  59  75 113 \n  1   1   1   1   1   1   1   1   1   1   1   2   2   2   2   2   2   2   2   2 \n118  15  37  54  72  11  24  62   4 \n  2   3   3   3   3   4   4   4  50 \n\n# we can see that group number 4 is the largest group. This is the first component.\n# so, we can assign the membership in the first component\nfirst_comp &lt;- cd$membership\nfirst_comp[ cd$membership != 4 ] &lt;- 0\nfirst_comp[ cd$membership == 4 ] &lt;- 1\n\n\n# now we set this as a network attribute\nga_net_u %v% \"first_comp\" &lt;- first_comp\n\n\n# Now, remove those not in the first component \n# by using the get.inducedSubgraph() function.\n# Specifically, we stipulate in the v= argument that \n# we only want vertices that are in the first component.\nga_net_ucomp &lt;- get.inducedSubgraph( \n  ga_net_u, # the network                 \n  v = which( ga_net_u %v% \"first_comp\" == 1 )  # the condition\n  )\n\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_ucomp, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#9cde18\", \n  main = \"First Component of Get\\n Along With Network (Undirected)\" )\n\n\n\n\n\n\n\n\nNow, let’s calculate our closeness scores:\n\n# get the number of nodes\nn_nodes &lt;- dim( as.matrix( ga_net_ucomp ) )[1]\n\n# unstandardized closeness\ncloseness( ga_net_ucomp, gmode=\"graph\" ) / ( n_nodes - 1 )\n\n [1] 0.003533569 0.004545455 0.005524862 0.004854369 0.003039514 0.004184100\n [7] 0.005208333 0.005681818 0.005917160 0.004608295 0.004524887 0.004975124\n[13] 0.005076142 0.004545455 0.005102041 0.004629630 0.005128205 0.003584229\n[19] 0.004651163 0.005025126 0.003745318 0.003184713 0.004464286 0.002652520\n[25] 0.004219409 0.004629630 0.003021148 0.004975124 0.003759398 0.003076923\n[31] 0.005813953 0.003802281 0.005076142 0.004166667 0.003891051 0.003690037\n[37] 0.005405405 0.004484305 0.002680965 0.003496503 0.004629630 0.004000000\n[43] 0.003745318 0.006535948 0.005714286 0.004566210 0.005681818 0.004149378\n[49] 0.003058104 0.004032258\n\n# standardized closeness\ncloseness( ga_net_ucomp, gmode=\"graph\" ) \n\n [1] 0.1731449 0.2227273 0.2707182 0.2378641 0.1489362 0.2050209 0.2552083\n [8] 0.2784091 0.2899408 0.2258065 0.2217195 0.2437811 0.2487310 0.2227273\n[15] 0.2500000 0.2268519 0.2512821 0.1756272 0.2279070 0.2462312 0.1835206\n[22] 0.1560510 0.2187500 0.1299735 0.2067511 0.2268519 0.1480363 0.2437811\n[29] 0.1842105 0.1507692 0.2848837 0.1863118 0.2487310 0.2041667 0.1906615\n[36] 0.1808118 0.2648649 0.2197309 0.1313673 0.1713287 0.2268519 0.1960000\n[43] 0.1835206 0.3202614 0.2800000 0.2237443 0.2784091 0.2033195 0.1498471\n[50] 0.1975806\n\n# Group Closeness Centralization.\ncentralization( ga_net_ucomp, closeness, mode=\"graph\" )\n\n[1] 0.214429\n\n\nWait, did you notice something about the undstandardized closeness scores? Go back and take a look. I will wait…\nOk, I hope you noticed it also. If not, look again and you will see that all the scores are really small. Specifically, the mean is 0.0044. Now, think about why it is so small.\nIf it is not immediately apparent, take a look at the plot of the network below where we size the nodes based on their closeness centrality score. All we have to do is pass these to the vertex_rescale() function:\n\n# now, take a look at the plot\ngplot( \n  ga_net_ucomp, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#9cde18\",\n  vertex.cex = vertex_rescale( closeness( ga_net_ucomp, gmode=\"graph\" ), 0.7, 1.8 ),\n  main = \"First Component of Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by closeness centrality\"\n  )\n\n\n\n\n\n\n\n\nNow, looking at th plot, why is it that the maximum closenessness centrality score is only 0.0065? This mainly has to do with the graph being fairly “spread-out”. That is, there is not a lot of clustering and the average node has to go through a lot of edges to reach most other nodes. To see this, we can calculate the distance matrix as we did above:\n\n# get the geodesics\nga_net_ucomp_geodist &lt;- geodist( ga_net_ucomp )\n\n# calculate the distances\nga_net_ucomp_distance &lt;- rowSums( ga_net_ucomp_geodist$gdist )\n\nThe mean distance is 236.96 meaning that the average nodes has to go through a lot of edges to reach other nodes. Again, a visual aid may help. Take a look at the plot below:\n\n\n\n\n\n\n\n\n\nWhat are the fewest number of edges node 4 has to traverse to reach node 13? To reach 135? These are large distances! That is how we get such small closeness centrality scores.\n\n\nPower and Influence Network (Directed Network)\nFor the power and influence network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. We will keep this asymmetry so that we can treat the network as directed. As mentioned above, the power and influence exists in SNACpack as pins_pi_net.\nAs before, we need to extract the first component:\n\n\n\n\n\n\n\n\n\nIn the plot above, the first component (i.e. the largest subgraph) is shown in red. Now, let’s again use the get.inducedSubgraph() function in the sna package to extract a subgraph that meets the first component condition.\n\n# find the component membership\ncd &lt;- component.dist( as.matrix( pins_pi_net ), connected=\"weak\" )\n\n\n# find which component is the largest\nsort( table( cd$membership ) )\n\n\n  2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 22  23  24  25  26  27  28  29  30  31  32  33  34  36  37  38  39  40  41  42 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 63  64  65  66  67  68  69  71  72  73  74  75  76  77  78  79  80  81  82  83 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n104 105 106 107 108  35  70   1 \n  1   1   1   1   1   2   3  95 \n\n# we can see that group number 1 is the largest group. This is the first component.\n# so, we can assign the membership in the first component\nfirst_comp &lt;- cd$membership\nfirst_comp[ cd$membership != 1 ] &lt;- 0\nfirst_comp[ cd$membership == 1 ] &lt;- 1\n\n\n# now we set this as a network attribute\npins_pi_net %v% \"first_comp\" &lt;- first_comp\n\n\n# Now, remove those not in the first component by using \n# the get.inducedSubgraph() function.\n# Specifically, we stipulate in the v= argument \n# that we only want vertices that are in the first component.\npins_pi_net_comp &lt;- get.inducedSubgraph( \n  pins_pi_net, # the network                 \n  v = which( pins_pi_net %v% \"first_comp\" == 1 )  # the condition\n  )\n\n\n# Now, take a look at the plot:\ngplot( \n  pins_pi_net_comp, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ab163b\", \n  main = \"First Component of Power\\n Network (Directed)\" )\n\n\n\n\n\n\n\n\nNow, let’s calculate our closeness scores. Note a slight change though, in the closeness() function there is the gmode= argument where we specify whether the graph is directed (i.e. \"digraph\" or undirected \"graph\". If we use gmode = \"digraph\" we will get all zeros because it is using the directionality of the network. For our purposes here, we will set the gmode = argument to \"graph\".\nWhy do this? Well, let’s think about what we are doing. By setting the gmode = argument to \"graph\", we are saying that the directionality doesn’t really matter for our network in terms of what closeness means. For example, consider the following: A -&gt; B -&gt; C. Here, by removing the directionality we are saying that A is as close to C as C is to A. Note that if we didn’t ignore the directionalty, then A is of distance 2 from C, but C is of infinite distance from A. We don’t want all those infinite distances, so we ignore the directionality here. In our case, with power influence ties, it makes sense to do this. But, this does  not apply to all networks  and you should think about this decision when working with your network. Essentially ask yourself: does it make sense to ignore the directionality?\nOk, back to where we were. Let’s go ahead and set the gmode = \"graph\" so we can actually get values:\n\n# get the number of nodes\nn_nodes &lt;- dim( as.matrix( pins_pi_net_comp ) )[1]\n\n# unstandardized closeness\ncloseness( pins_pi_net_comp, gmode=\"graph\" ) / ( n_nodes - 1 ) \n\n [1] 0.003367003 0.003891051 0.002857143 0.002824859 0.003311258 0.002531646\n [7] 0.003215434 0.002652520 0.002932551 0.002544529 0.002941176 0.002958580\n[13] 0.002531646 0.003831418 0.003215434 0.001754386 0.002659574 0.002666667\n[19] 0.003968254 0.003154574 0.002439024 0.002659574 0.003030303 0.002881844\n[25] 0.002793296 0.002994012 0.002985075 0.002237136 0.003311258 0.003571429\n[31] 0.002617801 0.004149378 0.002994012 0.003802281 0.003448276 0.002824859\n[37] 0.002881844 0.002127660 0.002604167 0.002331002 0.003289474 0.003030303\n[43] 0.002127660 0.003436426 0.003174603 0.002217295 0.002770083 0.002857143\n[49] 0.002531646 0.003205128 0.002985075 0.003436426 0.002237136 0.003649635\n[55] 0.002881844 0.003816794 0.002531646 0.002793296 0.003546099 0.002336449\n[61] 0.002570694 0.001754386 0.003460208 0.002976190 0.002898551 0.002217295\n[67] 0.002320186 0.002092050 0.003460208 0.003484321 0.003076923 0.003937008\n[73] 0.003389831 0.002341920 0.004048583 0.003745318 0.003533569 0.003984064\n[79] 0.002976190 0.002127660 0.002881844 0.002392344 0.002531646 0.002433090\n[85] 0.002057613 0.002985075 0.002824859 0.004132231 0.003436426 0.002985075\n[91] 0.002564103 0.003058104 0.002777778 0.002857143 0.003472222\n\n# standardized closeness\ncloseness( pins_pi_net_comp, gmode=\"graph\" ) \n\n [1] 0.3164983 0.3657588 0.2685714 0.2655367 0.3112583 0.2379747 0.3022508\n [8] 0.2493369 0.2756598 0.2391858 0.2764706 0.2781065 0.2379747 0.3601533\n[15] 0.3022508 0.1649123 0.2500000 0.2506667 0.3730159 0.2965300 0.2292683\n[22] 0.2500000 0.2848485 0.2708934 0.2625698 0.2814371 0.2805970 0.2102908\n[29] 0.3112583 0.3357143 0.2460733 0.3900415 0.2814371 0.3574144 0.3241379\n[36] 0.2655367 0.2708934 0.2000000 0.2447917 0.2191142 0.3092105 0.2848485\n[43] 0.2000000 0.3230241 0.2984127 0.2084257 0.2603878 0.2685714 0.2379747\n[50] 0.3012821 0.2805970 0.3230241 0.2102908 0.3430657 0.2708934 0.3587786\n[57] 0.2379747 0.2625698 0.3333333 0.2196262 0.2416452 0.1649123 0.3252595\n[64] 0.2797619 0.2724638 0.2084257 0.2180974 0.1966527 0.3252595 0.3275261\n[71] 0.2892308 0.3700787 0.3186441 0.2201405 0.3805668 0.3520599 0.3321555\n[78] 0.3745020 0.2797619 0.2000000 0.2708934 0.2248804 0.2379747 0.2287105\n[85] 0.1934156 0.2805970 0.2655367 0.3884298 0.3230241 0.2805970 0.2410256\n[92] 0.2874618 0.2611111 0.2685714 0.3263889\n\n# Group Closeness Centralization\ncentralization( pins_pi_net_comp, closeness, mode=\"graph\" )\n\n[1] 0.2273318\n\n\nAgain, we can use the closeness scores in the plot using the vertex_rescale() function:\n\ngplot( \n  pins_pi_net_comp, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ab163b\",\n  vertex.cex = vertex_rescale( closeness( pins_pi_net_comp, gmode=\"graph\" ), 0.4, 3 ),\n  main = \"First Component of Power\\n Network (Directed)\",\n  sub = \"node sized by closeness centrality\"\n  )\n\n\n\n\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the closeness centralization score of 0.23 indicate?",
    "crumbs": [
      "Closeness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#test-your-knowledge-exercises",
    "href": "snaca-r-closeness-centrality.html#test-your-knowledge-exercises",
    "title": "Closeness Centrality and Centralization",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nExplain the concept of closeness centrality in your own words. How does it differ from degree centrality?\nUsing the u_mat matrix in the tutorial, manually calculate the closeness centrality for the node “Jen.” Show your calculations step by step.\nUsing the “Get Along With” network, identify why only the largest component is analyzed for closeness centrality. What are the potential consequences of ignoring smaller components?\nIn the “Power and Influence Network,” why do we adjust the gmode argument when calculating closeness centrality? What are the implications of analyzing a directed network as undirected?\nFor both the “Get Along With” and “Power and Influence” networks, calculate the standardized closeness centrality for a specific node of your choice. Compare the results between the two networks.\nInterpret the group closeness centralization score for the “Get Along With” network. What does this score reveal about the structure of the network?\nExplain why Inf values appear in the geodesic distance matrix for directed graphs and how these values are handled during calculations.\nUsing the “Power and Influence Network,” examine the visual representation of the first component. What structural patterns do you observe, and how do these relate to the closeness centrality scores?\nAfter calculating the closeness centralization scores for both networks, compare their values. What do the differences in scores suggest about the overall structure of the two networks?",
    "crumbs": [
      "Closeness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#tutorial-summary",
    "href": "snaca-r-closeness-centrality.html#tutorial-summary",
    "title": "Closeness Centrality and Centralization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial provided an introduction to calculating closeness centrality and centralization in network analysis using R. It begins by explaining the theoretical foundation of closeness centrality, emphasizing its distinction from degree centrality by focusing on the inverse of the average distance between nodes. The tutorial demonstrates how to manually compute closeness centrality using the geodist() function from the sna package and visualize results through network plots. It covered both undirected and directed graphs, highlighting the nuances of analyzing asymmetric relationships and handling disconnected components. Additionally, the tutorial introduced the concept of group closeness centralization, which measures the variability in closeness scores across the network, and explains how to compute it using the centralization() function. Real-world examples, such as the “Get Along With” and “Power and Influence” networks from the Prison Inmate Networks Study (PINS), illustrate the practical application of these metrics.\n\n\n\n\nWasserman, Stanley, and Katherine Faust. 1994. Social Network Analysis: Methods and Applications. Vol. 8. Structural Analysis in the Social Sciences. Cambridge, UK: Cambridge University Press.",
    "crumbs": [
      "Closeness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html",
    "href": "snaca-r-betweenness-centrality.html",
    "title": "Betweenness Centrality and Centralization",
    "section": "",
    "text": "Betweenness Centrality (Undirected Binary Graphs)\nHow do we know whether a node is important in a network? As was discussed at the beginning of the chapter on Degree Centrality, one of the most popular concepts in network analysis is centrality. In that lecture, we covered how centrality can be measured by the number of edges incident on a node. Then, in the chapter on Closeness Centrality, we discussed an alternative conceptualization, closeness, where important nodes are those who are “close” to other nodes in the network. Finally, in the Betweenness Centrality chapter we covered a final conceptualization, betweenness, where important nodes are those that occupy positions between other nodes.\nIn this tutorial, we will examine how to calculate betweenness centrality and centralization scores in R using the betweenness() and centralization() functions in the sna package.\nBetweenness centrality is based on the number of shortest paths between j and k that actor i resides on.\nBetweenness centrality is calculated as:\n\\[C_B(n_i) = \\sum\\limits_{j&lt;k} g_{jk}(n_i) / g_{jk}\\]\nWhere \\(g_{jk}\\) represents the number of geodesics linking j to k and \\(g_{jk}(n_i)\\) is the number of geodesics linking j and k that contain i. So, betweenness centrality is the ratio of the geodesics between j and k that contain i to the geodesics between j and k that do not contain i.\nThe standardized betweenness centrality score is calculated by:\n\\[C'_B(n_i) = \\frac{\\sum\\limits_{j&lt;k} g_{jk}(n_i) / g_{jk}}{[(g-1)(g-2)/2]}\\]\nThe difference here is that we are dividing by \\((g-1)(g-2)/2\\) which is the number of pairs of actors not including i.",
    "crumbs": [
      "Betweenness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#betweenness-centrality-undirected-binary-graphs",
    "href": "snaca-r-betweenness-centrality.html#betweenness-centrality-undirected-binary-graphs",
    "title": "Betweenness Centrality and Centralization",
    "section": "",
    "text": "Using the sna Package\nLet’s go ahead and set up a simple matrix and see how we can calculate betweenness centrality using the betweenness() function in the sna package:\n\n# set up the matrix\nu_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ),\n  c( 0,1,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ))\n\n# now set the names\nmat_names &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\nrownames( u_mat ) &lt;- mat_names\ncolnames( u_mat ) &lt;- mat_names\n\n# define the number of nodes in the graph\ng &lt;- dim( u_mat )[1]\n\nNow, let’s take a look at the betweenness() function:\n\n?betweenness\n\n# raw\nbetweenness( u_mat, gmode=\"graph\" )\n\n[1] 0 3 4 0 0\n\n# standardized\nbetweenness( u_mat, gmode=\"graph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n[1] 0.0000000 0.5000000 0.6666667 0.0000000 0.0000000\n\n\nNow, let’s plot the graph so we can visualize what the betweenness score is showing. To make it easier to see, let’s add the betweenness centrality info to the labels and size the nodes by betweenness centrality. That will make it easier to visualize.\n\n# create an object that is the scores\nnode_betweenness &lt;- betweenness( u_mat,gmode=\"graph\" )\n\n# create a vector of labels that combines the name with the betweeness scores\n# use the paste() function to put characters and numbers together\nnames_between &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( node_betweenness, 0 ), # add the rounded distance\n  sep = \"\" ) # remove the space between the two inputs \n\n# set the seed to reproduce the same layout\nset.seed( 507 )\n\n# render the plot\ngplot( \n  u_mat,\n  gmode = \"graph\",\n  label = names_between,\n  label.cex = 0.6,\n  vertex.col = \"lightblue\"\n  )\n\n\n\n\n\n\n\n\nIn this plot, we see that Tom and Bob both have scores of 3 and 4, respectively, whereas Jen, Leaf, and Jim have scores of 0. Why do Jen, Leaf, and Jim have scores of 0? Because nobody has to go “between” them to reach other nodes.\n\n\nBetweenness Centralization\nWe can also summarize the entire network, in terms of betweenness. Group betweenness centralization tells us how much variation there is in the betweenness scores. As we saw in the chapters on Degree Centrality and Closeness Centrality, this measure is bound between 0 and 1 where a value of 0 indicates complete uniformity across nodes in their centrality scores and a value of 1 indicates that one node has the highest possible centrality score, and all others are at the minimum.\nFor betweenness centrality, this is calculated as:\n\\[C_B = \\frac{\\sum\\limits_{i=1}^g[C'_B(n^*)-C'_B(n_i)]}{(g-1)}\\]\nWhere \\(C'_B(n^*)\\) is the maximum or largest standardized betweenness centrality score. To calculate the group betweenness centrality, we can use the centralization() function in sna and specify betweenness in the FUN argument.\n\n?centralization\n\ncentralization( u_mat, betweenness, mode=\"graph\" )\n\n[1] 0.5416667\n\n\nWhat does the centralization score of 0.54 tell us?",
    "crumbs": [
      "Betweenness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#betweenness-centrality-directed-binary-graphs",
    "href": "snaca-r-betweenness-centrality.html#betweenness-centrality-directed-binary-graphs",
    "title": "Betweenness Centrality and Centralization",
    "section": "Betweenness Centrality (Directed Binary Graphs)",
    "text": "Betweenness Centrality (Directed Binary Graphs)\nAs with undirected graphs, we can calculate betweenness centrality scores for directed graphs. In a directed binary graph, betweenness centrality has the same interpretation, but it takes into account the directional nature of the graph.\nFor example, consider two scenarios:\n\nSuppose Laura sends a tie to Miguel and he sends a tie to Bruce (i.e. Laura -&gt; Miguel -&gt; Bruce). Here, Miguel is between Laura and Bruce and has a betweeness score of 1.\nNow suppose Laura sends a tie to Miguel and Bruce sends a tie to Miguel (i.e. Laura -&gt; Miguel &lt;- Bruce).\nIs Miguel between Laura and Bruce now?\n\nLet’s take a look at this using the network from the Betweenness Centrality chapter.\n\n# build the matrix\nd_mat &lt;- rbind(\n  c(0,1,0,0,0),\n  c(0,0,1,0,0),\n  c(0,0,0,1,1),\n  c(0,0,1,0,1),\n  c(0,0,1,1,0)\n  )\n\n# attach the names\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\nNow, let’s use the same code we used above to calculate the betweenness centrality scores. Note, however, that we have to change the gmode= argument in the betweenness() and centralization() functions to be digraph since the graph is directed and we want to include the information on directionality in the calculations (recall that for undirected graphs we use graph).\n\n# define the number of nodes in the graph for our calculation\ng &lt;- dim( d_mat )[1]\n\n# unstandardized\nbetweenness( d_mat, gmode=\"digraph\" )\n\n[1] 0 3 4 0 0\n\n# standardized\nbetweenness( d_mat, gmode=\"digraph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n[1] 0.0000000 0.5000000 0.6666667 0.0000000 0.0000000\n\n\nLet’s plot this to better visualize the scores:\n\n# create an object that is the scores\nnode_betweenness &lt;- betweenness( d_mat, gmode=\"digraph\" )\n\n# create a vector of labels that combines the name with the betweeness scores\n# use the paste() function to put characters and numbers together\nnames_between &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( node_betweenness, 0 ), # add the rounded distance\n  sep = \"\" ) # remove the space between the two inputs \n\n# set the seed to reproduce the same layout\nset.seed( 507 )\n\n# render the plot\ngplot( \n  d_mat,\n  gmode = \"digraph\",\n  label = names_between,\n  label.cex = 0.6,\n  arrowhead.cex = 0.5,\n  vertex.col = \"#2e5087\"\n  )\n\n\n\n\n\n\n\n\nFinally, let’s examine the betweenness centralization score:\n\n# Group Betweenness Centralization.\ncentralization( d_mat, betweenness, mode=\"digraph\" ) \n\n[1] 0.2708333\n\n\nWhat does the centralization score of 0.27 tell us?\nCompare the centralization score of 0.54 for the undirected graph above and the centralization score of 0.27 for the directed graph we just calculated.\nBonus question: Which one is larger? What does the difference in the values mean in terms of how betweenness scores are distributed in the graph?",
    "crumbs": [
      "Betweenness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#betweenness-centrality-in-pins-get-along-with-network",
    "href": "snaca-r-betweenness-centrality.html#betweenness-centrality-in-pins-get-along-with-network",
    "title": "Betweenness Centrality and Centralization",
    "section": "Betweenness Centrality in PINS Get Along With Network",
    "text": "Betweenness Centrality in PINS Get Along With Network\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collect sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:\n\nThe get along with network was created by asking individuals whom they “get along with” on the unit. We can think of this as “friends” in a prison setting. (People don’t really have “friends” in prison, but there are people they “get along with”)\nThe power and influence network was created by asking individuals whom they believed was “powerful and influential” on the unit.\n\nAs we saw in the past tutorials, both of these networks are available in SNACpack. The get along with network is called: pins_ga_net, and the power and influence network is called: pins_pi_net. Let’s examine the betweeness centrality scores for both of these networks.\n\nGet Along with Network (Undirected Network)\nFor the get along with network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. But, we are going to symmetrize the network by only taking ties for which both i and j indicated that the get along with the other person. This will give us an undirected network.\n\n# load the SNACpack package\n\nlibrary( SNACpack )\n\n\n# use the symmetrize() function to create an undirected matrix\n# you will notice that this creates an object of class \"matrix\"\n\nga_mat_u &lt;- symmetrize( pins_ga_net, rule = \"strong\" )\n\n\n# create the network object\n\nga_net_u &lt;- as.network( ga_mat_u, directed = FALSE )\n\nNow, let’s calculate our betweenness scores:\n\n# define the number of nodes in the graph for our calculation\n\ng &lt;- dim( as.matrix( ga_net_u ) )[1]\n\n\n# another way to do this is with the network.size \n# function in the network package (which is less code to write)\n\ng &lt;- network.size( ga_net_u )\n\n\n# unstandardized\n\nbetweenness( ga_net_u, gmode=\"graph\" )\n\n  [1]   0.000000   0.000000   0.000000 140.000000   0.000000   0.000000\n  [7]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [13]  94.000000   0.000000   0.000000   0.000000 291.866667   0.000000\n [19]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [25]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [31]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [37]   0.000000   0.000000   0.000000 242.666667  48.000000  86.216667\n [43] 209.966667   1.000000   0.000000 237.333333 335.366667   0.000000\n [49]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [55]   0.000000  27.200000   0.000000   0.000000   0.000000   0.000000\n [61]   0.000000  51.516667   0.000000   0.000000   0.000000   0.000000\n [67]  19.166667  16.700000 140.000000 141.150000   0.000000   0.000000\n [73]   0.000000   0.000000   0.000000   0.000000   1.000000   0.000000\n [79]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [85]   0.000000   2.000000   0.000000   0.000000   0.000000   0.000000\n [91]   0.000000   0.000000   0.000000   0.000000 180.000000   4.033333\n [97]   0.000000   0.000000   0.000000   3.000000   0.000000  48.000000\n[103]   0.000000  48.000000   0.000000   0.000000   0.000000 272.200000\n[109]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[115]   0.000000   0.000000   0.000000   0.000000   2.000000   0.000000\n[121]   0.000000 358.733333   0.000000   0.000000  26.166667   0.000000\n[127]   3.983333   0.000000  39.200000   0.000000   0.000000   0.000000\n[133]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[139]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[145]   0.000000   0.000000   0.000000  19.166667   0.000000   0.000000\n[151]  11.000000   0.000000   0.000000   0.000000 681.733333   0.000000\n[157]   0.000000 302.000000   0.000000   0.000000   0.000000  95.000000\n[163] 343.966667   0.000000   0.000000 184.666667   0.000000   0.000000\n[169]   0.000000   0.000000   0.000000   0.000000   0.000000   2.000000\n[175]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[181]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[187]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[193]   1.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[199]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[205]   0.000000\n\n# standardized\n\nbetweenness( ga_net_u, gmode=\"graph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n  [1] 0.000000e+00 0.000000e+00 0.000000e+00 6.761325e-03 0.000000e+00\n  [6] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [11] 0.000000e+00 0.000000e+00 4.539747e-03 0.000000e+00 0.000000e+00\n [16] 0.000000e+00 1.409575e-02 0.000000e+00 0.000000e+00 0.000000e+00\n [21] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [26] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [31] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [36] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 1.171963e-02\n [41] 2.318169e-03 4.163849e-03 1.014038e-02 4.829518e-05 0.000000e+00\n [46] 1.146206e-02 1.619659e-02 0.000000e+00 0.000000e+00 0.000000e+00\n [51] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [56] 1.313629e-03 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [61] 0.000000e+00 2.488007e-03 0.000000e+00 0.000000e+00 0.000000e+00\n [66] 0.000000e+00 9.256576e-04 8.065295e-04 6.761325e-03 6.816865e-03\n [71] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [76] 0.000000e+00 4.829518e-05 0.000000e+00 0.000000e+00 0.000000e+00\n [81] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [86] 9.659036e-05 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [91] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 8.693132e-03\n [96] 1.947906e-04 0.000000e+00 0.000000e+00 0.000000e+00 1.448855e-04\n[101] 0.000000e+00 2.318169e-03 0.000000e+00 2.318169e-03 0.000000e+00\n[106] 0.000000e+00 0.000000e+00 1.314595e-02 0.000000e+00 0.000000e+00\n[111] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[116] 0.000000e+00 0.000000e+00 0.000000e+00 9.659036e-05 0.000000e+00\n[121] 0.000000e+00 1.732509e-02 0.000000e+00 0.000000e+00 1.263724e-03\n[126] 0.000000e+00 1.923758e-04 0.000000e+00 1.893171e-03 0.000000e+00\n[131] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[136] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[141] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[146] 0.000000e+00 0.000000e+00 9.256576e-04 0.000000e+00 0.000000e+00\n[151] 5.312470e-04 0.000000e+00 0.000000e+00 0.000000e+00 3.292443e-02\n[156] 0.000000e+00 0.000000e+00 1.458514e-02 0.000000e+00 0.000000e+00\n[161] 0.000000e+00 4.588042e-03 1.661193e-02 0.000000e+00 0.000000e+00\n[166] 8.918510e-03 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[171] 0.000000e+00 0.000000e+00 0.000000e+00 9.659036e-05 0.000000e+00\n[176] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[181] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[186] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[191] 0.000000e+00 0.000000e+00 4.829518e-05 0.000000e+00 0.000000e+00\n[196] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[201] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n\n\nLet’s create a plot that has the nodes sized by their betweenness centrality score.\n\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ba491c\",\n  vertex.cex = betweenness( ga_net_u, gmode=\"graph\" ),\n  main = \"Get Along With Network (Undirected)\",\n  sub = \"node sized by betweenness centrality\"\n  )\n\n\n\n\n\n\n\n\nWait? Something isn’t right…All I see is a blob of color. This is because the size of the nodes in the plot are HUGE! We can see this by using the max() function. The max() function finds the maximum value of a vector:\n\nmax( betweenness( ga_net_u, gmode=\"graph\" ) )\n\n[1] 681.7333\n\n\nThe largest betweenness centrality score is 681.7333333, so the plot is using this value. What we need is to adjust the centrality scores so that they are not so large. Fortunately, there is a simple function we can write to do this.\nLet’s use the vertex_rescale() function to adjust the node sizes in our plot:\n\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ba491c\",\n  vertex.cex = vertex_rescale( betweenness( ga_net_u, gmode=\"graph\" ), 0.5, 2.5 ),\n  main = \"Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by betweenness centrality\"\n  )\n\n\n\n\n\n\n\n\nMuch better. Yet, it is still a bit difficult to see the differences due to the number of isolates (i.e. nodes without any edges). Let’s remove them using the displayisolates = argument. We will set it to FALSE to not display nodes that are isolates.\n\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ba491c\",\n  vertex.cex = vertex_rescale( betweenness( ga_net_u, gmode=\"graph\" ), 0.5, 2.5 ),\n  main = \"Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by betweenness centrality\",\n  displayisolates = FALSE # here we set it to FALSE, TRUE is the default\n  )\n\n\n\n\n\n\n\n\nNow we can examine the centralization score for the network:\n\n# note the \"mode=\" argument!\ncentralization( ga_net_u, betweenness, mode=\"graph\" ) \n\n[1] 0.03197054\n\n\nWhat does the centralization score of 0.03 tell us?\n\n\nPower and Influence Network (Directed Network)\nFor the power and influence network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. We will keep this asymmetry so that we can treat the network as directed. As we have seen, the power and influence exists in SNACpack as pins_pi_net.\n\n# define the number of nodes in the graph for our calculation\ng &lt;- network.size( pins_pi_net )\n\n# unstandardized\nbetweenness( pins_pi_net, gmode=\"digraph\" )\n\n  [1]  9.0  0.0  0.0 59.5  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [16]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  7.0  0.0  0.0  0.0  0.0  0.0\n [31]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  7.0  0.0  0.0  0.0  0.0  0.0\n [46] 49.5  5.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [61]  0.0  0.0  0.0  0.0  0.0  0.0 28.5  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [76]  0.0  0.0  0.0  0.0  0.0  3.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [91]  0.0  0.0  0.0  0.0  0.0  0.0  0.0 19.0  0.0  0.0  0.0  2.0  0.0  0.0  0.0\n[106]  0.0  0.0  4.0  0.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 12.0  0.0\n[121]  2.0  7.0  0.0  0.0  0.0  0.0  0.0  0.0  5.5  1.5  0.0  0.0  0.0  1.0  0.0\n[136]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 10.0  0.0  0.0\n[151]  0.0  0.0  5.0  0.0  0.0  4.0  0.0  0.0  0.0  0.0  0.0  7.5  0.0  0.0  0.0\n[166] 51.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  4.0  0.0  0.0  0.0\n[181]  0.0  0.0  0.0  0.0  0.0  0.0 77.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n[196]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n# standardized\nbetweenness( pins_pi_net, gmode=\"digraph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n  [1] 4.346566e-04 0.000000e+00 0.000000e+00 2.873563e-03 0.000000e+00\n  [6] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [11] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [16] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [21] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 3.380663e-04\n [26] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [31] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [36] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 3.380663e-04\n [41] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [46] 2.390611e-03 2.414759e-04 0.000000e+00 0.000000e+00 0.000000e+00\n [51] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [56] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [61] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [66] 0.000000e+00 1.376413e-03 0.000000e+00 0.000000e+00 0.000000e+00\n [71] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [76] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [81] 1.448855e-04 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [86] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [91] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [96] 0.000000e+00 0.000000e+00 9.176084e-04 0.000000e+00 0.000000e+00\n[101] 0.000000e+00 9.659036e-05 0.000000e+00 0.000000e+00 0.000000e+00\n[106] 0.000000e+00 0.000000e+00 1.931807e-04 0.000000e+00 2.897711e-04\n[111] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[116] 0.000000e+00 0.000000e+00 0.000000e+00 5.795422e-04 0.000000e+00\n[121] 9.659036e-05 3.380663e-04 0.000000e+00 0.000000e+00 0.000000e+00\n[126] 0.000000e+00 0.000000e+00 0.000000e+00 2.656235e-04 7.244277e-05\n[131] 0.000000e+00 0.000000e+00 0.000000e+00 4.829518e-05 0.000000e+00\n[136] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[141] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[146] 0.000000e+00 0.000000e+00 4.829518e-04 0.000000e+00 0.000000e+00\n[151] 0.000000e+00 0.000000e+00 2.414759e-04 0.000000e+00 0.000000e+00\n[156] 1.931807e-04 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[161] 0.000000e+00 3.622139e-04 0.000000e+00 0.000000e+00 0.000000e+00\n[166] 2.463054e-03 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[171] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[176] 0.000000e+00 1.931807e-04 0.000000e+00 0.000000e+00 0.000000e+00\n[181] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[186] 0.000000e+00 3.718729e-03 0.000000e+00 0.000000e+00 0.000000e+00\n[191] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[196] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[201] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n\n\nNow, we can plot it to examine the scores:\n\n# adjust the margins to cut some white space\npar( mar=c( 0, 0, 2, 0 ) )\n\n# render the plot\ngplot( \n  pins_pi_net, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#0b7344\",\n  vertex.cex = vertex_rescale( betweenness( pins_pi_net, gmode=\"digraph\" ), 0.5, 2.5 ),\n  arrowhead.cex = 0.5,\n  main = \"Power/Influence Network (Directed) \\n (node sized by betweenness centrality)\"\n  )\n\n\n\n\n\n\n\n\nAgain, let’s remove the isolates:\n\n# adjust the margins to cut some white space\npar( mar=c( 0, 0, 2, 0 ) )\n\n# render the plot\ngplot( \n  pins_pi_net, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#0b7344\",\n  vertex.cex = vertex_rescale( betweenness( pins_pi_net, gmode=\"digraph\" ), 0.5, 2.5 ),\n  arrowhead.cex = 0.5,\n  main = \"Power/Influence Network (Directed) \\n (node sized by betweenness centrality)\",\n  displayisolates = FALSE\n  )\n\n\n\n\n\n\n\n\nExamine the centralization score for the network:\n\n# note the \"mode=\" argument here is different!\ncentralization( pins_pi_net, betweenness, mode=\"digraph\" ) \n\n[1] 0.00182267\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the closeness centralization score of 0.0018 indicate?",
    "crumbs": [
      "Betweenness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#test-your-knowledge-exercises",
    "href": "snaca-r-betweenness-centrality.html#test-your-knowledge-exercises",
    "title": "Betweenness Centrality and Centralization",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nDefine betweenness centrality and explain its importance in network analysis.\nModify the matrix u_mat to include a new node and recalculate the betweenness centrality scores. How do the scores change?\nFor the directed graph d_mat, calculate the betweenness centrality and plot the graph. How does the directionality affect the results?\nCompare the centralization scores of u_mat (undirected) and d_mat (directed). What does the difference indicate about the distribution of betweenness scores?\nVisualize the “Power and Influence Network” as a directed graph with node sizes proportional to their betweenness centrality scores. Describe key observations from the plot.\nDiscuss the implications of removing isolates from a network visualization using the “Get Along With Network” as an example.\nExplain the meaning of the betweenness centralization score for the “Power and Influence Network” and how it compares to the betweenness centralization score for the “Get Along With Network”.\nInterpret the maximum betweenness centrality score for the “Get Along With Network” and discuss its implications for network structure. Do the same for the “Power and Influence Network”.",
    "crumbs": [
      "Betweenness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#tutorial-summary",
    "href": "snaca-r-betweenness-centrality.html#tutorial-summary",
    "title": "Betweenness Centrality and Centralization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced the concept of betweenness centrality and centralization and how it can be calculated using the betweenness() function in the sna package in R, key measures in social network analysis used to identify important nodes in a network based on their intermediary roles. We reviewed this calculation for both undirected and directed networks, illustrating how directionality influences betweenness scores and centralization metrics. These exercises demonstrated how betweenness centrality and centralization provide valuable insights into social dynamics and power structures within criminal justice contexts.",
    "crumbs": [
      "Betweenness Centrality and Centralization"
    ]
  },
  {
    "objectID": "snaca-r-bipartite.html",
    "href": "snaca-r-bipartite.html",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "",
    "text": "Bipartite Graphs/Two-Mode Networks\nAs discussed in the Bipartite Graphs & Two-Mode Networks chapter of the textbook, bipartite graphs are useful for operationalizing contexts where nodes come from two separate classes. In contrast to one-mode networks, or unipartite graphs, where edges can be incident within a particular node/vertex set, in two-mode or bipartite graphs there are two partitions of nodes (called modes), and edges only occur between these partitions (i.e. not within).\nThis tutorial examines various properties of bipartite graphs (e.g. density, degree centrality) and shows how to work with these structures in R using the network and sna packages.\nTo begin, let’s build the example bipartite graph from the Bipartite Graphs & Two-Mode Networks chapter:\n# create the example network\nbipartite_example &lt;- rbind(\n  c( 1,1,0,0,0 ),\n  c( 1,0,0,0,0 ),\n  c( 1,1,0,0,0 ),\n  c( 0,1,1,1,1 ),\n  c( 0,0,1,0,0 ), \n  c( 0,0,1,0,1 ) )\n\n# assign names to the rows\nrownames( bipartite_example ) &lt;- c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\" )\n\n# assign names to the columns\ncolnames( bipartite_example ) &lt;- c( \"1\",\"2\",\"3\",\"4\",\"5\" )\n\n# print out the object\nbipartite_example\n\n  1 2 3 4 5\nA 1 1 0 0 0\nB 1 0 0 0 0\nC 1 1 0 0 0\nD 0 1 1 1 1\nE 0 0 1 0 0\nF 0 0 1 0 1\nAs we can see, the matrix has 6 rows and 5 columns. So, the order of the matrix is 6 x 5.",
    "crumbs": [
      "Bipartite Graphs & Two-Mode Networks"
    ]
  },
  {
    "objectID": "snaca-r-bipartite.html#bipartite-graphstwo-mode-networks",
    "href": "snaca-r-bipartite.html#bipartite-graphstwo-mode-networks",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "",
    "text": "Using the network Package\nWe can create an object of class network by using the as.network() function in the network package. First, take a look at the help for the as.network() function, paying particular attention to the bipartite= argument.\n\n# call the network package\nlibrary( network )\n\n# pull up the help for the as.network() function\n?as.network\n\nIn looking through the help file for the as.network() function, we see that the bipartite= argument says that this argument allows the count of the number of actors in the bipartite network. A bipartite adjacency matrix has order NxM, where N represents the number of rows (e.g. actors) and M represents the number of columns (e.g. events). In the bipartite= argument, we can specify the count of actors as N.\nFor example:\n\n# identify the number of actors in the example\nN &lt;- dim( bipartite_example )[1]\n\n# create a network object\nbipartite_example_net &lt;- as.network(\n  bipartite_example, # here is our matrix\n  bipartite = N      # define the number of actors\n  )\n\n# there 11 vertices, 6 are bipartite (in the first mode), and 12 edges\nbipartite_example_net\n\n Network attributes:\n  vertices = 11 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = 6 \n  total edges= 12 \n    missing edges= 0 \n    non-missing edges= 12 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\n\n\nUsing gplot() in the sna Package\nNow that our object is created, we can take a look at a plot of the network using the gplot() function. Before we do so, let’s take a look at a few changes we need to make. First, note that the gplot() function reads the labels by starting with the names in the first mode, then the names in the second mode. We can see this by printing the vertex labels the function assigns with the network.vertex.names() function.\n\n# look how it reads the labels\nnetwork.vertex.names( bipartite_example_net ) \n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\nWe can see that it first labels the actor nodes (i.e. A, B, C, D, E, and F) and then names the event nodes (i.e. 1, 2, 3, 4, 5).\nSecond, we need to tell the gplot() function that the network has two modes, not one mode. We do this using the gmode= argument, which automatically changes the colors and the shapes of the nodes when we specify that the graph is twomode. Third, we need to set the usearrows= argument to FALSE so that the arrowheads are turned off. (Note that there are directed two-mode networks in which you would use arrowheads, but we will skip that for now). Let’s check it out:\n\n# load the sna library to get the gplot() function\nlibrary( sna )\n\n# set the seed to reproduce the plot layout\nset.seed( 507 )\n\n# execute the plot\ngplot(\n  bipartite_example_net,                                  # our network to plot\n  label = network.vertex.names( bipartite_example_net ),  # the labels we want\n  gmode = \"twomode\",                                      # indicate it is two modes\n  usearrows = FALSE,                                      # turn off the arrowheads\n  vertex.cex=2,                                           # size the nodes     \n  label.cex=1.2,                                          # size the labels\n  main=\"Bipartite Graph of Example Graph\"                 # add a title\n)\n\n\n\n\n\n\n\n\nAs we saw in the Basics of Network Visualization tutorial, there are a lot of options that help us convey important information about a network. When we are working with a two mode network object, we need to make sure that whatever information we pass to the nodes matches the order of the nodes in the network. For example, we saw above that the network first labels the actor nodes and then labels the event nodes. If we wanted to choose a different set of colors, for example, using the vertex.col= argument, then we would want a set of colors for the actors and a set of colors for the events. Then, we would want these combined into a single object. Let’s do that here to demonstrate:\n\n# identify the number of actors in the example\nN &lt;- dim( bipartite_example )[1]\n\n# identify the number of events in the example\nM &lt;- dim( bipartite_example )[2]\n\n# set the actor colors\nactor.col &lt;- rep( \"#1fdeb1\", N )\n\n# set the event colors\nevent.col &lt;- rep( \"#bab4de\", M )\n\n# now combine them into a single vector of colors\nnode_col &lt;- c( actor.col, event.col )\n\n# take a look\nnode_col\n\n [1] \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#bab4de\"\n [8] \"#bab4de\" \"#bab4de\" \"#bab4de\" \"#bab4de\"\n\n\nNow that we have a set of colors that match the order of the nodes, we can pass it into the gplot() function using the vertex.col= argument:\n\n# set the seed to reproduce the plot layout\nset.seed( 507 )\n\n# execute the plot\ngplot(\n  bipartite_example_net,                                  # our network to plot\n  label = network.vertex.names( bipartite_example_net ),  # the labels we want\n  gmode = \"twomode\",                                      # indicate it is two modes\n  usearrows = FALSE,                                      # turn off the arrowheads\n  vertex.cex = 3,                                         # size the nodes     \n  label.cex = 1.2,                                        # size the labels\n  label.pos = 5,                                          # position the labels on the nodes\n  main=\"Bipartite Graph of Example Graph\",                # add a title\n  \n  # here is the addition to what we had above:\n  vertex.col = node_col                                   # add the colors\n)\n\n\n\n\n\n\n\n\nThis setup, where we define the actor properties and event properties and combine them into a vector, will be used for any attribute we want to attach to the nodes. We will work through more examples below illustrating this point.",
    "crumbs": [
      "Bipartite Graphs & Two-Mode Networks"
    ]
  },
  {
    "objectID": "snaca-r-bipartite.html#structural-properties-of-bipartite-graphstwo-mode-networks",
    "href": "snaca-r-bipartite.html#structural-properties-of-bipartite-graphstwo-mode-networks",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Structural Properties of Bipartite Graphs/Two-Mode Networks",
    "text": "Structural Properties of Bipartite Graphs/Two-Mode Networks\nAs reviewed in the Bipartite Graphs & Two-Mode Networks chapter of the textbook, there are multiple structural properties of bipartite graphs that we can examine to help us describe the network.\n\nDensity\nThe density of a bipartite graph is the number of observed edges in the graph, L, divided by the number of nodes in the first mode, N, multiplied by the number of nodes in the second mode, M. That is:\n\\[\\frac{L}{N \\times M}\\]\nIn other words, the density of the graph is the number of edges we observed divided by the maximum number of possible edges in the graph. We can calculate this using the sum() and dim() functions.\n\n# identify the number of edges in the graph\nL &lt;- sum( bipartite_example )\n\n# identify the number of actors in the example\nN &lt;- dim( bipartite_example )[1]\n\n# identify the number of events in the example\nM &lt;- dim( bipartite_example )[2]\n\n# calculate the density\ndensity_bipartite_example &lt;- L / ( N * M )\n\n# check it out\ndensity_bipartite_example\n\n[1] 0.4\n\n\nWhat is the interpretation of the density?\n\n\nDegree Centrality\nFor a bipartite graph there are two degree distributions:\n\nThe distribution of ties in the first mode\nThe distribution of ties in the second mode\n\nWe can calculate the degree centrality scores for each node in each corresponding vertex set by taking the row sum for N nodes in the first mode and taking the column sum for M nodes in the second mode. We can do so using the rowSums() and colSums() functions, respectively.\n\n# raw scores for actors\nactor_deg &lt;- rowSums( bipartite_example )\nactor_deg\n\nA B C D E F \n2 1 2 4 1 2 \n\n# raw scores for events\nevent_deg &lt;- colSums( bipartite_example )\nevent_deg\n\n1 2 3 4 5 \n3 3 3 1 2 \n\n\nHow should we interpret the centrality scores for each node set? Well, it is a bit difficult when just looking at it here. So, we can calculate a summary statistic, such as the mean, to evaluate the distribution of centrality scores for each node set.\n\nMean Degree Centrality\nAs before, we could examine the central tendency by examining the mean degree for each node/vertex set. We take the sum of the edges, \\(L\\) and:\n\nfor the first node set we divide by \\(\\frac{L}{N}\\), the number of nodes in that set.\nfor the second node set we divide by \\(\\frac{L}{M}\\), the number of nodes in that set.\n\n\n# mean degree for actors\nmean_actor_deg &lt;- L / N\n\n# mean degree for events\nmean_event_deg &lt;- L / M\n\n# an alternative is to just use the mean() function with the degree data\nmean( actor_deg )\n\n[1] 2\n\nmean( event_deg )\n\n[1] 2.4\n\n\nHow should we interpret the mean centrality score for each node set? The mean for the actor node set indicates that, on average, each node has 2 ties. The mean for the event node set indicates that, on average, each event has 2.4 ties.\n\n\nStandardized Degree Centrality\nDegree centrality scores for each node/vertex set not only reflects each node’s connectivity to nodes in the other set, but also depend on the size of that set. As a result, larger networks will have a higher maximum possible degree centrality value. Solution?\nStandardize!!!\nAs we saw for unipartite graphs, we can adjust the raw degree centrality scores by taking into account the size of the graph. In a bipartite graph, we can standardize, or normalize, by dividing the raw centrality scores by the number of nodes in the opposite vertex set. That is, for the centrality scores in the first mode we divide by M and for the centrality scores in the second mode we divide by N.\n\n# standardized score for actors\nactor_deg / M\n\n  A   B   C   D   E   F \n0.4 0.2 0.4 0.8 0.2 0.4 \n\n# standardized score for events\nevent_deg / N\n\n        1         2         3         4         5 \n0.5000000 0.5000000 0.5000000 0.1666667 0.3333333 \n\n\nIn networks with lots of nodes, this information might be useful for visualizing differences in nodes degree centrality. Let’s create a plot with the standardized scores where larger degree centrality influences the size of the nodes. As we did above, we will want to create a single object that has these sizes. We can do this using the c() function.\n\n# define the standardized scores for actors\nactor_size &lt;- actor_deg / M\n\n# define the standardized scores for events\nevent_size &lt;- event_deg / N\n\n# combine these to use in the plot\nv_size &lt;- c( actor_size, event_size )\n\n# set the seed to reproduce the plot layout\nset.seed( 507 )\n\n# execute the plot\ngplot(\n  bipartite_example_net,                                  # our network to plot\n  label = network.vertex.names( bipartite_example_net ),  # the labels we want\n  gmode = \"twomode\",                                      # indicate it is two modes\n  usearrows = FALSE,                                      # turn off the arrowheads\n  label.cex = 1.2,                                        # size the labels\n  main = \"Bipartite Graph of Example Graph\",              # add a title\n  vertex.col = node_col,                                  # add the colors\n  \n  # here is the addition to what we had above:\n  vertex.cex = v_size + 0.5                               # set the size (add 0.5 so it is not too small) \n)",
    "crumbs": [
      "Bipartite Graphs & Two-Mode Networks"
    ]
  },
  {
    "objectID": "snaca-r-bipartite.html#structural-properties-of-young-ready-2015-police-officer-network",
    "href": "snaca-r-bipartite.html#structural-properties-of-young-ready-2015-police-officer-network",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Structural Properties of Young & Ready (2015) Police Officer Network",
    "text": "Structural Properties of Young & Ready (2015) Police Officer Network\nNow, let’s work with a real example. As discussed in the Bipartite Graphs & Two-Mode Networks chapter, Young and Ready (2015) examined how police officers develop cognitive frames about the usefulness of body-worn cameras. They argued that police officers’ views of body-worn cameras influence whether they use their cameras in incidents and that these views partly result from sharing incidents with other officers where they exchanged views about the legitimacy of body-worn cameras.\nThis network is available in SNACpack under the name officer_event_net. We can type the name of the network to see it’s properties:\n\n# load SNACpack \n\nlibrary( SNACpack )\n\n\n# print out the network\n\nofficer_event_net\n\n Network attributes:\n  vertices = 234 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = 81 \n  total edges= 346 \n    missing edges= 0 \n    non-missing edges= 346 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nIf you inspect the output, you will see that there are 81 officers (the N dimension of the sociomatrix) and 153 events (the M dimension of the sociomatrix).\n\nPlotting the Network\nNow, let’s create a plot of the network. To aid in visualization, we need to create a variable indicating whether the officer was in the treatment (i.e. received a body-cam) or control group. If you look at the network.vertex.names( officer_event_net ) object, you will see that the officer ids start with “C” or “T”:\n\nnetwork.vertex.names( officer_event_net )\n\n  [1] \"C1223\"       \"C1224\"       \"C1225\"       \"C1226\"       \"C1227\"      \n  [6] \"C1228\"       \"C1229\"       \"C1230\"       \"C1231\"       \"C1232\"      \n [11] \"C1234\"       \"C1235\"       \"C1237\"       \"C1238\"       \"C1239\"      \n [16] \"C1240\"       \"C1241\"       \"C1242\"       \"C1243\"       \"C1245\"      \n [21] \"C1247\"       \"C1248\"       \"C1249\"       \"C1250\"       \"C1251\"      \n [26] \"C1252\"       \"C1253\"       \"C1254\"       \"C1255\"       \"C1256\"      \n [31] \"C1257\"       \"C1258\"       \"C1259\"       \"C1260\"       \"C1261\"      \n [36] \"C1262\"       \"C1263\"       \"C1264\"       \"C1265\"       \"C1266\"      \n [41] \"C1268\"       \"C1269\"       \"C1270\"       \"C1271\"       \"T1223\"      \n [46] \"T1224\"       \"T1225\"       \"T1226\"       \"T1227\"       \"T1228\"      \n [51] \"T1229\"       \"T1231\"       \"T1232\"       \"T1236\"       \"T1237\"      \n [56] \"T1238\"       \"T1239\"       \"T1240\"       \"T1242\"       \"T1243\"      \n [61] \"T1245\"       \"T1247\"       \"T1248\"       \"T1249\"       \"T1251\"      \n [66] \"T1252\"       \"T1253\"       \"T1255\"       \"T1256\"       \"T1259\"      \n [71] \"T1260\"       \"T1261\"       \"T1262\"       \"T1264\"       \"T1265\"      \n [76] \"T1270\"       \"T1273\"       \"T1275\"       \"T1276\"       \"T1277\"      \n [81] \"T1278\"       \"12272012_16\" \"02102013_9\"  \"02102013_10\" \"02102013_8\" \n [86] \"02102013_7\"  \"12272012_7\"  \"12272012_5\"  \"12272012_6\"  \"12272012_4\" \n [91] \"12272012_3\"  \"12272012_1\"  \"12262012_5\"  \"12272012_2\"  \"12272012_18\"\n [96] \"02072013_17\" \"12292012_6\"  \"12292012_7\"  \"12292012_4\"  \"12292012_5\" \n[101] \"02092013_5\"  \"12292012_17\" \"12292012_23\" \"12272012_17\" \"12282012_1\" \n[106] \"02092013_2\"  \"02092013_3\"  \"02092013_26\" \"06122013_1\"  \"01012013_2\" \n[111] \"01012013_3\"  \"01012013_1\"  \"12302012_7\"  \"12292012_26\" \"12302012_8\" \n[116] \"12302012_9\"  \"12302012_2\"  \"12292012_24\" \"12282012_2\"  \"02092013_6\" \n[121] \"12312012_2\"  \"12312012_3\"  \"02072013_1\"  \"02072013_3\"  \"02072013_4\" \n[126] \"12292012_18\" \"12292012_20\" \"02092013_22\" \"12292012_21\" \"02092013_23\"\n[131] \"02092013_25\" \"02092013_15\" \"02092013_21\" \"12292012_19\" \"12292012_22\"\n[136] \"02092013_18\" \"12292012_15\" \"12292012_16\" \"02092013_14\" \"02092013_19\"\n[141] \"02092013_17\" \"02082013_2\"  \"12292012_3\"  \"12282012_3\"  \"12312012_1\" \n[146] \"12302012_21\" \"02112013_3\"  \"02102013_11\" \"02112013_1\"  \"12302012_11\"\n[151] \"12302012_10\" \"01012013_4\"  \"02092013_8\"  \"02092013_10\" \"12292012_13\"\n[156] \"12292012_14\" \"12292012_12\" \"02092013_13\" \"12292012_10\" \"12292012_11\"\n[161] \"12292012_9\"  \"02092013_7\"  \"02092013_9\"  \"02162013_1\"  \"02092013_20\"\n[166] \"02092013_16\" \"02092013_11\" \"02092013_12\" \"12302012_3\"  \"12302012_6\" \n[171] \"12302012_5\"  \"12292012_25\" \"12302012_4\"  \"02092013_24\" \"12292012_8\" \n[176] \"12262012_3\"  \"12262012_2\"  \"12262012_1\"  \"02062013_5\"  \"02062013_3\" \n[181] \"12272012_10\" \"12272012_8\"  \"12302012_14\" \"12302012_12\" \"12302012_16\"\n[186] \"12302012_13\" \"12312012_5\"  \"12312012_4\"  \"02072013_7\"  \"02072013_5\" \n[191] \"02072013_16\" \"02072013_10\" \"12272012_11\" \"02072013_13\" \"02072013_9\" \n[196] \"12272012_15\" \"02072013_8\"  \"12272012_12\" \"02072013_15\" \"02072013_11\"\n[201] \"02072013_2\"  \"02072013_6\"  \"02062013_4\"  \"12302012_19\" \"12302012_17\"\n[206] \"02102013_3\"  \"02102013_6\"  \"12292012_27\" \"02102013_2\"  \"02102013_5\" \n[211] \"02102013_1\"  \"12292012_1\"  \"12302012_1\"  \"12292012_28\" \"02102013_4\" \n[216] \"02082013_1\"  \"12312012_6\"  \"12302012_18\" \"12302012_20\" \"02232013_1\" \n[221] \"12292012_2\"  \"02092013_4\"  \"02092013_1\"  \"02062013_1\"  \"12262012_4\" \n[226] \"02072013_14\" \"12272012_9\"  \"02072013_12\" \"02062013_2\"  \"12302012_15\"\n[231] \"12272012_14\" \"12272012_13\" \"02112013_2\"  \"02252013_1\" \n\n\nThe first 81 elements are officers. For the officer ids, the “C” prefix indicates a control officer and a “T” prefix indicates a treatment officer. The first 44 ids are for control officers and the subsequent 37 ids are for treatment officers. The remaining 153 correspond to events. We can use this info to create a variable that indicates treatment status.\nWe will use this information to create an attribute. To do so, we will use the rep() function which repeats a sequence of numbers of characters.\n\n# create a variable using the information in the ids\nstatus &lt;- c( \n  rep( \"Control\", 44 ),   # repeat \"Control\" 44 times because there are 44 control officers\n  rep( \"Treatment\", 37 ), # repeat \"Treatment\" 37 times because there are 37 control officers\n  rep( \"Incident\", 153 )     # repeat \"Incident\" 153 times because there are 153 incident\n  )\n\n# create colors for the plot\nvcol &lt;- status\nvcol[ status == \"Control\" ]   &lt;- \"green\" # make controls green\nvcol[ status == \"Treatment\" ] &lt;- \"red\"   # make treatment group red\nvcol[ status == \"Incident\" ]  &lt;- \"white\" # make events white\n\n# create the shapes\nvsides &lt;- rep( 0, length( status ) )\nvsides[ status == \"Control\" ]   &lt;- 3  # make controls triangles\nvsides[ status == \"Treatment\" ] &lt;- 4  # make treatment group squares\nvsides[ status == \"Incident\" ]  &lt;- 50 # make events circles\n\n# create the node sizes\nnsize &lt;- c(\n  rep( 2,   81 ), # sizes for officers\n  rep( 1.2, 153 )  # size for the events\n  ) \n\nNow, we can plot this using the gplot() function.\n\n# adjust the margins to cut some white space\npar( mar=c( 0, 0, 2, 0 ) )\n\n# set the seed for the plot\nset.seed( 507 )\n\n# plot it\ngplot(\n  officer_event_net,\n  gmode=\"twomode\",\n  usearrows=FALSE,\n  displayisolates=FALSE,\n    vertex.col=vcol,\n    vertex.sides=vsides,\n    edge.col=\"grey60\",\n    edge.lwd=1.2,\n    vertex.cex = nsize,\n  main = \"Plot of Officers and Events\"\n)\n\n\n\n\n\n\n\n\n\n\nStructural Properties of the Network\nNow, let’s take a look at several properties of the graph: density, degree centrality, and mean degree centrality.\n\nDensity\nRemember, the density is the total number of edges divided by N x M.\n\n# coerce to a matrix for ease of working with the object\nofficer_event_mat &lt;- as.matrix( officer_event_net )\n\n# create the N and M objects\nN &lt;- dim( officer_event_mat )[1]\nM &lt;- dim( officer_event_mat )[2]\n\n# identify the number of edges in the graph\nL &lt;- sum( officer_event_mat )\n\nL / ( N * M )\n\n[1] 0.02791899\n\n\nThe density for the this network is 0.03. What is the interpretation of the density for this network?\n\n\nDegree\nNow, let’s take a look at the degree distributions.\n\n# raw scores for officers\nofficer_deg &lt;- rowSums( officer_event_mat )\n\n# raw scores for incidents\nincident_deg &lt;- colSums( officer_event_mat )\n\n\n\nMean Degree Centrality\nNow, we can examine the central tendency by examining the mean degree for each node/vertex set. We take the sum of the edges, \\(L\\) and:\n\nfor the first node set we divide by \\(\\frac{L}{N}\\), the number of nodes in that set.\nfor the second node set we divide by \\(\\frac{L}{M}\\), the number of nodes in that set.\n\n\n# mean degree for officers\nmean_officer_deg &lt;- L / N\nmean_officer_deg\n\n[1] 4.271605\n\n# mean degree for incidents\nmean_incident_deg &lt;- L / M\nmean_incident_deg\n\n[1] 2.261438\n\n# an alternative is to just use the mean() function with the degree data\nmean( mean_officer_deg )\n\n[1] 4.271605\n\nmean( mean_incident_deg )\n\n[1] 2.261438\n\n\nWhat is the interpretation of the mean degree for each node set?",
    "crumbs": [
      "Bipartite Graphs & Two-Mode Networks"
    ]
  },
  {
    "objectID": "snaca-r-bipartite.html#test-your-knowledge-exercises",
    "href": "snaca-r-bipartite.html#test-your-knowledge-exercises",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nExplain the difference between bipartite graphs and unipartite graphs. Provide examples of contexts where each might be used.\nWhat is the purpose of the bipartite argument in the as.network() function? How does it relate to the dimensions of the adjacency matrix?\nDescribe the role of the gmode argument in the gplot() function. What happens when it is set to \"twomode\"?\nHow would you create a set of colors for the nodes in a bipartite graph, ensuring that actor nodes and event nodes have different colors? Write the R code to demonstrate this.\nHow do you compute the degree centrality for actor nodes and event nodes in a bipartite graph? Provide the R code to do this.\nInterpret the mean degree centrality for the officer and incident nodes in the police officer network. What do these values tell you about the structure of the network?\nWhen visualizing a bipartite graph, why is it important to ensure that node attributes (e.g., color, size) are correctly ordered? What steps would you take to ensure this in R?\nCreate a plot of a bipartite graph where node sizes reflect their standardized degree centrality and node colors differentiate between actors and events.\nWhy is it important to examine both the raw and mean degree centrality scores when analyzing bipartite graphs? What insights can each provide?",
    "crumbs": [
      "Bipartite Graphs & Two-Mode Networks"
    ]
  },
  {
    "objectID": "snaca-r-bipartite.html#tutorial-summary",
    "href": "snaca-r-bipartite.html#tutorial-summary",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial explored bipartite graphs, or two-mode networks, as a foundational tool for representing relationships between two distinct node sets, such as individuals and events. Crime analysts often work with these graph structures, so we learned in this tutorial how to construct these networks through adjacency matrices, transform them into network objects, and visualize them using the gplot() function from the sna package. We also reviewed several properties of these networks, such as calculating network density and degree centrality.\n\n\n\n\nYoung, Jacob T. N., and Justin T. Ready. 2015. “Diffusion of Ideas and Technology: The Role of Networks in Influencing the Endorsement and Use of on-Officer Video Cameras.” Journal of Contemporary Criminal Justice 31 (3): 243–61. https://doi.org/10.1177/1043986214553380.",
    "crumbs": [
      "Bipartite Graphs & Two-Mode Networks"
    ]
  },
  {
    "objectID": "snaca-r-projection.html",
    "href": "snaca-r-projection.html",
    "title": "Projection & Weighted Graphs",
    "section": "",
    "text": "One-Mode Networks by Projection\nAs discussed in the Bipartite Graphs & Two-Mode Networks chapter of the textbook, bipartite graphs are useful for operationalizing contexts where nodes come from two separate classes. In contrast to one-mode networks, or unipartite graphs, where edges can be incident within a particular node/vertex set, in two-mode or bipartite graphs there are two partitions of nodes (called modes), and edges only occur between these partitions (i.e. not within).\nThen, in the Projection chapter, we saw that projection is the process by which we map the connectivity between modes to a single mode. And, we saw that we can use a weighted graph or a binarized graph in the analysis of the project.\nIn this tutorial, we will review how a unipartite or one-mode network can be created through projection.\nFollowing Breiger (1974), we can build the adjacency matrix for each projected network through matrix algebra. Specifically, multiplying an adjacency matrix by it’s transpose. The transpose of a matrix A simply reverses the columns and rows: \\(\\sf{A^T_{ij}}\\) = \\(\\sf{A_{ji}}\\).\nThe two-mode, NxM, adjacency matrix, when multiplied by it’s transpose, produces either:\nTo examine how this works, let’s first set up an example:\n# create an example matrix\nA &lt;- rbind(\n  c( 1,1,0,0,0 ),\n  c( 1,0,0,0,0 ),\n  c( 1,1,0,0,0 ),\n  c( 0,1,1,1,1 ),\n  c( 0,0,1,0,0 ),\n  c( 0,0,1,0,1 )\n  )\n\n# name the rows and columns \nrownames( A ) &lt;- c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\" )\ncolnames( A ) &lt;- c( \"1\",\"2\",\"3\",\"4\",\"5\" )\n\n# print out the matrix\nA\n\n  1 2 3 4 5\nA 1 1 0 0 0\nB 1 0 0 0 0\nC 1 1 0 0 0\nD 0 1 1 1 1\nE 0 0 1 0 0\nF 0 0 1 0 1",
    "crumbs": [
      "Projection & Weighted Graphs"
    ]
  },
  {
    "objectID": "snaca-r-projection.html#one-mode-networks-by-projection",
    "href": "snaca-r-projection.html#one-mode-networks-by-projection",
    "title": "Projection & Weighted Graphs",
    "section": "",
    "text": "An NxN matrix (ties among N nodes via M)\nAn MxM matrix (ties among M nodes via N)\n\n\n\n\nTransposition\nIn R, the t() function, or transpose() returns the transposition of a matrix. To see the help on the transpose() function, just use ?t to pull up the help page.\n\n# print the transpose of our example\nt( A )\n\n  A B C D E F\n1 1 1 1 0 0 0\n2 1 0 1 1 0 0\n3 0 0 0 1 1 1\n4 0 0 0 1 0 0\n5 0 0 0 1 0 1\n\n\nWhat is different? Compare the difference between A and t( A ).\n\nMatrix Multiplication in R\nTo create the project, we need to use matrix algebra. To multiply matrices in R, we have to use the following operator: %*%. This is different then * in that %*% tells R to use matrix multiplication. For example, compare the differences:\n\n# create two matrices\na &lt;- matrix( c(1,1,1,1), nrow=2, byrow=TRUE )\nb &lt;- matrix( c(2,2,2,2), nrow=2, byrow=TRUE )\n\n# multiply the first element in a by the first element in b\na * b\n\n     [,1] [,2]\n[1,]    2    2\n[2,]    2    2\n\n# multiply the matrix a by the matrix b\na %*% b\n\n     [,1] [,2]\n[1,]    4    4\n[2,]    4    4\n\n\nWhat is the difference? When we use a * b, it is not using matrix multiplication.\nTo multiply two matrices, the number of columns in the first matrix must match the number of rows in the second matrix. This is called conformability. Only matrices with conformable dimensions can be multiplied. For example, 5x6 X 6x5 works, but not 5x6 X 5x6. When two matrices are multiplied by each other, this renders the product matrix. The product matrix has the number of rows equal to the first matrix and the number of columns equal to the second matrix.\nRecall that from the two-mode, NxM, adjacency matrix, we can produce two different matrices:\n\nAn NxN matrix (ties among N nodes via M)\n\nThis is created by using NxM X t(NxM), or NxM X MxN\n\nAn MxM matrix (ties among M nodes via N)\n\nThis is created by using t(NxM) X NxM, or MxN X NxM\n\n\nLet’s create each of these with our example network.\n\n# create the NxN matrix\nA %*% t( A )\n\n  A B C D E F\nA 2 1 2 1 0 0\nB 1 1 1 0 0 0\nC 2 1 2 1 0 0\nD 1 0 1 4 1 2\nE 0 0 0 1 1 1\nF 0 0 0 2 1 2\n\n# create the MxM matrix\nt( A ) %*% A\n\n  1 2 3 4 5\n1 3 2 0 0 0\n2 2 3 1 1 1\n3 0 1 3 1 2\n4 0 1 1 1 1\n5 0 1 2 1 2",
    "crumbs": [
      "Projection & Weighted Graphs"
    ]
  },
  {
    "objectID": "snaca-r-projection.html#projections",
    "href": "snaca-r-projection.html#projections",
    "title": "Projection & Weighted Graphs",
    "section": "Projections",
    "text": "Projections\n\nThe Person Matrix\nOk, so we have created the projections, which are the one-mode networks that represent information in the two-mode networks. Recall from the Projection chapter that Breiger (1974) referred to the person matrix (i.e. the NxN matrix) and the group matrix (i.e. the MxM matrix).\n\n# create the \"person\" matrix: recall this is A X t(A)\nP &lt;- A %*% t( A )\n\nP\n\n  A B C D E F\nA 2 1 2 1 0 0\nB 1 1 1 0 0 0\nC 2 1 2 1 0 0\nD 1 0 1 4 1 2\nE 0 0 0 1 1 1\nF 0 0 0 2 1 2\n\n\nWhat does the diagonal represent in this matrix? What do the off-diagonal elements represent?\nThe diagonal elements represent the number of nodes in the second mode of the bipartite graph to which a node is connected. Put differently, if we have a two-mode network where one set of nodes are individuals and the other set of nodes are events, then the diagonal of the projection for the “person” matrix represents the number of events that an individual attended.\nThe off-diagonal elements represent the ties between nodes in the same node set of the bipartite graph. That is, ties between individuals.\nTo visualize this by plotting each network, then we can better see what is happening. We will use the gplot() function, so be sure to call the sna package library.\n\n# call the library\nlibrary( sna )\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 1, 2 ),\n  mar = c( 0, 1, 4, 1)\n  )\n\n# set the seed to reproduce the plot\nset.seed( 507 )\n\n# plot the bipartite network\ngplot( A,\n       gmode = \"twomode\",\n       main = NA,\n       usearrows = FALSE,\n       label = c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\", \"1\",\"2\",\"3\",\"4\",\"5\" ),\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = c(                   # create a vector of colors\n         rep( \"#fa6e7a\", dim( A )[1] ),  # the first color is the number of nodes in the first mode\n         rep( \"#00aaff\", dim( A )[2] ) ) # the second color is the number of nodes in the second mode\n       )\ntitle( \"Bipartite Matrix\", line = 1 )\n\n# plot the person matrix\ngplot( P,\n       gmode = \"graph\",\n       label = c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\" ),\n       main = NA,\n       usearrows = FALSE,\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = \"#fa6e7a\",\n       vertex.sides = 99.      # set the shapes to be circles\n       )\ntitle( \"Unipartite Projection of\\n Person Matrix\", line = -1 )\n\n\n\n\n\n\n\n\nFrom the plots we can see what the projection is doing. It is creating a unipartite graph based on the ties in the bipartite graph. For example, consider nodes A, B, and C. In the bipartite graph, B, is connected to A and C through node 1. We see this in the unipartite graph where A, B, and C are connected. In other words, we have taken the links between A, B, and C in the bipartite graph and reproduced them in a unipartite graph.\n\n\nThe Group Matrix\nNow, let’s take a look at the “group” matrix. The projection for the “group” matrix has a different interpretation. Let’s work through this to see it.\n\n# create the \"group\" matrix: recall this is t(A) X A\nG &lt;- t( A ) %*% A\n\nG\n\n  1 2 3 4 5\n1 3 2 0 0 0\n2 2 3 1 1 1\n3 0 1 3 1 2\n4 0 1 1 1 1\n5 0 1 2 1 2\n\n\nWhat does the diagonal represent in this matrix? What do the off-diagonal elements represent?\nThe diagonal elements represent the number of nodes in the first mode of the bipartite graph to which a node is connected. If we have a two-mode network where one set of nodes are individuals and the other set of nodes are events, then the diagonal of the projection for the “group” matrix represents the number of individuals that attend an event. The off-diagonal elements represent the ties between events. Essentially, how events are connected by people attending them. Let’s plot this to see it.\n\n# call the library\nlibrary( sna )\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 1, 2 ),\n  mar = c( 0, 1, 4, 1)\n  )\n\n# set the seed to reproduce the plot\nset.seed( 507 )\n\n# plot the bipartite network\ngplot( A,\n       gmode = \"twomode\",\n       main = NA,\n       usearrows = FALSE,\n       label = c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\", \"1\",\"2\",\"3\",\"4\",\"5\" ),\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = c( \n         rep( \"#fa6e7a\", dim( A )[1] ), \n         rep( \"#00aaff\", dim( A )[2] ) )\n       )\ntitle( \"Bipartite Matrix\", line = 1 )\n\n# plot the person matrix\ngplot( G,\n       gmode = \"graph\",\n       label = c( \"1\",\"2\",\"3\",\"4\",\"5\" ),\n       main = NA,\n       usearrows = FALSE,\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = \"#00aaff\",\n       vertex.sides = 4        # set the shape to be a square\n       )\ntitle( \"Unipartite Projection of\\n Group Matrix\", line = -1 )\n\n\n\n\n\n\n\n\nFrom the plots we can see what the projection is doing. It is creating a unipartite graph based on the ties in the bipartite graph, but this time it is for the other node set. For example, consider nodes 1, 2, and 3. In the bipartite graph, 1, is connected to 2 through node A and C. Node 2 and 3 are connected through node D. We see this in the unipartite graph where 1 is connected to 2 and 2 is connected to 3. In other words, we have taken the links between 1, 2, and 3 in the bipartite graph and reproduced them in a unipartite graph.",
    "crumbs": [
      "Projection & Weighted Graphs"
    ]
  },
  {
    "objectID": "snaca-r-projection.html#projecting-young-readys-2015-police-officer-network",
    "href": "snaca-r-projection.html#projecting-young-readys-2015-police-officer-network",
    "title": "Projection & Weighted Graphs",
    "section": "Projecting Young & Ready’s (2015) Police Officer Network",
    "text": "Projecting Young & Ready’s (2015) Police Officer Network\nNow, let’s work with a real example. As discussed in the Bipartite Graphs & Two-Mode Networks chapter, Young and Ready (2015) examined how police officers develop cognitive frames about the usefulness of body-worn cameras. They argued that police officers’ views of body-worn cameras influence whether they use their cameras in incidents and that these views partly result from sharing incidents with other officers where they exchanged views about the legitimacy of body-worn cameras.\nhis network is available in SNACpack under the name officer_event_net. We can type the name of the network to see it’s properties:\n\n# load SNACpack \n\nlibrary( SNACpack )\n\n\n# print out the network\n\nofficer_event_net\n\n Network attributes:\n  vertices = 234 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = 81 \n  total edges= 346 \n    missing edges= 0 \n    non-missing edges= 346 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nThe officer_event_net object is stored as one of class network. Let’s coerce it to a matrix to make it easier to handle:\n\nofficer_event_mat &lt;- as.matrix( officer_event_net )\n\nWe can check the dimensions of the matrix using the dim() function. The officer_event_mat matrix has 81 rows and 153 columns. Recall that this is police officers and incidents, so there are 81 police officers and 153 incidents that connect officers.\n\n# identify the number of police officers\nN &lt;- dim( officer_event_mat )[1]\n\n# identify the number of incidents\nM &lt;- dim( officer_event_mat )[2]\n\n\nCreate the Projections\nNow that we have it put together, let’s create the projections. To do this, we just need to employ matrix multiplication on the officer_event_mat matrix.\n\n# create the \"person\" matrix\nofficer_event_mat_P &lt;- officer_event_mat %*% t( officer_event_mat )\n\n# create the \"group\" matrix\nofficer_event_mat_G &lt;- t( officer_event_mat ) %*% officer_event_mat\n\nNow, let’s plot the networks!\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 2, 2 ),\n  mar = c( 2, 1, 4, 1)\n  )\n\n# set the seed to reproduce the plot\nset.seed( 507 )\n\n# plot the bipartite network\ngplot( officer_event_mat,\n       gmode=\"twomode\",\n       usearrows=FALSE,\n       edge.col=\"grey60\",\n       vertex.col = c( \n         rep( \"#34e5eb\", dim( officer_event_mat )[1] ), \n         rep( \"#4f0a1a\", dim( officer_event_mat )[2] ) ),\n       edge.lwd=1.2\n       )\ntitle( \"Bipartite Matrix of Officers and Incidents\", line = 1 )\n\n# plot the person matrix\ngplot( officer_event_mat_P,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col=\"grey60\",\n       edge.lwd=1.2,\n       vertex.col = \"#34e5eb\"\n       )\ntitle( \"Unipartite Projection of\\n Officers (Person) Matrix\", line = 1 )\n\n# plot the group matrix\ngplot( officer_event_mat_G,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col=\"grey60\",\n       edge.lwd=1.2,\n       vertex.col = \"#4f0a1a\",\n       vertex.sides = 4\n       )\ntitle( \"Unipartite Projection of\\n Incidents (Group) Matrix\", line = 1 )\n\n\n\n\n\n\n\n\nNow that we have reduced our bipartite graph to a unipartite graph, we can employ the same descriptive tools we have previously used.\n\n\nUsing the Weights in the Plot\nNote that when we create the projection, the matrix is actually a weighted matrix. We saw this in the Projection chapter. We can use this information in our plot. That is, we can use the weighted matrix to shade the edges (darker are larger weights) and size the edges (where larger are bigger weights). To see how this works, let’s build a few functions.\n\nThe edge_rescale() and edge_shade() functions for incorporating edge weights\nAs we have seen in prior tutorials, the vertex_rescale() function can be used to rescale the size of the nodes in a plot based on an attribute. We can do the same thing for edge values. That is, we can make edges that have larger values in the projection to be thicker and darker and smaller values to be thinner and lighter. This helps us better visualize the weights assigned to the edges. In SNACpack, there are two functions that do just that: edge_rescale() and edge_shade. (Use ?edge_rescale and ?edge_shade to see more about the function in the help file).\nNow, let’s plot the networks with the edges adjusted. We will plot the bipartite graph, the officer network, and the officer network with the shading.\n\n# set the plot regions to ease with visualization\n\npar( \n  mfrow = c( 1, 3 ),\n  mar = c( 2, 1, 5, 1)\n  )\n\n\n# plot the bipartite network\n\ngplot( officer_event_mat,\n       gmode=\"twomode\",\n       usearrows=FALSE,\n       edge.col=\"grey60\",\n       vertex.col = c( \n         rep( \"#34e5eb\", dim( officer_event_mat )[1] ), \n         rep( \"#4f0a1a\", dim( officer_event_mat )[2] ) ),\n       edge.lwd=1.2\n       )\n\ntitle( \"Bipartite Matrix of Officers and Incidents\", line = 1 )\n\n\n# plot the person matrix\n\nset.seed( 507 )\n\ngplot( officer_event_mat_P,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       vertex.col = \"#34e5eb\"\n       )\n\ntitle( \"Unipartite Projection of\\n Officers (Person) Matrix\\n (no shading)\", line = 1 )\n\n\n# plot the person matrix\n\nset.seed( 507 )\n\ngplot( officer_event_mat_P,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col = edge_shade( officer_event_mat_P ),           # note the usage here\n       edge.lwd = edge_rescale( officer_event_mat_P, 0.1, 5 ), # note the usage here\n       vertex.col = \"#34e5eb\"\n       )\n\ntitle( \"Unipartite Projection of\\n Officers (Person) Matrix\", line = 1 )\n\n\n\n\n\n\n\n\nNow, we will plot the bipartite graph, the incident network, and the incident network with the shading.\n\n# set the plot regions to ease with visualization\n\npar( \n  mfrow = c( 1, 3 ),\n  mar = c( 2, 1, 4, 1)\n  )\n\n\n# plot the bipartite network\n\ngplot( officer_event_mat,\n       gmode=\"twomode\",\n       usearrows=FALSE,\n       edge.col=\"grey60\",\n       vertex.col = c( \n         rep( \"#34e5eb\", dim( officer_event_mat )[1] ), \n         rep( \"#4f0a1a\", dim( officer_event_mat )[2] ) ),\n       edge.lwd=1.2\n       )\n\ntitle( \"Bipartite Matrix of Officers and Incidents\", line = 1 )\n\n\n# plot the group matrix\n\nset.seed( 507 )\n\ngplot( officer_event_mat_G,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       vertex.col = \"#4f0a1a\",\n       vertex.sides = 4\n       )\n\ntitle( \"Unipartite Projection of\\n Incidents (Group) Matrix\\n (no shading)\", line = 1 )\n\n\n# plot the group matrix\n\nset.seed( 507 )\n\ngplot( officer_event_mat_G,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col = edge_shade( officer_event_mat_G ),           # note the usage here\n       edge.lwd = edge_rescale( officer_event_mat_G, 0.1, 5 ), # note the usage here\n       vertex.col = \"#4f0a1a\",\n       vertex.sides = 4\n       )\n\ntitle( \"Unipartite Projection of\\n Incidents (Group) Matrix\", line = 1 )",
    "crumbs": [
      "Projection & Weighted Graphs"
    ]
  },
  {
    "objectID": "snaca-r-projection.html#test-your-knowledge-exercises",
    "href": "snaca-r-projection.html#test-your-knowledge-exercises",
    "title": "Projection & Weighted Graphs",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nExplain the process of projection in the context of bipartite graphs. Why is it useful for crime analysts?\nUsing R, describe the difference between the t() function and %*% operator. Provide an example illustrating their use.\nWhat are the conditions required for two matrices to be conformable for matrix multiplication? Why is this important when creating projections?\nCreate R code to generate the “person” matrix (NxN) and “group” matrix (MxM) from a given bipartite adjacency matrix. What do the diagonal and off-diagonal elements represent in each projection?\nWhat is the significance of the diagonal elements in the “person” matrix for crime analysts studying shared events?\nWrite R code to visualize the “group” matrix using the gplot() function. How would you ensure that event nodes have distinct shapes and colors?\nWhat are edge weights in a projection, and how can they be represented visually in R?\nDescribe how the edge_rescale() and edge_shade() functions created above work to adjust edge properties in a weighted graph. Why might this be helpful in a crime analysis context?\nWhy might a crime analyst choose to visualize both weighted and unweighted projections of a bipartite network? What insights can be gained from each?\nWhen plotting the unipartite projections, why is it important to use consistent colors and shapes for nodes? How does this enhance the interpretation of the graph?",
    "crumbs": [
      "Projection & Weighted Graphs"
    ]
  },
  {
    "objectID": "snaca-r-projection.html#tutorial-summary",
    "href": "snaca-r-projection.html#tutorial-summary",
    "title": "Projection & Weighted Graphs",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced crime analysts to the concept of projecting bipartite networks into unipartite networks, a critical technique for analyzing relational structures involving two distinct sets of nodes, such as people and events. We showed how analysts can create projections by multiplying an adjacency matrix with its transpose to generate either a “person” matrix, representing relationships between individuals, or a “group” matrix, representing connections between events. Visualization techniques using the gplot() function were demonstrated, showing how unipartite graphs are derived from bipartite structures and how weighted edges can be used to represent the strength of connections. Through these methods, crime analysts gained tools to investigate patterns of collaboration, shared events, and broader social structures, providing valuable perspectives for understanding crime and enforcement dynamics.\n\n\n\n\nBreiger, Ronald L. 1974. “The Duality of Persons and Groups.” Social Forces 53 (2): 181–90. https://doi.org/10.1093/sf/53.2.181.\n\n\nYoung, Jacob T. N., and Justin T. Ready. 2015. “Diffusion of Ideas and Technology: The Role of Networks in Influencing the Endorsement and Use of on-Officer Video Cameras.” Journal of Contemporary Criminal Justice 31 (3): 243–61. https://doi.org/10.1177/1043986214553380.",
    "crumbs": [
      "Projection & Weighted Graphs"
    ]
  },
  {
    "objectID": "snaca-r-conclusion.html",
    "href": "snaca-r-conclusion.html",
    "title": "Concluding Remarks",
    "section": "",
    "text": "Congratulations! You have made it all the way through the “Social Network Analysis for Crime Analysts using R” book! The goal of this book has been to equip you, the crime analyst, with the tools and knowledge to effectively apply social network analysis (SNA) using the R programming language. Throughout the tutorials, the book has emphasized practical application, guiding you through the process of conducting SNA in RStudio with real-world examples. Progressing through these topics, you have gained a comprehensive understanding of SNA techniques and how to implement them using R, ultimately enabling you to uncover critical insights within complex relational data. We did not cover everything there is in network analysis, but we covered most of it. My hope in writing this book is that it serves as a valuable resource for you as a crime analyst seeking to harness the power of social network analysis through R. And, that it has helped bridge the gap between theoretical concepts and practical application, providing the tools necessary to analyze and interpret complex networks within the realm of crime analysis. Good luck out there!",
    "crumbs": [
      "Concluding Remarks"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Breiger, Ronald L. 1974. “The Duality of Persons and\nGroups.” Social Forces 53 (2): 181–90. https://doi.org/10.1093/sf/53.2.181.\n\n\nCavallaro, L., A. Ficara, P. De Meo, G. Fiumara, S. Catanese, and O.\nBagdasar. 2020. “Disrupting Resilient Criminal Networks Through\nData Analysis: The Case of Sicilian Mafia.” PLOS ONE 15\n(8): e0236476. https://doi.org/10.1371/journal.pone.0236476.\n\n\nWasserman, Stanley, and Katherine Faust. 1994. Social Network\nAnalysis: Methods and Applications. Vol. 8. Structural Analysis in\nthe Social Sciences. Cambridge, UK: Cambridge University Press.\n\n\nYoung, Jacob T. N., and Justin T. Ready. 2015. “Diffusion of Ideas\nand Technology: The Role of Networks in Influencing the Endorsement and\nUse of on-Officer Video Cameras.” Journal of Contemporary\nCriminal Justice 31 (3): 243–61. https://doi.org/10.1177/1043986214553380.",
    "crumbs": [
      "References"
    ]
  }
]