[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Social Network Analysis for Crime Analysts using R",
    "section": "",
    "text": "Preface\nThe field of crime analysis is rapidly evolving, driven by advancements in technology and the growing availability of rich, complex data. Among the most pressing challenges for crime analysts is the need to make sense of these data, particularly when they involve relationships between individuals, groups, or organizations. Social network analysis (SNA) provides a powerful set of tools for mapping and understanding these connections, enabling analysts to uncover patterns, identify key players, and generate actionable insights. This book, Social Network Analysis for Crime Analysts using R, is designed to bridge the gap between theory and application, offering crime analysts a practical guide to using R, an open-source statistical programming language, and RStudio, an integrated development environment that provides a user-friendly interface for coding, data analysis, visualization, and report generation.\nWhy R and RStudio? RStudio is more than just software. It provide a robust ecosystem that empowers users to wrangle, visualize, and analyze data with precision and flexibility. For crime analysts, learning the R language and how to work in RStudio offers a significant advantage: they are free, widely supported by a global community, and capable of handling the types of network data that traditional tools struggle to process. With RStudio, analysts can customize workflows, automate repetitive tasks, and leverage advanced techniques such as clustering algorithms, centrality measures, and visualization methods: all essential for modern SNA. By working in RStudio, even those new to programming can gain the confidence to manipulate data and produce meaningful outputs. The ability to write reproducible code also ensures that analyses are transparent and can be revisited or adapted as cases evolve.\nThis book is written with the unique needs of crime analysts in mind. Using real-world examples and step-by-step instructions, it demonstrates how SNA can be conducted in Rstudio to solve practical problems, from identifying influential actors in a gang network to assessing the vulnerability of criminal enterprises. The focus is not only on teaching the mechanics of RStudio but also on fostering a deeper understanding of the concepts behind social network analysis. Whether you are new to network analysis or seeking to expand your analytic toolkit, this book will provide you with the skills and confidence to harness the power of RStudio and SNA in your work. Together, these tools can transform how crime analysts approach data, enabling them to uncover critical insights and ultimately contribute to safer communities.\nThis book is a companion to Social Network Analysis for Crime Analysts. It is organized as tutorials that show the “how to” of SNA in RStudio that correspond to conceptual chapters in the Social Network Analysis for Crime Analysts textbook.\nEach tutorial in this book will contain R code which is in “code chunks”. You will notice a code chunk because the font will change. Code chunks will have text that looks like this. There is also regular text. The R code chunks can be copied and pasted directly into R and RStudio. As you work through the tutorials, follow along in the software by coping and pasting the code and seeing it work on your end.\nLet’s get to it!"
  },
  {
    "objectID": "snaca-r-intro-to-r.html#things-about-r-to-get-you-started",
    "href": "snaca-r-intro-to-r.html#things-about-r-to-get-you-started",
    "title": "Getting Started with R",
    "section": "10 Things about R to get you started:",
    "text": "10 Things about R to get you started:\n\n1. What is R\nR is a dialect of the S language that was written by John Chambers and others at Bell tutorials in the 70s. In the 90s, R was developed and made avaitutorialle to the public with the GNU general public license. Importantly, R is free, meaning that you don’t have to pay for it (duh), but it is also open source, meaning that you have freedom to use and modify it.\nR is an operating system for data science software. Just as Windows allows you to turn on your computer, open a web browser, moved files around, and write a paper using MS Word, R allows you to install and run packages and manage files while organizing large data projects. Just like Windows would be a very boring piece of software without all of the applications you run while on the computer, R would be a boring language without all of the packages it can run.\n\n\n2. Installing and Starting\nGo to http://cran.r-project.org. Find the “Download R for…” link that is appropriate for your operating system.\nWhen R starts it loads some basic info and provides you with a prompt: &gt;\nThis prompt is the fundamental entry point for communicating with R. We type expressions at the prompt, R evaluates these expressions, and returns output.\n\n\n3. Objects in R\nR is a programming language. That means, it allows us to give instructions to our computer to do stuff. We will see that there is a lot of “stuff” we can do. But, the basic orientation to R is understanding objects.\nWhat is an object? Without getting to philosophical, an object is something we create in the R environment. Think of an R session as a box. We are creating objects and putting them into the box. This is quite different from data analysis programs like SPSS or Stata.\nWe create objects by using the assignment operator: &lt;-\nWhat you type on the right is assigned to what you type on the left. For example:\ny &lt;- 4 (we have assigned the value 4 to the object y)\nx &lt;- 6 (we have assigned the value 6 to the object x)\nz &lt;- y (we have assigned the value of the object y to the object z, i.e. z = 4)\nAfter assigning a value to an object, type the name of the object and hit return/enter to see what the value is.\nObjects can start with a letter or a period. But, you cannot name a object starting with a number (or other symbols used by R).\nSome examples:\nthe.number.two &lt;- 2\n2 &lt;- the.number.two\n2.the.number &lt;- 2\n;.2 &lt;- 2\nR is case sensitive (i.e. A is a different object than a). R is insensitive to white space though.\nThese two examples are treated the same in R:\nx &lt;- 2\nx&lt;-              2\nTo have R ignore text, use the # sign to make comments.\nFor example: x &lt;- 2 # this assigns the value 2 to object x.\nIn R there are no carriage returns (e.g. Stata uses /// in code). Sorry :("
  },
  {
    "objectID": "snaca-r-intro-to-r.html#functions-in-r",
    "href": "snaca-r-intro-to-r.html#functions-in-r",
    "title": "Getting Started with R",
    "section": "4. Functions in R",
    "text": "4. Functions in R\nA major strength of R is the ability to manipulate objects using functions. A function takes an argument (aka input) and returns some value (aka output).\nFor example, suppose we wanted to create a list of numbers, called a vector. We want to create an object that is defined by the list of numbers. In R, there is a preprogrammed function c(), which combines or concatenates values to create a single object. We can create an object x, that is a vector of 1, 2, 3, 4, and 5 using: x &lt;- c(1,2,3,4,5).\nThis reads: the object x is assigned the values 1, 2, 3, 4, and 5. The function is “c” and the argument is 1,2,3,4,5.\nThe number of values (aka elements) a vector contains is referred to as the “length”. We can use the length() function to return this information for us. For example: length(x) shows that the vector x has 5 values or elements.\nReminder: R is a language, so part of the learning curve is getting familiar with the names of functions."
  },
  {
    "objectID": "snaca-r-intro-to-r.html#referencing-and-indexing-objects-in-r",
    "href": "snaca-r-intro-to-r.html#referencing-and-indexing-objects-in-r",
    "title": "Getting Started with R",
    "section": "5. Referencing and Indexing Objects in R",
    "text": "5. Referencing and Indexing Objects in R\nIn R, specific elements in an object are referenced by using brackets (i.e. [ or ]).\nFor example, let’s create a vector and work with it:\n\nx &lt;- c( 1,2,3,4,5 ) # create the vector.\nx\nx[5] # what is the fifth element  in x?  \nx[2:4] # what are the second through fourth elements in x?  \nx[ c( 1,4 )] # what are the first and fourth elements in x?  \n\nNote the difference in use between [#:#] and [c(#,#)]. The colon : means “through” and the comma , means “and”.\nWe can also change values by indexing:\n\nx[5]   &lt;- 3 # change the fifth element in x to 5.  \nx[1:5] &lt;- 0 # change the first through fifth elements in x to 0.  \n\nUsing brackets to identify particular elements, called indexing, is VERY useful. By using indexing, we can create objects from other objects, or reference particular locations. The utility of this will be more obvious later.\n\n6. Types of objects (“classes”) in R\nObjects in R can be of different types or classes. There are four:\n\nnumeric, a number (e.g. 1, 2)\ncharacter, a letter or word (e.g. \"Shelley\", \"Trevor\")\nfactor, a category (e.g. female, male)\nlogical, True or False values (e.g. TRUE, FALSE)\n\nEach type of vector serves different purposes:\n\nnumeric: keep track of quantitative measures, counts, or orders of things\n\ncharacter: store non-numeric data, typically unstructured text\n\nfactor: represent distinct and mutually-exclusive categories\n\nlogical: designate cases that meet some criteria, usually group inclusion\n\nFor example, let’s build a few objects:\n\nnums &lt;- c( 1, 2, 3 )\nnames &lt;- c( \"Shelley\", \"Trevor\" )\nsex &lt;- factor( c( \"female\", \"male\" ) )\nis_female &lt;- sex == \"female\"\n\nNote that numbers do not require \" \" around them but characters do require \" \" around them. Also, that the object is.female is created by stating a condition.\nEach object has a class, which defines the “type” of vector a particular object is:\n\nname_list &lt;- c( \"Hugo\",\"Desmond\",\"Largo\" ) # assign the characters to an object.\nis.character( name_list ) # is the object a character vector?\nis.numeric( name_list ) #is the object a numeric vector?  \nis.factor( name_list ) # is the object a factor vector?\nis.logical( name_list ) # is the object a logical vector?\n\nMissing values are dealt with in R by NA.\n\ny &lt;- c( 3,NA,10 ) # create a vector with a missing value.\n2*y # multiple the vector by 2.  \nis.na( y ) # which positions in y have missing values?  \ny[ is.na( y )] #subset meeting condition.\ny[ !is.na( y )] # subset meeting a different condition.\n\n\n\n7. Matrices in R\nIn addition to vectors, we can create a matrix, which is a 2-dimensional representation of data. A matrix has dimensions r X c which means rows by columns. The number of rows and columns a matrix has is referred to as its “order” or “dimensionality”. This information is returned by using the dim() function. Matrices can be created by combining existing vectors using the rbind() and cbind() functions. The rbind() function means “row bind” and binds together vectors by rows. Think of it as stacking vectors on each other. The cbind() function means “column bind” and binds together vectors by rows. Think of it as placing them side by side. Let’s take a look:\n\nx  &lt;- c( 6,5,4,3,2 )\ny  &lt;- c( 8,7,5,3,1 )\nm1 &lt;- rbind( x,y ) #bind x and y by row to create a 2 X 5 matrix.\nm1 #just enter the name of the object to print it.\nm2 &lt;- cbind( x,y ) #bind x and y by column to create a 5 X 2 matrix.\nm2 #just enter the name of the object to print it.\n\nFor both functions, the dimensions of the vectors must be the same (i.e. same number of rows and columns).\nLet’s see some examples:\n\nl  &lt;- c( 6,5,4,3,2 )\nn  &lt;- c( 8,7,5 )\nm2 &lt;- rbind( l,n ) # returns an error because the dimensions differ.\n\nWe can index the matrix m1 or m2 by using the brackets [ ] with a comma between the two dimensions. Since a matrix is 2-dimensions, we can reference a specific element, an entire row, or an entire column:\n\nm1[2,2] #what is the value of the element in the 2nd row, 2nd column?\nm1[,2]  #what are the values in the second column?\nm1[2,]  #what are the values in the second row?\n\n\nm2[2,2] &lt;- 0 #change the value to zero.\nm2[2,]  &lt;- 0 #change the second row to zeros.\nm2[,2]  &lt;- 0 #change the second column to zeros.\n\nIn the code chunk above, note the difference between [,#] and [#,]. A comma in front of the argument (i.e. [,#]) applies to the columns) and a common after the argument (i.e. [#,]) applies to the rows.\nAlso, notice that m1[2,2], is an object, just as m1 is an object. In effect, we are subsetting the object m1 when we index it.\nMatrices can also be created from a list of numbers using the matrix() and c() functions.\n\nm3 &lt;- matrix( c( 1,0,1,0,0,1,0,1,0 ),nrow=3,ncol=3 )\nm3\n\n\n\n8. One of the most important functions in R: help()\nA useful feature of R is an extensive documentation of each of the functions. To access the main R help archive online, type: help.start()\nThe help() function, or a simple ?, can be used to get help about a specific function. For example: help(c) or ?c returns the help page for the c() function.\nTake a look at the help page. The first line shows you the function and the package it is written for in brackets (more on packages below). The help page provides a description, how to use it (i.e. what are the arguments), and a description of what each argument does. Further details and examples are provided as well.\nLet’s take a look at another function that creates sequences of numbers, the seq( ) function. There are several ways to use the seq( ) function. The most common are:\n\nseq( from=, to=, by= ) # Starts at from, ends at to, steps defined by by.\nseq( from=, to=, length= ) # Starts at from, ends at to, steps defined by length.  \n\nFor example:\nif we want to create an object of 5 values that starts with 1 and ends with 5, we type: seq( from=1, to=5, by=1 ).\nif we want to create an object of 5 values that starts with 1 and ends with 9, we type: seq( from=1, to=9, by=2 ).\nWe could also have used the length= argument: seq( from=1, to=10, length=5 ).\nSince R knows that from= or to= or by= or length= are arguments, we do not have to type them in the syntax: seq( 1, 9, 2 ) is identical to seq( from=1, to=9, by=2 ) (as far as R is concerned).\nFor the help function to work, you need to know the exact name of the function. If you don’t know this, but have a fuzzy idea of what it might be are what you want the function to do, you can use the help.search(\"fuzzy notion\") function (or just put ?? in front of the word).\nFor example, say you want to calculate the standard deviation for an object, but do not know the function name. Try: help.search( \"standarddeviation\" ) or ??standarddeviation (note the absence of a space). This returns the list of help topics that contain the phrase. We see that the standard deviation function is called sd().\n\n\n9. Packages and the install.packages() and library() Functions\nR has MANY preprogrammed functions that are automatically loaded when you open the program. Functions are stored in “packages”. Although there are many preprogrammed functions, there are even MORE functions that you can install on your own. A package in R is a collection of functions, usually written for a specific purpose.\nWe can see the packages available from CRAN at http://cran.r-project.org/. Just click on the “packages” link or go to https://cran.r-project.org/web/packages/index.html. As of writing this there are nearly 13,000 packages. There is a WIDE variety of packages available, this is another reason why R is awesome. If you can think it, someone has probably written a package for it in R (and if not, you can write one and contribute [isn’t it great!]).\nTake a few moments and look through the packages\nIf there is a particular package you want to add, you simply use the install.packages() function like this: install.packages(\"package name\").\nAfter the package is installed on your machine, you do not need to reinstall it each time you open a new session. Rather, you just need to load the package using the library() function like this: library(\"package name\").\nSome packages require other packages for them to work. If there is an error, you need to install the additional packages.\nNote that each time you open R you have to load any packages that you manually loaded using the install.packages() function. In other words, if we closed R and then reopened it, we would need to type library( \"ergm\" ) to load the functions in ergm. Note that we do not have to reinstall the package using install.packages(), we just have to load the library.\nIf you have installed the package, but have not loaded it, R will return an error saying that a particular function is not found.\nFor example, the function rgraph() in the package sna (which is a set of tools for working with social networks that we will use for this course) is used to create random graphs. Type ?rgraph and you get an error stating that there is no documentation avaitutorialle. This is because the sna library has not been loaded (even if you have installed sna). Typing install.packages( \"sna\" ) and library( sna ) prior to ?rgraph() will solve this problem.\nA final point on loading packages. Since anyone can write and contributes packages to R, it is not surprising that some packages occasionally use the same names for functions. When you have loaded libraries for packages that have conflicting functions, R will output a message indicating there is an issue.\nFor example, the sna package and the tnet package both have a function called betweenness, but the functions are programmed differently. When you load tnet after loading sna (or visa versa), R will give you a warning that an “object is being masked”. That means the functionality of betweenness in sna is no longer used. Let’s check it out:\n\ninstall.packages( \"sna\" )\nlibrary( sna )\ninstall.packages( \"tnet\" )\nlibrary( tnet )\n\nThis can be a bit frustrating. In such cases, you can unload the package using the detach() function. See: ?detach for an example.\n\n\n10. R Session Management\nAll variables created in R are stored in the “workspace”. Think of it as a work bench that has a bunch of stuff on it that you have created.\nTo see what exists in the workspace, type: ls().\nWe can remove specific variables with the rm() function. This helps clear up space (i.e. conserve memory). For example:\n\nx &lt;- seq( 1,5,1 ) # create the object.\nls()          # see the objects.\nrm( x )         # remove the object x.\nls()          # no more x.\n\nTo remove everything from the workspace use: rm( list=ls() ). This is helpful for starting a session to make sure everything is cleaned out.\nWhen you start R, it nominates one of the directories on your hard drive as a working directory, which is where it looks for user-written programs and data files.\nTo determine the current directory, type: getwd().\nYou can set the working directory also by typing: setwd(\"your desired directory here\").\nFor example, if you are using Windows OS and want to set your directory to be the “C” drive, type: setwd( \"C:/\" ). NOTE: when you copy and paste filepaths in Windows, the folders are denoted with \\, while R uses /.\nOr, if you are using Mac OS and want to set your directory to be a folder called “Users”, type: setwd( \"/Users\" ).\nOn the Windows OS you can set R to automatically start up in your preferred working directory by right clicking on the program shortcut, choosing properties, and completing the ‘Start in’ field. On the Mac OS you can set the initial working directory using the Preferences menu.\nTo save the workspace use the save.image() function. This function requires a file path, a file name, and the extension “.RData” which is the format for an R workspace file.\nFor example, to save a workspace called “OurFirstTutorial” to the current directory, simply type: save.image(\"OurFirstTutorial.Rdata\"). You can also write in the directory of you want to save it somewhere else. You can also do this by the pull-down menu with the File/Save option.\nTo load a previously saved workspace, you can either click on the file outside of R or use the load() function (e.g. load(\"OurFirstTutorial.Rdata\")). If you get an error, make sure you are referring the correct directory. You can also choose Load Workspace from the pull-down menu.\nNote that only the objects in the workspace are saved, not the text of what you have written.\n\n\n11. (Bonus!) R Studio\nYou may be surprised to discover how little functionality is implemented in the standard R GUI (i.e. graphical user interface). The standard R GUI implements only very rudimentary functionality through menus: reading help, managing multiple graphics windows, editing some source and data files, and some other basic functionality. There are no menu items, buttons, or palettes for loading data, transforming data, plotting data, or doing any real work with data. Commercial applications like SAS, SPSS, and Stata include user interfaces with much more functionality.\nThis was just the nature of working with R until some awesome human beings created RStudio. RStudio is one of several projects to build an easier-to-use GUI for R. It is a free, open-source IDE (i.e. integrated development environment) for working with R. Unlike the standard R GUI, RStudio tiles windows on the screen and puts different windows in different tabs. RStudio can be downloaded from: http://www.rstudio.com.\n\n\nRStudio workthrough\nOk, now open RStudio and let’s take a look!\nNow, that you have RStudio up and running, try rerunning some of the code above. You will see that R operates within the RStudio environment. However, there are more tools available in RStudio which we will use."
  },
  {
    "objectID": "snaca-r-intro-to-r.html#test-your-knowledge-exercises",
    "href": "snaca-r-intro-to-r.html#test-your-knowledge-exercises",
    "title": "Getting Started with R",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nAfter installing R, what does the &gt; prompt represent?\nCreate an object called a with the value 7.\nWhich of the following is a valid object name?\n\n3cats\n.hidden_data\nmy-object\n_underscore\n\nExplain what the following code does: b &lt;- 10?\nWhat is a function in R? Explain using the c() function as an example.\nCreate an object called numbers that contains the values 2, 4, 6, 8, and 10 using the c() function.\nType the following code: length( numbers ). What is the meaning of the number it returns?\nCreate a vector z with the values 10 through 20. Now, write code to retrieve:\n\nThe 3rd element in z.\nThe 2nd through 5th elements in z.\nThe 1st and last elements in z.\n\nWhat is the difference between z[3:5] and z[ c(3,5) ]?\nWhat is the purpose of the install.packages() function? The library() function?\nWhy might you see a “function not found” error when trying to use a function from a package?\nLook through the packages on the CRAN repository. Find one and install it."
  },
  {
    "objectID": "snaca-r-intro-to-r.html#tutorial-summary",
    "href": "snaca-r-intro-to-r.html#tutorial-summary",
    "title": "Getting Started with R",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial provides a quick introduction to R. R is a versatile and open-source programming language designed for data science and statistical analysis. As we will see, it is one of the best environments for working with social network data. We began with an overview of R’s history, emphasizing its unique features, such as being free and customizable through numerous packages. The tutorial then guides readers through essential concepts, including installing R, understanding the R environment, and creating objects, which are fundamental building blocks of any R session. Readers learn how to use functions, reference and manipulate objects, and work with different data types (numeric, character, factor, and logical). The tutorial also covers indexing techniques for accessing specific elements within objects and introduces matrices as a two-dimensional data structure. Practical advice is provided on navigating R’s extensive documentation, installing and loading packages, and managing the R workspace effectively. We also reviewed (briefly) RStudio, a powerful integrated development environment that enhances the R user experience. You are now equipped with foundational skills to explore R further and apply it to real-world data tasks as you continue developing your skills as a crime analyst."
  },
  {
    "objectID": "snaca-r-rmarkdown.html#data-driven-documents",
    "href": "snaca-r-rmarkdown.html#data-driven-documents",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "Data-Driven Documents",
    "text": "Data-Driven Documents\n\nWhat are Data-Driven Documents?\nData-driven documents are formats that combine text and analysis (i.e. data and code). By combining everything in a single file, we promote transparency and reproducibility. For any given table, figure, or model in the document, you should be able to easily discern how it was created, from what data, and what analysis was used.\nWe will use the R Markdown format.\nAll of the document formats build from a simple text formatting convention called markdown.\nTo create an R Markdown document, you need three things:\n\nA header to specify the document type\nSome text (formatted in markdown)\nSome code (inside a “code chunk”)\n\nLet’s see how it works!"
  },
  {
    "objectID": "snaca-r-rmarkdown.html#rmarkdown-in-rstudio",
    "href": "snaca-r-rmarkdown.html#rmarkdown-in-rstudio",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "RMarkdown in RStudio",
    "text": "RMarkdown in RStudio\nFirst, you need to install the rmarkdown and knitr packages using:\n\ninstall.packages( \"rmarkdown\" )\ninstall.packages( \"knitr\" )\n\nHere is a diagram of how to open an RMarkdown file and create an output file:\n\n\n\n\nsequenceDiagram\n    participant User\n    participant RStudio\n    User-&gt;&gt;RStudio: Open RStudio\n    User-&gt;&gt;RStudio: File &gt; New File &gt; RMarkdown...\n    RStudio--&gt;&gt;User: RMarkdown template setup window\n    User-&gt;&gt;RStudio: Specify title, author, and output format (e.g., HTML, PDF, Word)\n    User-&gt;&gt;RStudio: Click \"OK\"\n    RStudio--&gt;&gt;User: Generates a new RMarkdown file\n    User-&gt;&gt;RStudio: Start editing text and adding code chunks\n    User-&gt;&gt;RStudio: Save the file (.Rmd extension)\n    User-&gt;&gt;RStudio: Click \"Knit\" to generate the output document\n\n\n\n\n\n\nLet’s walk through this. First, you need to open RStudio. Then, using the dropdown menu select File &gt; New File &gt; RMarkdown. This will bring up the RMarkdown template window. In this window, you can specify the title, author, and output format. Click “OK” and RStudio will create a new RMarkdown file. An RMarkdown file has two essential pieces: text and code chunks (discussed more below). The last piece is to click the “Knit” button to create the output document.\n\nA Closer Look\n\nKnitting R Markdown Files\nCode is placed inside of “chunks” in the documents:\n\n\n\n\n\nWhen you “knit” a file RStudio will run all of code, embed the output into your document, and then convert the file to whichever type you have specified in the file header.\n\n\n\nOutput Types\nYou can select from many different document types, including HTML pages, Microsoft word, presentation formats, or dashboards.\nCheck out these examples:\nR Markdown Formats R Markdown Gallery\n\nHTML Pages\n---\noutput: html_document\n---\n\n\n\n\n\n\n\n\nDashboards\n---\noutput: flexdashboard::flex_dashboard:\n---\n\n\n\n\n\n\n\nPDFs\n---\noutput: pdf_document\n---\n\nA note on PDFs\nIf you would like to knit to PDF you need one additional program. TeX creates publication-quality PDF files. The open-source version is called MiKTeX download page.\nIf you have problems, you can find some nice tutorials like this one: https://www.reed.edu/data-at-reed/software/R/r_studio_pc.html\n\n\n\n\nWorking with Markdown\nMarkdown is a set of simple conventions for formatting text in R Markdown (RMD) files.\nIt makes it easy to create professional documents with minimal effort.\nHere are the basic formatting rules for Markdown:\n\nHeaders\n# Heading One (h1)\n\n## Heading Two (h2)\n\n### Heading Three (h3)\n\n#### Heading Four (h4)\n\n##### Heading Five (h5)\n\n###### Heading Six (h6)\n\n\nText Style\nWith Markdown, it is possible to emphasize words by making them *italicized*, using *astericks* or _underscores_, or making them **bold**, using **double astericks** or __double underscores__. \n\nOf course, you can combine those two formats, with both _**bold and italicized**_ text, using any combination of the above syntax. \n\nYou can also add a strikethrough to text using a ~~double tilde~~.\nWith Markdown, it is possible to emphasize words by making them italicized, using astericks or underscores, or making them bold, using double astericks or double underscores.\nOf course, you can combine those two formats, with both bold and italicized text, using any combination of the above syntax.\nYou can also add a strikethrough to text using a double tilde.\n\n\nLists\n\nUnordered\n* First item\n* Second item\n* Third item\n    * First nested item\n    * Second nested item\n\nFirst item\nSecond item\nThird item\n\nFirst nested item\nSecond nested item\n\n\n\n\nOrdered\n1. First item\n2. Second item\n3. Third item\n    1. First nested item\n    2. Second nested item\n\nFirst item\nSecond item\nThird item\n\nFirst nested item\nSecond nested item\n\n\n\n\n\nHyperlinks\nCreate links by wrapping the link text in square brackets [ ], and the URL in adjacent parentheses ( ).\n[Google News](https://news.google.com)\nGoogle News\n\n\nImages\nInsert images in a similar way, but add an exclamation mark in front of square brackets [ ], and the image file name goes in the parentheses ( ).\n![alt_text_here](image_file.png)\nThe alt text appears when the image cannot be located, or is read by devices for the blind when the mouse hovers over the image. It\nOr you can link directly to an image online using the URL address of the image:\n![](https://www.rodaw.com/wp-content/uploads/2017/02/Mark-Down-MonsterDogLampShade-1.jpg)\n\n\n\nTables\n| Title 1          | Title 2          | Title 3         | Title 4         |\n|------------------|------------------|-----------------|-----------------|\n| First entry      | Second entry     | Third entry     | Fourth entry    |\n| Fifth entry      | Sixth entry      | Seventh entry   | Eight entry     |\n| Ninth entry      | Tenth entry      | Eleventh entry  | Twelfth entry   |\n| Thirteenth entry | Fourteenth entry | Fifteenth entry | Sixteenth entry |\n\n\n\n\n\n\n\n\n\nTitle 1\nTitle 2\nTitle 3\nTitle 4\n\n\n\n\nFirst entry\nSecond entry\nThird entry\nFourth entry\n\n\nFifth entry\nSixth entry\nSeventh entry\nEight entry\n\n\nNinth entry\nTenth entry\nEleventh entry\nTwelfth entry\n\n\nThirteenth entry\nFourteenth entry\nFifteenth entry\nSixteenth entry"
  },
  {
    "objectID": "snaca-r-rmarkdown.html#tutorial-summary",
    "href": "snaca-r-rmarkdown.html#tutorial-summary",
    "title": "Creating Data-Driven Documents using RMarkdown",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced you to the power of RMarkdown for creating reproducible, data-driven documents using RStudio. By combining narrative text, code, and analytical outputs into a single file, RMarkdown ensures transparency and efficiency in reporting workflows, eliminating the need to switch between multiple programs. This can be a valuable tool for any crime analyst. We (briefly) covered how to generate various output formats, such as HTML, Word, and PDF, which are customizable to suit different professional contexts. The tutorial also covers the basics of Markdown for text formatting, embedding images, creating tables, and hyperlinks, offering a comprehensive foundation for crafting professional documents."
  },
  {
    "objectID": "snaca-r-network-data.html#working-with-matrices",
    "href": "snaca-r-network-data.html#working-with-matrices",
    "title": "Working with Networks in R",
    "section": "Working with matrices",
    "text": "Working with matrices\nFirst, clear the workspace. To do so, we use the following statement:\nLet’s start by working with an example of an undirected, binary network. We will create an object that is the adjacency matrix.\nOne way to create an adjacency matrix is to use the matrix() function with the concatenate() or c() function.\nWe can look at what these functions do by asking for help using the help(\" function name here \") or ?(\" function name here \") functions.\nThe help window describes the arguments that the function takes and also provides examples.\nNow, let’s create the data object:\nThis command reads as follows:\n\nCombine the following numbers\nFrom these combined numbers, create a matrix by reading across the list\nCreate an object called data. This object will be a matrix with 5 rows.\n\nWe can see the object by just typing the object name: mat. Note that if the number of elements does not correctly match the dimensions of the matrix, R gives you an error.\nFor example:\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    1\n\n\nAfter we have created our object mat or junk_1, we can examine the dimensions with the dim function: dim( mat ) or dim( junk_1 ).\nWe can also attach names to the rows and columns of the matrix by using the rownames() and colnames() functions.\n\n\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\nWe can refer to specific elements, rows, or columns by using the [ and ] symbols. This reads as: “object[row,column]”.\nFor example, lets look at the relation Jen sends to Tom.\nRecall from th Network Data Structures chapter that this is element 1,2 in the matrix (i.e. row one, column two). In R code that is: mat[1,2].\nThis command reads as follows: for the object mat, return the value at row 1 column 2. The row number is the first dimension and the column is the second dimension. Remember: “rows by columns”\nWe can also call the values for an entire row or column. A single value is called a scalar.\n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\nSince we have defined names for the rows and columns, we can use those as well.\n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    0    0    0 \n\n\nNote: the following does not work because it needs a character, defined by the \"\" symbols around the name.\nWe can also call a series of values:\n\n\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nTom   1   0   1    0   0\nBob   0   1   0    1   1\n\n\n     Jen Tom Bob\nJen    0   1   0\nTom    1   0   1\nBob    0   1   0\nLeaf   0   0   1\nJim    0   0   1\n\n\nWe can also call a group of values that are non-contiguous using the c() function:\n\n\n    Jen Tom Bob Leaf Jim\nJen   0   1   0    0   0\nBob   0   1   0    1   1\n\n\n     Jen Bob\nJen    0   0\nTom    1   1\nBob    0   0\nLeaf   0   1\nJim    0   1\n\n\nWe can also call a group of values that that do not contain specified values by putting a - (i.e. a minus sign) in front of the c function:\n\n\n     Jen Tom Bob Leaf Jim\nTom    1   0   1    0   0\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\n     Tom Leaf Jim\nJen    1    0   0\nTom    0    0   0\nBob    1    1   1\nLeaf   0    0   1\nJim    0    1   0\n\n\nGot it? If yes, then GREAT! If no, hang in there: you got this! If you are a bit hesitant with working with indexing, the best way to get better is to practice. Feel free to work back through the section above to get better at this basic skill we will use a LOT in subsequen tutorials."
  },
  {
    "objectID": "snaca-r-network-data.html#exploring-the-network-package",
    "href": "snaca-r-network-data.html#exploring-the-network-package",
    "title": "Working with Networks in R",
    "section": "Exploring the network Package",
    "text": "Exploring the network Package\nNow that we have our object mat is created, let’s manipulate it into a network and a graph. To do this, we can use the network package. network is a package containing tools to create and modify network objects created by Carter Butts. See the network page for an overview of package functionality.\nFirst, we need to install the package using: install.packages( \"network\" ). Note: if you have already installed the package, no do not need to reinstall it.\nIf it is already installed, we should check to make sure we have the most recent version: update.packages( \"network\" )\nWhenever we start R, we need to load the package because it is not automatically loaded. To do this, use the library() function. library( \"network\" )\nTo get a list of the contents of the package, as for help with respect to the package itself use the help() function, but tell R we want help on the particular package: help( package=\"network\" ).\n\nWorking with Unidirected, Binary Networks\nNow that the package is loaded, lets create a new object from our matrix that is a network. In R lingo, we will use the network() function to create an object that is of class network. To use some of the functions, it has to be a specific class.\nJust like you can’t perform calculations on a object that is of class character (e.g. a list of names), the functions in this page are designed to work with a network object.\n\n\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\n[1] \"matrix\" \"array\" \n\n\nWhen we enter the object in the command line, summary info about the object is produced: net_u. This is because the object is of class network. We can use the class function to confirm this: class( net_u ).\nLet’s look at the object again: net_u. What does the summary output of the object tell us?\nNote that the network is treated as directed. By default, the function as.network() sets the argument directed = to TRUE. We can see this by looking at the structure of the function in the help page: ?as.network. What do we need to change in the as.network() function?\nWe need to change the input for the directed= argument because our network is undirected. In other words, directed = FALSE. This tells the function that the matrix we are entering is an undirected network. This is logical: is the object a directed network? False. Therefore, it is an undirected network.\n\n\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 10 \n    missing edges= 0 \n    non-missing edges= 10 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\n Network attributes:\n  vertices = 5 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 5 \n    missing edges= 0 \n    non-missing edges= 5 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nThe summary() function is a generic function that summarizes objects. We can use it on an object of class network to provide more information: summary( net_u_correct ). More information about what can be done with the summary() function for an object of class network is shown on the ?as.network page.\nWe could also enter the data as an edgelist using the matrix.type = argument. By default, the function as.network() sets the argument matrix.type = to adjacency. For an edgelist, we would need to change the input for the matrix.type = argument to edgelist.\n\n\n     [,1]   [,2]  \n[1,] \"Jen\"  \"Tom\" \n[2,] \"Tom\"  \"Bob\" \n[3,] \"Bob\"  \"Leaf\"\n[4,] \"Bob\"  \"Jim\" \n[5,] \"Leaf\" \"Jim\" \n\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   1\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   1   0    0   0\n\n\n\n\nWorking with Directed, Binary Networks\nNow, let’s work with the example of a directed, binary network. We will create an object that is the adjacency matrix.\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    0    0    0\n[2,]    0    0    1    0    0\n[3,]    0    0    0    1    1\n[4,]    0    0    1    0    1\n[5,]    0    0    1    1    0\n\n\nNow, let’s coerce it to be an object of class network.\n\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n  1 2 3 4 5\n1 0 1 0 0 0\n2 0 0 1 0 0\n3 0 0 0 1 1\n4 0 0 1 0 1\n5 0 0 1 1 0\n\n\nJust as before, we could also enter the data as an edgelist. Since we have directed relations, we have more edges. This is because reciprocated ties count twice. So, we have to tell the matrix() function that the matrix has 8 rows, instead of 5.\n\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Bob Jen Jim Leaf Tom\nBob    0   0   1    1   0\nJen    0   0   0    0   1\nJim    1   0   0    1   0\nLeaf   1   0   1    0   0\nTom    1   0   0    0   0\n\n\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 8 \n   missing edges = 0 \n   non-missing edges = 8 \n density = 0.4 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\n\n\n\nImporting Network Data\nIf we had a large network, these routines (i.e. using the matrix() function) would be tedious. Most of the time, we have a file that is an adjacency matrix or an edgelist that we can import. The read.csv() function can be used to read in .csv files that are arranged in this way. Let’s take a look at the help for this function: ?read.csv.\nWe will use a file called data-undirected-example.csv. To access the file, we can place the url in the read.csv() function.\nHere is the url: https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv.\n\n# define the path\nurl &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\"\n\n# define the data using the url object\nmat_u &lt;- read.csv( url )\n\n# look at the object\nmat_u\n\n# note that the read.csv function creates an object of class data.frame.\nclass( mat_u )\n\nWe need to adjust the arguments to read in the file how we want it. Specifically, we want to do the following:\n\nSet the as.is = argument equal to TRUE so that it reads the data as it is.\nSet the header = argument to TRUE to indicate that there is a header, or column labels.\nSet the row.names = argument equal to 1 to indicate that the name of the rows are in the first column.\n\n\n# look at the arguments\nmat_u2 &lt;- read.csv( \n  url,\n  as.is = TRUE,\n  header = TRUE,\n  row.names = 1 \n  )\n\nmat_u2\n\n# compare them\nmat_u\nmat_u2\n\nNow, make the object into one of class network:\n\n# we have to first coerce the object to a matrix\nmat_u2 &lt;- as.matrix( mat_u2 )\n\n# recall that since this network is undirected\n# we set the directed= argument to FALSE\nnet_u &lt;- as.network( \n  mat_u2,\n  directed = FALSE\n   )\n\nnet_u\n\n# we could combine the as.matrix and as.network functions\nnet_u &lt;- as.network( \n  as.matrix( \n    mat_u2 ), \n  directed = FALSE \n  )\n\nnet_u\n\nWe could also import the file if it is saved locally (i.e. we are not going to the web to get it). Typically we do not do this because it is a bad practice. That is, creating a version of a file locally. But, sometimes you might be offline or you have files that cannot be put online.\nLet’s do this for the directed network. I have saved the file to my desktop. First, look at what directory we are in using: getwd() function. This function gets the wording directory R is currently looking at.\nThen, set the directory where the file is using the setwd() function. You can get the location of the file by right-clicking and in Windows using Properties or on Mac using Get Info. Note that you have to configure this path to your machine.\nThen, use read.csv as above:\n\nsetwd( \"PUT THE CORRECT PATH HERE\" )\n\nmat_d &lt;- read.csv(\n  \"data-directed-example.csv\",\n  as.is=TRUE,\n  header=TRUE,\n  row.names=1\n  )\n\n# Note: we don't need to tell it that \n# the network is directed since \n# this is the default, \n# but a good habit to get into.\nnet_d &lt;- as.network(\n  as.matrix( data_d ),\n  directed=TRUE\n  )\n\n\n\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 8 \n    missing edges= 0 \n    non-missing edges= 8 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes"
  },
  {
    "objectID": "snaca-r-network-data.html#test-your-knowledge-exercises",
    "href": "snaca-r-network-data.html#test-your-knowledge-exercises",
    "title": "Working with Networks in R",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nCreate a 5x5 adjacency matrix using the matrix() function.\n\nWhat happens if the number of elements doesn’t match the dimensions of the matrix?\nAssign meaningful row and column names to the adjacency matrix using the rownames() and colnames() functions.\nHow can you reference a specific row or column by name?\n\nUse the [ and ] symbols to extract specific elements, rows, or columns from a matrix.\n\nCoerce an adjacency matrix into a network object using the as.network() function.\n\nWhat argument must you modify to create an undirected network?\n\n\nCreate an edgelist for a directed network and convert it to a network object. How does this process differ from working with adjacency matrices?\n\nSummarize a network object using the summary() function.\n\nWhat insights can you gain from this output?\n\n\nExplain the difference between directed and undirected networks in the context of the as.network() function.\n\nWhat specific arguments are used to define these properties?"
  },
  {
    "objectID": "snaca-r-network-data.html#tutorial-summary",
    "href": "snaca-r-network-data.html#tutorial-summary",
    "title": "Working with Networks in R",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced the basics of working with network data in R, focusing on creating, manipulating, and importing network structures. It began with constructing adjacency matrices using the matrix() function, followed by assigning meaningful row and column names for clarity and exploring matrix indexing to extract specific elements, rows, or columns. The tutorial then transitioned to coercing matrices into network objects using the as.network() function from the network package, with special attention to specifying whether a network is directed or undirected. The use of edgelists as an alternative to adjacency matrices was demonstrated, highlighting the importance of specifying the correct matrix type in the as.network() function. The tutorial also covered importing network data from external sources, including CSV files from URLs or local directories, and converting them into network objects. The emphasis was on building a solid foundation for working with network data structures, which are essential for analyzing relationships and interactions in crime analysis."
  },
  {
    "objectID": "snaca-r-visualization.html#network-visualization",
    "href": "snaca-r-visualization.html#network-visualization",
    "title": "Basics of Network Visualization",
    "section": "Network Visualization",
    "text": "Network Visualization\nOne of the great features of working with network data is the ability to see the data through visualization. Visualizing the structure of a network is helpful for discerning patterns that might be of interest.\nDouglas Luke’s (2015: 47) A User’s Guide to Network Analysis provides several guidelines, or aesthetic principles, for what makes a graphical layout of a network easy to understand and interpret. These are:\n\nMinimize edge crossings\nMaximize the symmetry of the layout of nodes\nMinimize the variability of the edge lengths\nMaximize the angle between edges when they cross or join nodes\nMinimize the total space used for the network display\n\nThink about each of these suggestions. Why do they aid in visualizing the network? How do they assist in avoiding conveying information that is not really there? Ponder these questions for a bit…"
  },
  {
    "objectID": "snaca-r-visualization.html#getting-started",
    "href": "snaca-r-visualization.html#getting-started",
    "title": "Basics of Network Visualization",
    "section": "Getting Started",
    "text": "Getting Started\nNow that you have a sense of what a good visualization should try to do, let’s look at the example Luke uses as an illustration by working with the gplot() function in the sna package.\nFirst, we need to install the sna package using install.packages( \"sna\" ) and load the library using library( sna ).\nRemember, if you have already installed a package then you do not need to use the install.packages() function. But, if you have not installed the package in a while, you should use update.packages() to incorporate any changes that have been made to the page.\nNext, let’s get the UserNetR package from Douglas Luke’s GitHub page. Since this package is not on the CRAN package repository, we need to install it directly from Github. We do this in four steps:\n\nFirst, install the devtools package using install.packages( \"devtools\" )\nAnd then load the library for the package with library( devtools )\nNow, install the UserNetR package install_github( \"DougLuke/UserNetR\" )\nFinally, load the library library( UserNetR )\n\nAltogether, that looks something like this:\n\n# install the packages\ninstall.packages( \"sna\" )\ninstall.packages( \"devtools\" )\n\n# call the libraries\nlibrary( sna )\nlibrary( devtools )\n\n# install from Github\ninstall_github( \"DougLuke/UserNetR\" )\n\n# call that library\nlibrary( UserNetR )\n\nNow, let’s take a look at the Moreno network (see help( Moreno, package = UserNetR ). These data are contained in a sociogram constructed by Jacob Moreno, and published in the New York Times in 1933 (see Moreno, J. L. 1934. Who shall survive? A new approach to the problem of human interrelations. Nervous and mental disease monograph series, no. 58. Washington, DC: Nervous and Mental Disease Publishing Co. for a more extensive discussion).\n\n# Note that we ask the summary() function to not print out the adjacency matrix.\nsummary( Moreno, print.adj = FALSE )\n\nNetwork attributes:\n  vertices = 33\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 46 \n   missing edges = 0 \n   non-missing edges = 46 \n density = 0.08712121 \n\nVertex attributes:\n\n gender:\n   numeric valued attribute\n   attribute summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   1.000   2.000   1.515   2.000   2.000 \n  vertex.names:\n   character valued attribute\n   33 valid vertex names\n\nNo edge attributes\n\n# Now, let's compare two different plot layouts.\n\n# Here is a circle.\ngplot( Moreno, mode = \"circle\" )\n\n\n\n\n\n\n\n# Here is a separate layout.\ngplot( Moreno, mode = \"fruchtermanreingold\" )\n\n\n\n\n\n\n\n\nThink back to the aesthetic elements we discussed above. How do these two plots differ in how well they convey the same information? Which one is better? Why is it better?\nTo think about these questions, let’s plot the two layouts together. To do this we will use the par() function. This allows us to partition the plotting region.\n\n# First, we define the plot layout window.\nop &lt;- par( \n  mar = rep( 2, 4 ), # set the margins\n  mfrow = c( 1, 2 )  # set the dimensions\n  )\n\n# plot the circle layout (add the main() argument for a title)\ngplot( Moreno, mode = \"circle\", main = \"Plotted as a circle\" )\n\n# plot the Fruchterman Reingold layout\ngplot( Moreno, mode = \"fruchtermanreingold\", main = \"Plotted using a spring algorithm\" )\n\n\n\n\n\n\n\n\nAgain, think about our questions: How do these two plots differ in how well they convey the same information? Which one is better? Why is it better?\n\nAdding Attributes\nIf we add information about gender, we can see a bit more that is revealed by the spring algorithm.\nTo do so, we use the vertex.col= argument with the vertex attribute gender. To do so, we need to access the vertex attribute. We can do this with:\n\nthe get.vertex.attribute() function in the sna package. Use library( sna ) and specify the attribute we want, like get.vertex.attribute( Moreno,  \"gender\" )\nor use the shorthand for this with network object %v% atttribute, like Moreno %v% \"gender\"\n\n\nop &lt;- par( mar = rep( 2, 4 ), mfrow = c( 1, 2 ) )\n\ngplot( Moreno,\n      mode = \"circle\",\n      main = \"Plotted as a circle\",\n      vertex.col = get.vertex.attribute( Moreno, \"gender\" ) # use the vertex attribute.\n      )\n\ngplot( Moreno,\n       mode = \"fruchtermanreingold\",\n       main = \"Plotted using a spring algorithm\",\n       vertex.col = Moreno %v% \"gender\" # note the difference here compared to above.\n       )\n\n# let's add a legend to the plot\nlegend(\n  \"bottomleft\",\n  legend = c( \"Male\",\"Female\" ),\n  col = c( \"red\",\"black\" ),\n  title = \"legend\",\n  pt.cex = 0.75,\n  bty = \"n\",\n  pch = 19 \n  )\n\n\n\n\n\n\n\n\nWhat is the primary story that the plot tells? Does a particular layout help us see that better?\nOk, that was a lot. Let’s work our way back through the mechanics of building a plot to better get a sense of what we are doing."
  },
  {
    "objectID": "snaca-r-visualization.html#working-with-the-gplot-function",
    "href": "snaca-r-visualization.html#working-with-the-gplot-function",
    "title": "Basics of Network Visualization",
    "section": "Working with the gplot() Function",
    "text": "Working with the gplot() Function\nLet’s take a look at some of the visualization capabilities of gplot(). Let’s start by looking at the function’s help page: ?gplot.\nTo see the various functionality of the function, let’s work with our example of an undirected network.\n\n# define the path where the data are\nurl &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\"\n\n# define the object\nmat_u &lt;- as.matrix(\n  read.csv( \n    url,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1\n    )\n  )\n\n# now, create the network\nnet_u &lt;- network(\n  mat_u,\n  directed = FALSE\n)\n\n# take a look at the network\nsummary( net_u )\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n#NOTE: we could have wrapped all of this into two statements\nnet_u &lt;- as.network( \n  as.matrix( \n    read.csv( \n      \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-undirected-example.csv\", \n      as.is = TRUE, \n      header = TRUE, \n      row.names = 1 \n      ) \n    ),\n  directed = FALSE \n  )\n\nsummary( net_u )\n\nNetwork attributes:\n  vertices = 5\n  directed = FALSE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 5 \n   missing edges = 0 \n   non-missing edges = 5 \n density = 0.5 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nNo edge attributes\n\nNetwork adjacency matrix:\n     Jen Tom Bob Leaf Jim\nJen    0   1   0    0   0\nTom    1   0   1    0   0\nBob    0   1   0    1   1\nLeaf   0   0   1    0   1\nJim    0   0   1    1   0\n\n\nNow that we have the object built, we can plot it.\n\ngplot( net_u )\n\n\n\n\n\n\n\n\nHold on, this plot shows arrows. But this network is undirected. What gives?\nThat is because gplot() assumes a directed network. We can see this in the help menu, ?gplot, where is shows that for the type of network, the gmode= argument defaults to a directed graph. To fix this we can either:\n\nmanually turn off the display of arrows using the usearrows= argument, gplot( net.u, usearrows = FALSE )\nor indicate that the object to be plotted is a undirected graph or graph, gplot( net.u, gmode = \"graph\" )\n\nThe gplot() function has a number of arguments that can be used to work try and better display the information contained in the network.\nFor example, we can add labels to the vertices using the network.vertex.names() function.\n\ngplot(\n  net_u, \n  gmode = \"graph\", \n  label = network.vertex.names( net_u )\n  )\n\n\n\n\n\n\n\n\nAlternatively, we could add in a string of names for the label:\n\ngplot( net.u, gmode = \"graph\",  label = c( \"Jen\", \"Tom\", \"Bob\", \"Leaf\", \"Jim\" ) )\n\nOr we could read them in as an object:\n\nnames &lt;- c( \"Jen\", \"Tom\", \"Bob\", \"Leaf\", \"Jim\" )\nadd to the plot using gplot( net.u, gmode = \"graph\", label = names )\n\nA great feature of R is that we can tune the graphing parameters. Here are several examples:\n\nLabels:\n\nAdd boxes around the labels, boxed.labels = TRUE\nChange label size using label.cex, such as label.cex = 1.5\nColor the labels using label.col=, such as: label.col = \"blue\"\n\nColors:\n\ndifferent colored names, combine label.col= with the c() function. Such as: label.col = c( \"red\", \"blue\", \"green\", \"orange\", \"grey\" )\ndifferent colored nodes, vertex.col= argument. Such as: vertex.col=c(\"red\",\"blue\",\"green\",\"orange\",\"grey\")\ndifferent colored edges, using edge.col=, such as: edge.col=c(\"red\",\"blue\",\"green\",\"orange\",\"grey\")\n\n\nThere is a LOT of functionality to the gplot() function. See the arguments in the help file: ?gplot. I would encourage you to take some time to look through it and play around with the various features.\n\nAdjusting Plot Layout\nWhen a layout is generated, the results can be saved for later reuse using the coord= argument.\n\n# Set the seed for the random number generator \n# so we can always get the same plot layout.\nset.seed( 605 ) \n\n# Define an object that will be the coordinates we want to use.\ncoords &lt;- gplot( \n  net_u, \n  gmode = \"graph\",\n  label = network.vertex.names( net_u )\n  )\n\n\n\n\n\n\n\n# Show the vertex coordinates.\ncoords\n\n             x         y\n[1,] -5.441389 -1.849797\n[2,] -4.682331 -3.198937\n[3,] -3.171835 -3.157688\n[4,] -2.055885 -2.041756\n[5,] -1.648225 -3.476604\n\n\nTake a close look at the coords object. What do the values represent? Think about how this information is used in the plot.\nNow, we can pass the coordinates into a plot.\n\n# Saved layouts can be used via the coord= argument:\ngplot(\n  net_u, \n  gmode = \"graph\",\n  label = network.vertex.names( net_u ),\n  coord = coords \n  )\n\n\n\n\n\n\n\n\nCool but, why do this? The placement of the nodes shift when we call the gplot() function just due to the operation of the algorithm. Controlling where nodes are plotted in the 2-dimensional space is useful if we want to show different aspects of the plot. Note that we can have different layouts of the nodes. If we like a particular one, we can save the coordinates.\nBut, suppose the default settings are insufficient and we want to make a few small changes. The interactive= argument allows for tweaking.\n\n# First, set up the coordinates you want.\ncoords &lt;- gplot(\n  net_u, \n  gmode = \"graph\",\n  label = network.vertex.names( net_u ),\n  coord = coords, \n  interactive=TRUE \n  )\n\nWhen this renders on your system, move a few of the nodes around. Then, after you close the window it will save the coordinates.\n\n# Then, use these in the plot.\ngplot( \n  net_u, \n  coord = coords, \n  gmode = \"graph\",\n  label=network.vertex.names( net_u )\n  )"
  },
  {
    "objectID": "snaca-r-visualization.html#a-layering-approach",
    "href": "snaca-r-visualization.html#a-layering-approach",
    "title": "Basics of Network Visualization",
    "section": "A Layering Approach",
    "text": "A Layering Approach\nAs we have seen, we can start with a basic plot and add information. Creating graphics in this way is referred to as layering because we are stacking additional layers of elements on top of each other.\nTake a look at this series of plots:\n\n\n\n\n\n\n\n\n\nThe plot uses several layers of information:\n\nthe size of the nodes (vertex.cex)\nthe color of the nodes (vertex.col)\nthe color of the edges (edge.col)\n\nAs we create a plot, we want to think about what information we should convey and how best to convey that information (i.e. colors?, shapes?, size?, all of the above?)"
  },
  {
    "objectID": "snaca-r-visualization.html#plotting-the-powerinfluence-network-from-the-prison-inmate-networks-study-pins",
    "href": "snaca-r-visualization.html#plotting-the-powerinfluence-network-from-the-prison-inmate-networks-study-pins",
    "title": "Basics of Network Visualization",
    "section": "Plotting the Power/Influence Network from the Prison Inmate Networks Study (PINS)",
    "text": "Plotting the Power/Influence Network from the Prison Inmate Networks Study (PINS)\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collect sociometric data in a prison. The researchers collected data on several types of networks.\nLet’s plot the power and influence network, which was created by asking individuals whom they believed was “powerful and influential” on the unit. We will continue working with the gplot() function.\nWe are going to do this in a few steps:\n\nFirst, load the adjacency matrix, data-PINS-power-w1-adj.csv, and create an object of class network.\nSecond, load the file with Age and Race attributes, data-PINS-w1-age-race-attributes.csv, and assign each attribute to the network object.\n\n\n# define the adjacency matrix\nPI_mat &lt;- as.matrix(\n  read.csv( \n    \"https://raw.githubusercontent.com/jacobtnyoung/snaca-r/main/data/data-PINS-power-w1-adj.csv\",\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1\n    )\n  )\n\n# create an object of class network\nPI_net &lt;- network( PI_mat, directed = TRUE )\n\n# define the attributes object\nPI_attrs &lt;- read.csv( \n    \"https://raw.githubusercontent.com/jacobtnyoung/snaca-r/main/data/data-PINS-w1-age-race-attributes.csv\",\n    as.is = TRUE,\n    header = TRUE \n    )\n\n# assign the attributes to the network\nPI_net %v% \"Age\" &lt;- PI_attrs[,1]\nPI_net %v% \"Race\" &lt;- PI_attrs[,2]\n\nNote that we used a shorthand notation: %v%. This is an assignment operation that tells R to assign something to the network. Specifically, %v% indicates the assignment to a vertex, hence the v.\nThe operate also let’s us pull a specific attribute. We can look at the various vertex data by using the shorthand network %v% \"attribute\". For example:\n\nPI_net %v% \"Age\" shows the age variable.\nPI_._net %v% \"Race\" shows the race variable.\n\n\n# look at the values for age\nPI_net %v% \"Age\" &lt;- PI_attrs[,1]\n\n# look at the values for race\nPI_net %v% \"Race\" &lt;- PI_attrs[,2]\n\nNote that we can also reference edges (i.e. %e%) if a network has an assigned edge. For example, we could pull the information network and assign that to the power influence network:\n\n# define the adjacency matrix\nINFO_mat &lt;- as.matrix(\n  read.csv( \n    \"https://raw.githubusercontent.com/jacobtnyoung/snaca-r/main/data/data-PINS-info-w1-adj.csv\",\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1\n    )\n  )\n\n# assign the matrix as an edge attribute\nPI_net %e% \"info\" &lt;- INFO_mat\n\nThink about what we did on the last line. For the power influence edges, we assigned INFO_._mat as an attribute. This represents whether a power/influence tie was also an information network tie.\nNow, we can use that information in our plot. For example:\n\ngplot( PI_net,\n       arrowhead.cex=0.5,\n       vertex.cex = PI_net %v% \"Age\" )\n\n\n\n\n\n\n\n\nYIKES!!! What is wrong?\nThe problem is that we need to rescale the vertex attribute so that the nodes are not too big. Let’s build a function to do that and then execute the gplot() function:\n\nrescale &lt;- function( nchar, low, high ){\n  min_d &lt;- min( nchar )\n  max_d &lt;- max( nchar )\n  rscl  &lt;- ( ( high - low )*( nchar - min_d ) ) / ( max_d - min_d ) + low\n  rscl\n}\n\nNow, use the function we created to rescale the vertex attribute:\n\n# now execute the plot\ngplot( PI_net, \n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nNote that the plot above has a lot of “whitespace” due to the margins. We can adjust this using the par() function.\n\n# tweak the margins to cut some whitespace\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\n# now execute the plot\ngplot( PI_net, \n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nThat looks better. Let’s drop the isolates (using the displayisolates = FALSE argument) to help with the visualization.\n\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\ngplot( PI_net,\n       displayisolates = FALSE,\n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nHow about we color the edges based on whether there was a information network tie.\n\npar( mar = c( 0.1,0.1,0.1,0.1 ) )\n\ngplot( PI_net,\n       edge.col = PI_net %e% \"info\" + 1,\n       displayisolates = FALSE,\n       arrowhead.cex=0.5,\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ) )\n\n\n\n\n\n\n\n\nAs we build layers, we can get a fairly useful graphic that tells us a lot of information:\n\npar( mar = c( 5,0.1,3,0.1 ) )\n\ngplot( PI_net,\n       main=\"PINS Power/Influence Network\", # add a title\n       vertex.col = PI_net %e% \"Race\", # color the nodes by the Race variable\n       edge.col = PI_net %e% \"info\" + 2, # color the edges by the information network attribute\n       displayisolates = FALSE, # don't display the isolated cases\n       arrowhead.cex=0.5, # augment the size of the arrowheads\n       vertex.cex = rescale( PI_net %v% \"Age\", 0.5, 1.5 ), # size the nodes by the Age variable\n       sub=\"Nodes colored by Race, \\n edges colored by Info net \\n nodes sized by Age\" # add a subtitle\n       )"
  },
  {
    "objectID": "snaca-r-visualization.html#test-your-knowledge-exercises",
    "href": "snaca-r-visualization.html#test-your-knowledge-exercises",
    "title": "Basics of Network Visualization",
    "section": "Test Your Knowledge Exercises",
    "text": "Test Your Knowledge Exercises\n\nUsing the Moreno dataset, compare the circle layout and the Fruchterman-Reingold layout. Which layout better adheres to the aesthetic principles discussed above? Why?\nModify the Moreno visualization to color nodes by gender. How does this addition change your interpretation of the network structure?\nWhen plotting an undirected network, why might gplot() still display arrows? How can this be resolved?\nExperiment with adding labels to a network plot. What are some ways to customize label appearance? Why might label size or color be important?\nUse the rescale() function to adjust node sizes based on a vertex attribute. Try some different values. How do the difference values influence your understanding of the network?\nExplain why saving node coordinates using the coord= argument can be useful. Demonstrate how to save and reuse coordinates in a network plot.\nDescribe the concept of layering in network visualization. Create a plot that layers at least three attributes (e.g., node size, color, edge attributes).\nCompare a basic network plot of the PINS dataset with one that incorporates multiple attributes. What additional insights does the more detailed visualization provide?"
  },
  {
    "objectID": "snaca-r-visualization.html#tutorial-summary",
    "href": "snaca-r-visualization.html#tutorial-summary",
    "title": "Basics of Network Visualization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThere is nothing like a beautiful network visualization that conveys lots of information and is aesthetically pleasing. Now you know how to get there! As you have seen, there is a ton of flexibility. I would encourage you to spend some time tinkering with the various arguments for the gplot() function to get a feel for what it can do."
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-undirected-binary-graphs",
    "href": "snaca-r-degree-centrality.html#degree-centrality-undirected-binary-graphs",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality (Undirected Binary Graphs)",
    "text": "Degree Centrality (Undirected Binary Graphs)\nIn an undirected binary graph, actor degree centrality measures the extent to which a node connects to all other nodes in a network. In other words, the number of edges incident with a node. This is symbolized as: \\(d(n_i)\\). For an undirected binary graph, the degree \\(d(n_i)\\) is the row or column sum. If we have an object of class(matrix) in the workspace, we can use the colSums() and/or rowSums() functions to return this information.\nFirst, let’s set up our graph from the degree centrality chapter:\n\n# First, clear the workspace\nrm( list = ls() )\n\n# Then, build an object\nu_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ),\n  c( 0,1,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ) )\n\n# Assign the names to the object\nrownames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# Now, plot the graph (remember to load the sna package)\n# The quitely= argument tells R not to print out the info on the package\nlibrary( sna, quietly=TRUE ) \n\n# Let's set up the coordinates to force the nodes\n# to be in the same position throughout the lab\nset.seed( 507 )\ncoords &lt;- gplot( u_mat )\n\n\n\n# Plot the network\ngplot( \n  u_mat, \n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  coord = coords\n  )\n\n\n\n\nSince the graph is undirected, we can print the degree centrality for each node as a vector using the colSums() or rowSums() functions:\n\ncolSums( u_mat )\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\nrowSums( u_mat )\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\n# We could also assign these to an object\ndeg_u_mat &lt;- colSums( u_mat )\n\nThen, we can use that information in the plot by passing the degree object to the vertex.cex= argument. This will make nodes with higher degree larger.\n\ngplot(\n  u_mat,\n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  vertex.cex = deg_u_mat, #HERE: we added the object to size the plot\n  coord = coords\n  )\n\n\n\n\nAnother approach is to shade the nodes. Rather than just the size, we might want to have nodes with larger degree to be darker (or lighter) to better visualize differences in degree. To do this, we could use the RColorBrewer package to shade the nodes.\n\n# install.packages( \"RColorBrewer\" )\nlibrary( RColorBrewer, quietly=TRUE )\n\n# use display.brewer.all() to see the pallettes.\n\n# Let's use the Blues pallette.\ncol_deg  &lt;- brewer.pal( length( unique( deg_u_mat ) ), \"Blues\")[deg_u_mat]\n\n# In this plot, what do darker shades mean?\ngplot(\n  u_mat, \n  gmode=\"graph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( u_mat ),\n  label.col=\"blue\",\n  label.cex=1.2,\n  vertex.cex = deg_u_mat,\n  vertex.col = col_deg,\n  coord = coords\n  )\n\n\n\n\n\nStandardized degree centrality, mean degree, and centralization\nActor degree centrality not only reflects each node’s connectivity to other nodes but also depends on the size of the network, g. As a result, larger networks will have a higher maximum possible degree centrality values. This makes comparison across networks problematic. The solution is to take into account the number of nodes and the maximum possible nodes to which i could be connected, g-1.\nLet’s calculate the standardized centrality scores for our undirected graph:\n\n# unstandardized or raw centrality\ndeg_u_mat &lt;- colSums( u_mat )\n\n# to calculate g-1, we need to know the number of nodes in the graph \n# this is the first dimension of the matrix\ng &lt;- dim( u_mat )[1]\n\n# now, divide by g-1\ns_deg_u_mat &lt;- deg_u_mat / ( g-1 )\n\ndeg_u_mat\n\n Jen  Tom  Bob Leaf  Jim \n   1    2    3    2    2 \n\ns_deg_u_mat\n\n Jen  Tom  Bob Leaf  Jim \n0.25 0.50 0.75 0.50 0.50 \n\n\nWe can also examine the average degree of the graph using\n\\[\\frac{\\sum_{i=1}^g d(n_i)}{g}\\] or\n\\[\\frac{2L}{g}\\]\nwhere L is the number of edges in the graph:\n\nmean_deg &lt;- sum( deg_u_mat ) / dim( u_mat )[1] \n\nmean_deg\n\n[1] 2\n\n# Note that we can also use the mean() function to return this information:\nmean( deg_u_mat )\n\n[1] 2\n\n\n\nWe can also calculate how centralized the graph itself is. Group degree centralization measures the extent to which the actors in a social network differ from one another in their individual degree centralities. Following Wasserman and Faust (1994), an index of group degree centralization can be calculated as:\n\\[C_D = \\frac{\\sum\\limits_{i=1}^g [C_D(n^*) - C_D(n_i)]}{[(g-1)(g-2)]}\\]\nfor undirected graphs where \\(C_D(n^*)\\) is the maximum degree in the graph. We can write out the components of the equation using the max() function:\n\n# In separate pieces\ndeviations &lt;- max( deg_u_mat ) - deg_u_mat\nsum_deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-2 )\ngroup_deg_cent &lt;- numerator/denominator\n\ngroup_deg_cent\n\n[1] 0.4166667\n\n# Or, as a single equation.\ngroup_deg_cent &lt;-( sum( ( ( max( deg_u_mat ) - deg_u_mat ) ) ) ) / ( ( g -1 )*( g - 2 ) )\n\ngroup_deg_cent\n\n[1] 0.4166667"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-directed-binary-graphs",
    "href": "snaca-r-degree-centrality.html#degree-centrality-directed-binary-graphs",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality (Directed Binary Graphs)",
    "text": "Degree Centrality (Directed Binary Graphs)\nIn a directed binary graph, actor degree centrality can be broken down into indegree and outdegree centrality. Indegree, \\(C_I(n_i)\\), measures the number of ties that i receives. For the sociomatrix \\(Xij\\), the indegree for i is the column sum. Outdegree, \\(C_O(n_i)\\), measures the number of ties that i sends. For the sociomatrix \\(Xij\\), the outdegree for i is the row sum.\nAs before, if we have an object of class(matrix) in the workspace, we can use the rowSums() and colSums() functions. However, the colSums() function will return the indegree centrality for i and the rowSums() function will return the outdegree centrality for i.\nFirst, let’s set up our directed graph from the degree centrality lecture:\n\n# First, clear the workspace\nrm( list = ls() )\n\n# Then, build the object\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ),\n  c( 0,0,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ) )\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# Let's set up the coordinates to force the nodes\n# to be in the same position throughout the lab\nset.seed( 507 )\n\n# remove the old object named coords\nrm( coords )\n\n# set the new coordinates\ncoords &lt;- gplot( d_mat )\n\n\n\n# Now, plot the graph (remember to load the sna package)\ngplot(\n  d_mat, \n  gmode=\"digraph\",\n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=1.2,\n  coord = coords\n  )\n\n\n\n\n\n# Let's look at the different centrality scores \n# by assigning them to different objects\nideg_d_mat &lt;- colSums( d_mat )\nodeg_d_mat &lt;- rowSums( d_mat )\n\n# print them out to examine them\nideg_d_mat\n\n Jen  Tom  Bob Leaf  Jim \n   0    1    3    2    2 \n\nodeg_d_mat\n\n Jen  Tom  Bob Leaf  Jim \n   1    1    2    2    2 \n\n\nNow, let’s work this information in the plot. We will want to partition the plotting window using the par() function to show two plots and we want to change the margins using the mar= argument. Use ?par and/or ?mar to view the help on how these work.\n\npar( \n  mfrow=c( 1, 2 ), \n  mar=c( 0.1, 0.5, 4, 0.1) \n  )\n\ngplot(\n  d_mat, \n  gmode=\"digraph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=0.8,\n  label.pos=1,\n  vertex.cex = ideg_d_mat+0.2,\n  main=\"Nodes sized by Indegree\",\n  coord = coords\n  )\n\ngplot(\n  d_mat, \n  gmode=\"digraph\", \n  arrowhead.cex=0.5, \n  edge.col=\"grey40\", \n  label=rownames( d_mat ),\n  label.col=\"red\",\n  label.cex=0.8,\n  label.pos=1,\n  vertex.cex = odeg_d_mat,\n  main=\"Nodes sized by Outdegree\",\n  coord = coords\n  )\n\n\n\n\n\n\n\n\nNote the difference. Which nodes are more central in terms of indegree? What about outdegree?\nAgain, let’s use the RColorBrewer package to help with shading.\n\n# create the objects\ncol_ideg  &lt;- brewer.pal( length( unique( ideg_d_mat ) ), \"Greens\")[ideg_d_mat]\ncol_odeg  &lt;- brewer.pal( length( unique( odeg_d_mat ) ), \"Oranges\")[odeg_d_mat]\n\npar( \n  mfrow=c( 1, 2 ), \n  mar=c( 0.1, 0.5, 4, 0.1) \n  )\n\ngplot(\n  d_mat, \n  gmode = \"digraph\", \n  arrowhead.cex = 0.5, \n  edge.col = \"grey40\", \n  label = rownames( d_mat ),\n  label.col = \"red\",\n  label.cex = 0.8,\n  label.pos = 1,\n  vertex.cex = ideg_d_mat+0.2,\n  vertex.col = col_ideg,\n  main = \"Nodes sized &\\n shaded by Indegree\",\n  coord = coords\n  )\n\ngplot(\n  d_mat, \n  gmode = \"digraph\", \n  arrowhead.cex = 0.5, \n  edge.col = \"grey40\", \n  label = rownames( d_mat ),\n  label.col = \"red\",\n  label.cex = 0.8,\n  label.pos = 1,\n  vertex.cex = odeg_d_mat,\n  vertex.col = col_odeg,\n  main = \"Nodes sized &\\n shaded by Outdegree\",\n  coord = coords\n  )\n\n\n\n\n\n\n\n\n\nStandardized degree centrality, mean degree, and centralization\nLet’s calculate the standardized centrality scores for our directed graph:\n\n# unstandardized or raw centrality\nideg_d_mat &lt;- colSums( d_mat )\nodeg_d_mat &lt;- rowSums( d_mat )\n\n# to calculate g-1, we need to know the number of nodes in the graph\n# this is the first dimension of the matrix\ng &lt;- dim( d_mat )[1]\n\n# now, divide by g-1\ns_i_deg_u_mat &lt;- ideg_d_mat / ( g-1 )\ns_o_deg_u_mat &lt;- odeg_d_mat / ( g-1 )\n\nWe can also examine the average degree of the graph using \\(\\frac{\\sum_{i=1}^g C_I(n_i)}{g} = \\frac{\\sum_{i=1}^g C_O(n_i)}{g}\\) or \\(\\frac{L}{g}\\), where L is the number of edges in the graph:\n\nmean_i_deg &lt;- sum( ideg_d_mat ) / dim( d_mat )[1] \nmean_o_deg &lt;- sum( odeg_d_mat ) / dim( d_mat )[1] \nmean_i_deg\n\n[1] 1.6\n\nmean_o_deg\n\n[1] 1.6\n\n# we could also use the mean() function\nmean( ideg_d_mat )\n\n[1] 1.6\n\nmean( odeg_d_mat )\n\n[1] 1.6\n\n\nAgain, following Wasserman and Faust (1994), an index of group indegree/outdegree centralization can be calculated as:\n\\[ C_D = \\frac{\\sum\\limits_{i=1}^g [C_D(n^*) - C_D(n_i)]}{[(g-1)^2]} \\]\nfor undirected graphs where \\(C_D(n^*)\\) is the maximum indegree/outdegree in the graph. We can write out the components of the equation using the max() function:\n\n# In separate pieces\ndeviations &lt;- max( ideg_d_mat ) - ideg_d_mat\nsum_deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-1 )\ngroup_i_deg_cent &lt;- numerator/denominator\ngroup_i_deg_cent\n\n[1] 0.4375\n\ndeviations &lt;- max( odeg_d_mat ) - odeg_d_mat\nsum.deviations &lt;- sum( deviations )\nnumerator &lt;- sum_deviations\ndenominator &lt;- ( g-1 )*( g-1 )\ngroup_o_deg_cent &lt;- numerator/denominator\ngroup_o_deg_cent\n\n[1] 0.4375\n\n# Or, as a single equation\ngroup_i_deg_cent &lt;-( sum( ( ( max( ideg_d_mat ) - ideg_d_mat ) ) ) ) / ( ( g -1 )*( g - 1) )\ngroup_o_deg_cent &lt;-( sum( ( ( max( odeg_d_mat ) - odeg_d_mat ) ) ) ) / ( ( g -1 )*( g - 1 ) )\ngroup_i_deg_cent\n\n[1] 0.4375\n\ngroup_o_deg_cent\n\n[1] 0.125\n\n\nWhat do the centralization scores tell us, conceptually?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-using-the-sna-package",
    "href": "snaca-r-degree-centrality.html#degree-centrality-using-the-sna-package",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality using the sna Package",
    "text": "Degree Centrality using the sna Package\nDid that feel tedious? If no, go back and do it again :)\nAs you probably have guessed, there are functions in the sna package that calculate degree centrality and graph centralization! In the sna package, these are the degree() and centralization() functions, respectively. Let’s take a look at how these work.\n\n# load the library\nlibrary( sna )\n\n# Build the objects to work with\nrm( list = ls() )\n\nu_mat &lt;- rbind( \n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ), \n  c( 0,1,0,1,1 ), \n  c( 0,0,1,0,1 ), \n  c( 0,0,1,1,0 )\n  )\n\nrownames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\ncolnames( u_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ), \n  c( 0,0,0,1,1 ), \n  c( 0,0,1,0,1 ), \n  c( 0,0,1,1,0 )\n  )\n\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n\n# First, let's look at degree\n?degree\n\n# degree for undirected graph\ndeg &lt;- degree( u_mat, gmode=\"graph\" )\n\n# indegree for directed graph\nideg &lt;- degree( d_mat, gmode=\"digraph\", cmode=\"indegree\" )\n\n# outdegree for directed graph\nodeg &lt;- degree( d_mat, gmode=\"digraph\", cmode=\"outdegree\" )\n\n# returns the combined centrality for each node\ndeg_d &lt;- degree( d_mat, gmode=\"digraph\" )\n\n\n# Now, let's look at centralization\n?centralization\n\n# degree centralization for undirected graph\ncent_u &lt;- centralization( u_mat, degree, mode=\"graph\" )\n\n# indegree centralization for directed graph.\ni_cent_d &lt;- centralization( d_mat, degree, mode=\"digraph\", cmode=\"indegree\" ) \n\n# outdegree centralization for directed graph.\no_cent_d &lt;- centralization( d_mat, degree, mode=\"digraph\", cmode=\"outdegree\" )\n\nNow, wasn’t that easier?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#degree-centrality-in-pins-get-along-with-and-powerinfluence-networks",
    "href": "snaca-r-degree-centrality.html#degree-centrality-in-pins-get-along-with-and-powerinfluence-networks",
    "title": "Degree Centrality and Centralization",
    "section": "Degree Centrality in PINS Get Along With and Power/Influence Networks",
    "text": "Degree Centrality in PINS Get Along With and Power/Influence Networks\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collection sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:\n\nThe get along with network was created by asking individuals whom they “get along with” on the unit. We can think of this as “friends” in a prison setting. (People don’t really have “friends” in prison, but there are people they “get along with”)\nThe power and influence network was created by asking individuals whom they believed was “powerful and influential” on the unit.\n\nLet’s examine the degree centrality scores for both of these networks.\n\nGet Along With Network (Undirected Network)\nFor the get along with network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. But, we are going to symmetrize the network by only taking ties for which both i and j indicated that the get along with the other person. This will give us an undirected network.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-getalong-w1-adj.csv\"\n\n# read in the .csv file\nga_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# use the symmetrize() function to create an undirected matrix\nga_mat_u &lt;- symmetrize( ga_mat, rule = \"strong\" )\n\n# create the network object\nga_net_u &lt;- as.network( ga_mat_u, directed = FALSE )\n\nNow we have created an undirected network where ties represent “get along with” nominations from both individuals. Let’s calculate the degree centrality scores, the centralization score, and then use the degree centrality scores to size our nodes in a plot using the vertex.cex() argument in the gplot() function.\n\n\n# Set the coordinates\nset.seed( 507 )\ncoords &lt;- gplot( ga_net_u )\n\nNow lets build the objects and the plot:\n\n# get the degrees.\nga_net_deg &lt;- degree( ga_net_u, gmode=\"graph\" )\n\n# now the centralization score.\nga_net_deg_cent &lt;- centralization( ga_net_u, degree, mode=\"graph\" )\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = ga_net_deg,\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\nWoops! Let’s try that again AFTER rescaling the degree. We can use the rescale() function to do this.\n\n# define the rescale function\nrescale &lt;- function( nchar, low, high ){\n  min_d &lt;- min( nchar )\n  max_d &lt;- max( nchar )\n  rscl  &lt;- ( ( high - low )*( nchar - min_d ) ) / ( max_d - min_d ) + low\n  rscl\n}\n\nNow we can plot it after adding in the rescale() function to gplot():\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = rescale( ga_net_deg, 0.2, 4 ),\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\n\n\n\n\nAlmost there! Let’s drop the isolates to help with the size:\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#3250a8\",\n  vertex.cex = rescale( ga_net_deg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords,\n  main = \"PINS Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by degree centrality\"\n  )\n\n\n\n\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the degree centralization score of 0.04 indicate?\n\n\n\nPower and Influence Network (Directed Network)\nFor the power and influence network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. We will keep this asymmetry so that we can treat the network as directed.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-power-w1-adj.csv\"\n\n# read in the .csv file\npi_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# create the network object\npi_net_d &lt;- as.network( pi_mat, directed = TRUE )\n\nNow we have created an undirected network where ties represent “get along with” nominations from both individuals. Let’s calculate the degree centrality scores, the centralization score, and then use the degree centrality scores to size our nodes in a plot using the vertex.cex() argument in the gplot() function.\n\n# Set the coordinates\nset.seed( 507 )\ncoords2 &lt;- gplot( pi_net_d )\n\n\n# get the degrees.\npi_net_ideg &lt;- degree( pi_net_d, gmode=\"digraph\", cmode = \"indegree\" )\npi_net_odeg &lt;- degree( pi_net_d, gmode=\"digraph\", cmode = \"outdegree\" )\n\n# now the centralization scores.\npi_net_ideg_cent &lt;- centralization( pi_net_d, degree, mode=\"digraph\", cmode = \"indegree\" )\npi_net_odeg_cent &lt;- centralization( pi_net_d, degree, mode=\"digraph\", cmode = \"outdegree\" )\n\n\npar( mfrow=c( 1, 2 ) )\n\ngplot( \n  pi_net_d, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#693859\",\n  vertex.cex = rescale( pi_net_ideg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords2,\n  main = \"PINS Power/Influnece\\n Network (Directed)\",\n  sub = \"node sized by indegree centrality\"\n  )\n\ngplot( \n  pi_net_d, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#2b868c\",\n  vertex.cex = rescale( pi_net_odeg, 0.2, 4 ),\n  displayisolates = FALSE,\n  coord = coords2,\n  main = \"PINS Power/Influnece\\n Network (Directed)\",\n  sub = \"node sized by outdegree centrality\"\n  )\n\n\n\n\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the indegree centralization score of 0.07 indicate?\nWhat does the outdegree centralization score of 0.04 indicate?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#test-your-knowledge-excercises",
    "href": "snaca-r-degree-centrality.html#test-your-knowledge-excercises",
    "title": "Degree Centrality and Centralization",
    "section": "Test Your Knowledge Excercises",
    "text": "Test Your Knowledge Excercises\n\nFor the undirected binary graph u_mat, calculate the degree centrality for each node manually. Verify your results using the colSums() function. What does the degree centrality of each node represent in this network? Which node has the highest degree centrality? Why do you think this is the case?\nIn the example above, nodes were plotted with sizes proportional to their degree centrality. Using the shaded plot, describe the relationship between node size and shade intensity. Which node has the darkest shade? Explain what this represents in terms of degree centrality.\nCalculate the standardized degree centrality for u_mat. How does standardizing degree centrality help in comparing nodes across networks of different sizes?\nCompute the degree centralization for u_mat manually and verify it using the centralization() function. What does the result tell you about the network’s structure?\nFor the directed graph d_mat, compute both indegree and outdegree centrality for each node using colSums() and rowSums(). Plot the graph with nodes sized by indegree and outdegree separately. Which nodes are most central in terms of indegree? What does this imply about their role in the network? Which nodes are most central in terms of outdegree? What does this imply?\nFor the Get Along With network, describe the significance of symmetrizing the network. Interpret the degree centrality scores and the centralization score. What does the structure of this network suggest about relationships in the unit?\nFor the Power/Influence network, compare and contrast the plots sized by indegree and outdegree centrality. What do the indegree and outdegree centralization scores suggest about the distribution of power and influence in the network?\nCompare the degree centralization scores for the undirected Get Along With network and the directed Power/Influence network. Which network is more centralized? How does the type of network (undirected vs. directed) influence the interpretation of centralization?"
  },
  {
    "objectID": "snaca-r-degree-centrality.html#tutorial-summary",
    "href": "snaca-r-degree-centrality.html#tutorial-summary",
    "title": "Degree Centrality and Centralization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced the concept of degree centrality, a measure of node importance based on connectivity within a network, and explores its calculation and visualization for both undirected and directed graphs in R. For undirected graphs, degree centrality is computed using row or column sums, and standardized to account for network size. Directed graphs distinguish between indegree and outdegree centrality, reflecting incoming and outgoing connections, respectively. The tutorial demonstrated graph centralization, highlighting the variability in node centrality within a network. Visualization techniques, including node sizing and shading based on centrality scores, were covered, alongside practical applications using real-world data from the Prison Inmate Networks Study (PINS), where networks like “Get Along With” and “Power/Influence” are analyzed. The use of R’s sna package simplifies centrality calculations and graph plotting, enabling users to gain insights into the structure and dynamics of social networks.\n\n\n\n\nWasserman, Stanley, and Katherine Faust. 1994. Social Network Analysis: Methods and Applications. Vol. 8. Structural Analysis in the Social Sciences. Cambridge, UK: Cambridge University Press."
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#closeness-centrality-undirected-binary-graphs",
    "href": "snaca-r-closeness-centrality.html#closeness-centrality-undirected-binary-graphs",
    "title": "Closeness Centrality and Centralization",
    "section": "Closeness Centrality (Undirected Binary Graphs)",
    "text": "Closeness Centrality (Undirected Binary Graphs)\nHow close is a node to other nodes?\nIn an undirected binary graph, closeness centrality measures how near a node is to the other nodes in the network. This is based on the inverse of the distance of each actor to every other actor.\nTerminology:\n\nThe distance, \\(d(n_i,n_j)\\), is the length of the path between i and j. For example, suppose Sally is friends with Tom, Ulrica, and Violet; Violet is friends with Tom and Walter. What are the paths from Violet to Ulrica? Walter from Ulrica?\nA geodesic is the shortest path between two nodes. What is the shortest path (i.e. geodesic) from Violet to Ulrica?\n\nCloseness centrality is calculated as:\n\\[C_C(n_i) = [\\sum\\limits_{j=1}^g d(n_i,n_j)]^{-1}\\]\nor\n\\[\\frac{1}{[\\sum\\limits_{j=1}^g d(n_i,n_j)]}\\] Here is what the equation is doing:\n\nfirst identify the distances between i and j (i.e. \\(d(n_i,n_j)\\)) and sum them.\nNote that \\(\\sum\\limits_{j=1}^g\\) is indicating that for i, we want to sum over all the js in the graph, g.\nthen take the inverse of this quantity.\n\n\nManually Calculating Closeness Centrality\nWe can manually calculate the distance matrix using the geodist() function in the sna package. Let’s take a look:\n\n# now, take a look at the geodist() function\n?geodist\n\nLet’s go ahead and set up a simple matrix and examine the geodesics for that matrix.\n\n# set up the matrix\nu_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ),\n  c( 0,1,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ))\n\n# now set the names\nmat_names &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\nrownames( u_mat ) &lt;- mat_names\ncolnames( u_mat ) &lt;- mat_names\n\n# let's look at what the geodist() function creates\nu_mat_geodist &lt;- geodist( u_mat )\nclass( u_mat_geodist )\n\n[1] \"list\"\n\nu_mat_geodist\n\n$counts\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    1    1    1    1\n[2,]    1    1    1    1    1\n[3,]    1    1    1    1    1\n[4,]    1    1    1    1    1\n[5,]    1    1    1    1    1\n\n$gdist\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]    1    0    1    2    2\n[3,]    2    1    0    1    1\n[4,]    3    2    1    0    1\n[5,]    3    2    1    1    0\n\n\nWe can see that the function creates an object of class list. In the object, there are two arrays, $counts and $gdist. The $counts array is a matrix containing the number of geodesics between each pair of vertices. The $gdist array is a matrix containing the geodesic distances between each pair of vertices.\nTo get the geodesic distances, we use the $ sign to select a single array from the list:\n\n# print out the distances\nu_mat_geodist$gdist\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]    1    0    1    2    2\n[3,]    2    1    0    1    1\n[4,]    3    2    1    0    1\n[5,]    3    2    1    1    0\n\n# if we take the row sum of this object, we get the distances\ndistance &lt;- rowSums( u_mat_geodist$gdist )\ndistance\n\n[1] 9 6 5 7 7\n\n\nNow, let’s plot the graph so we can visualize what the distance score is showing. To make it easier to see, let’s add the centrality info to the labels and size the nodes by centrality. That will make it easier to visualize.\n\n# create a vector of labels that combines the name with the distances\n# use the paste() function to put characters and numbers together\nnames_dist &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( distance, 0 ), # add the rounded distance\n  sep = \"\" ) # remove the space between the two inputs \n\n# change the margins using the mar= argument\npar( mar=c( 0.1, 0.5, 1, 0.1 ) )\n\n# set the seed to reproduce the same layout\nset.seed( 507 )\n\n# render the plot\ngplot( \n  u_mat,\n  gmode = \"graph\",\n  label = names_dist,\n  label.cex = 0.6,\n  vertex.col = \"lightblue\"\n  )\n\n\n\n\nIn this plot, we see that Jen has a distance score of 9. (She is so far away!) To see how we get that score, let’s do the calculation:\n\nrecall that \\(d(n_i,n_j)\\) is the length of the path from i to j\n\nJen -&gt; Tom (\\(d(Jen,Tom)\\)) is 1\nJen -&gt; Bob (\\(d(Jen,Bob)\\)) is 2\nJen -&gt; Leaf (\\(d(Jen,Leaf)\\)) and Jen -&gt; Jim (\\(d(Jen,Jim)\\)) are both 3\nSo that is \\(\\sum\\limits_{Jen}^g d(Jen,Tom/Bob/Leaf/Jim) = 1+2+3+3=9\\).\n\n\nTo get the closeness centrality score, we divide that quantity by 1.\n\n# take the reciprocal\nclose_cent &lt;- 1 / rowSums( u_mat_geodist$gdist )\nclose_cent\n\n[1] 0.1111111 0.1666667 0.2000000 0.1428571 0.1428571\n\n# we can calculate the standardized closeness centrality by multiplying by g-1\ng &lt;- dim( u_mat )[1]\nclose_cent_s &lt;- ( g-1 ) * close_cent\nclose_cent_s\n\n[1] 0.4444444 0.6666667 0.8000000 0.5714286 0.5714286\n\n# put it all together in a table\ndist_close_table &lt;- round( rbind( distance, close_cent, close_cent_s ), 2 )\nrownames( dist_close_table ) &lt;- c( \"distance\", \"closeness\", \"stand.close\" )\ncolnames( dist_close_table ) &lt;- mat_names\ndist_close_table\n\n             Jen  Tom Bob Leaf  Jim\ndistance    9.00 6.00 5.0 7.00 7.00\ncloseness   0.11 0.17 0.2 0.14 0.14\nstand.close 0.44 0.67 0.8 0.57 0.57\n\n\nNow, let’s take a look at this info in a series of plots. To render these, let’s use a for loop:\n\nnames_close &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( close_cent, 2 ), # add the rounded closeness centrality score\n  sep = \"\" ) # remove the space between the two inputs \n\nnames_s_close &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( close_cent_s, 2 ), # add the rounded closeness centrality score\n  sep = \"\" ) # remove the space between the two inputs \n\n# create the inputs for the loop\ntitles &lt;- c( \"Distance\", \"Closeness\", \"Standardized Closeness\")\ncols &lt;- c( \"lightblue\", \"lightgreen\", \"orange\" )\nnames &lt;- rbind( names_dist, names_close, names_s_close )\n\n# change the margins using the mar= argument\npar( \n  mfrow=c( 2,2 ),\n  mar=c( 0.1, 0.5, 1, 0.1 ) \n  )\n\nfor( i in 1:3 ){\n  \n  # set the seed\n  set.seed( 507 )\n\n  # render the plot\n  gplot( \n  u_mat,\n  gmode = \"graph\",\n  label = names[i,],\n  label.cex = 0.6,\n  vertex.col = cols[i],\n  main = titles[i]\n  )\n\n}\n\n\n\n\n\n\nUsing the sna Package\nAlternatively, we could just use the closeness() function in the sna package. First, take a look at the function using ?closeness. Note that the standardized closeness centrality is reported by default. If we want the unstandardized closeness, we can just divide the result returned by closeness() by g-1.\n\n# standardized\ncloseness( u_mat,gmode=\"graph\")\n\n[1] 0.4444444 0.6666667 0.8000000 0.5714286 0.5714286\n\n# raw\ncloseness( u_mat,gmode=\"graph\" ) / ( g-1 )\n\n[1] 0.1111111 0.1666667 0.2000000 0.1428571 0.1428571\n\n\n\n\nCloseness Centralization\nWe can also summarize the entire network, in terms of how close nodes are to each other. Group closeness centralization tells us how much variation there is in the closeness scores. As we saw in the textbook chapters on Degree Centrality and Closeness Centrality, this measure is bound between 0 and 1 where a value of 0 indicates complete uniformity across nodes in there centrality scores and a value of 1 indicates that one node has the highest possible centrality score, and all others are at the minimum.\nThis is calculated as: \\(C_C = \\frac{\\sum\\limits_{i=1}^g[C'_C(n^*)-C'_C(n_i)]}{[(g-2)(g-1)]/(2g-3)}\\).\nWhere \\(C'_C(n^*)\\) is the maximum or largest standardized closeness centrality score. For a more elaborate discussion of this equation, see (Wasserman and Faust 1994, 8:191–92). To calculate the group closeness centrality, we can use the centralization() function in sna and specify closeness in the FUN argument.\n\n?centralization\n\ncentralization( u_mat, closeness, mode=\"graph\" )\n\n[1] 0.5518519\n\n\nWhat does the centralization score of 0.55 tell us?"
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#closeness-centrality-directed-binary-graphs",
    "href": "snaca-r-closeness-centrality.html#closeness-centrality-directed-binary-graphs",
    "title": "Closeness Centrality and Centralization",
    "section": "Closeness Centrality (Directed Binary Graphs)",
    "text": "Closeness Centrality (Directed Binary Graphs)\nIn a directed binary graph, closeness centrality has the same interpretation (i.e. it is the inverse of the average distance between nodes), but it takes into account the directional nature of the graph.\nFor example, consider two scenarios:\n\nSuppose Laura sends a tie to Miguel and he sends a tie to Bruce (i.e. Laura -&gt; Miguel -&gt; Bruce). Here, Laura is of distance 2 from Bruce.\nNow suppose Laura sends a tie to Miguel and Bruce sends a tie to Miguel (i.e. Laura -&gt; Miguel &lt;- Bruce).\nHow far is Laura from Bruce now?\n\nLet’s take a look at this using the network from the Closeness Centrality chapter.\n\n# Build the object\nd_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 0,0,1,0,0 ),\n  c( 0,0,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 )\n  )\n\n# name the rows and columns\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\n# define g\ng &lt;- dim( d_mat )[1]\n\n\nManually Calculating Closeness Centrality\nWe can manually calculate the distance matrix using the geodist() function in the sna package as we did above.\n\n# calculate distances\ndistances &lt;- geodist( d_mat )\n\n# get the geodesics\ngeodesics &lt;- distances$gdist\n\n# take a look\ngeodesics\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]  Inf    0    1    2    2\n[3,]  Inf  Inf    0    1    1\n[4,]  Inf  Inf    1    0    1\n[5,]  Inf  Inf    1    1    0\n\n\nSomething look different?\nLet’s recode those Inf values to be zero and chug on.\n\n# code Inf values as zero\ngeodesics[geodesics == Inf] &lt;- 0 \n\n# take a look now\ngeodesics\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    2    3    3\n[2,]    0    0    1    2    2\n[3,]    0    0    0    1    1\n[4,]    0    0    1    0    1\n[5,]    0    0    1    1    0\n\n\n\n# unstandardized closeness\n1/rowSums( geodesics ) \n\n[1] 0.1111111 0.2000000 0.5000000 0.5000000 0.5000000\n\n# standardized closeness\n( 1/rowSums( geodesics ) ) * ( g - 1 )\n\n[1] 0.4444444 0.8000000 2.0000000 2.0000000 2.0000000\n\n\n\n\nUsing the sna Package\nAlternatively, we could (again) just use the closeness() function in the sna package. Remember that the standardized closeness centrality is reported by default. If we want the unstandardized closeness, we can just divide the result returned by closeness() by g-1.\n\n# standardized closeness\ncloseness( d_mat, gmode=\"digraph\" )\n\n[1] 0.4444444 0.0000000 0.0000000 0.0000000 0.0000000\n\n# unstandardized closeness\ncloseness( d_mat, gmode=\"digraph\" ) / ( g-1 )\n\n[1] 0.1111111 0.0000000 0.0000000 0.0000000 0.0000000\n\n\n\n\nCloseness Centralization\nAs discussed in (Wasserman and Faust 1994, 8:200–201), the denominator is not defined for closeness centralization for directed graphs. Yet, score can be computed using the centralization() function.\n\ncentralization( d_mat, closeness, mode=\"digraph\" )\n\n[1] 0.5555556\n\n\nWhat does the centralization score of 0.56 tell us?"
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#closeness-centrality-in-pins-get-along-with-network",
    "href": "snaca-r-closeness-centrality.html#closeness-centrality-in-pins-get-along-with-network",
    "title": "Closeness Centrality and Centralization",
    "section": "Closeness Centrality in PINS Get Along With Network",
    "text": "Closeness Centrality in PINS Get Along With Network\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collection sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:\n\nThe get along with network was created by asking individuals whom they “get along with” on the unit. We can think of this as “friends” in a prison setting. (People don’t really have “friends” in prison, but there are people they “get along with”)\nThe power and influence network was created by asking individuals whom they believed was “powerful and influential” on the unit.\n\nLet’s examine the closeness centrality scores for both of these networks.\n\nGet Along with Network (Undirected Network)\nFor the get along with network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. But, we are going to symmetrize the network by only taking ties for which both i and j indicated that the get along with the other person. This will give us an undirected network.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-getalong-w1-adj.csv\"\n\n# read in the .csv file\nga_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# use the symmetrize() function to create an undirected matrix\nga_mat_u &lt;- symmetrize( ga_mat, rule = \"strong\" )\n\n# create the network object\nga_net_u &lt;- as.network( ga_mat_u, directed = FALSE )\n\n\nNow, we have created an undirected network where ties represent “get along with” nominations from both individuals.\nBefore we calculate the closeness scores, recall that in a graph with multiple components (i.e. disconnected subgraphs) individuals who cannot be reached will have a closeness score of zero. So, what do we do? Call it a day and go home? (We could, but we have some options)\nWhat often happens in practice when we have multiple components in a network is that researchers will take the “first component” and analyze the closeness scores for that graph. The first component is the largest subgraph in a graph. We can see this visually in the following plot:\n\n\n\n\n\nIn the plot above, the first component (i.e. the largest subgraph) is colored green. To get the closeness centrality scores, we can use a function called get.inducedSubgraph() in the sna package to extract a subgraph that meets a condition. In this case, we want to take those cases who are in the first component. Let’s walk through the pieces.\n\n# find the component membership\ncd &lt;- component.dist( as.matrix( ga_net_u ), connected=\"weak\" )\n\n# find which component is the largest\nsort( table( cd$membership ) )\n\n\n  1   2   3   5   6   7   8   9  10  12  13  14  16  17  19  20  21  22  23  25 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 26  27  29  30  31  32  33  34  35  36  38  40  41  42  43  44  45  47  49  50 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 51  52  53  55  56  58  60  61  63  64  65  66  67  68  69  70  71  73  74  76 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112 114 115 116 117 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n119 120 121 122 123 124 125 126 127 128 129  18  28  39  46  48  57  59  75 113 \n  1   1   1   1   1   1   1   1   1   1   1   2   2   2   2   2   2   2   2   2 \n118  15  37  54  72  11  24  62   4 \n  2   3   3   3   3   4   4   4  50 \n\n# we can see that group number 4 is the largest group. This is the first component.\n# so, we can assign the membership in the first component\nfirst_comp &lt;- cd$membership\nfirst_comp[ cd$membership != 4 ] &lt;- 0\nfirst_comp[ cd$membership == 4 ] &lt;- 1\n\n# now we set this as a network attribute\nga_net_u %v% \"first_comp\" &lt;- first_comp\n\n# Now, remove those not in the first component by using the get.inducedSubgraph() function.\n# Specifically, we stipulate in the v= argument that we only want vertices that are in the first component.\nga_net_ucomp &lt;- get.inducedSubgraph( \n  ga_net_u, # the network                 \n  v = which( ga_net_u %v% \"first_comp\" == 1 )  # the condition\n  )\n\n# Now, take a look at the plot.\ngplot( \n  ga_net_ucomp, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#9cde18\", \n  main = \"First Component of Get\\n Along With Network (Undirected)\" )\n\n\n\n\nNow, let’s calculate our closeness scores:\n\n# get the number of nodes\nn_nodes &lt;- dim( as.matrix( ga_net_ucomp ) )[1]\n\n# unstandardized closeness\ncloseness( ga_net_ucomp, gmode=\"graph\" ) / ( n_nodes - 1 )\n\n [1] 0.003533569 0.004545455 0.005524862 0.004854369 0.003039514 0.004184100\n [7] 0.005208333 0.005681818 0.005917160 0.004608295 0.004524887 0.004975124\n[13] 0.005076142 0.004545455 0.005102041 0.004629630 0.005128205 0.003584229\n[19] 0.004651163 0.005025126 0.003745318 0.003184713 0.004464286 0.002652520\n[25] 0.004219409 0.004629630 0.003021148 0.004975124 0.003759398 0.003076923\n[31] 0.005813953 0.003802281 0.005076142 0.004166667 0.003891051 0.003690037\n[37] 0.005405405 0.004484305 0.002680965 0.003496503 0.004629630 0.004000000\n[43] 0.003745318 0.006535948 0.005714286 0.004566210 0.005681818 0.004149378\n[49] 0.003058104 0.004032258\n\n# standardized closeness\ncloseness( ga_net_ucomp, gmode=\"graph\" ) \n\n [1] 0.1731449 0.2227273 0.2707182 0.2378641 0.1489362 0.2050209 0.2552083\n [8] 0.2784091 0.2899408 0.2258065 0.2217195 0.2437811 0.2487310 0.2227273\n[15] 0.2500000 0.2268519 0.2512821 0.1756272 0.2279070 0.2462312 0.1835206\n[22] 0.1560510 0.2187500 0.1299735 0.2067511 0.2268519 0.1480363 0.2437811\n[29] 0.1842105 0.1507692 0.2848837 0.1863118 0.2487310 0.2041667 0.1906615\n[36] 0.1808118 0.2648649 0.2197309 0.1313673 0.1713287 0.2268519 0.1960000\n[43] 0.1835206 0.3202614 0.2800000 0.2237443 0.2784091 0.2033195 0.1498471\n[50] 0.1975806\n\n# Group Closeness Centralization.\ncentralization( ga_net_ucomp, closeness, mode=\"graph\" )\n\n[1] 0.214429\n\n\n\n# define the rescale function\nrescale &lt;- function( nchar, low, high ){\n  min_d &lt;- min( nchar )\n  max_d &lt;- max( nchar )\n  rscl  &lt;- ( ( high - low )*( nchar - min_d ) ) / ( max_d - min_d ) + low\n  rscl\n}\n\n\n# now, take a look at the plot\ngplot( \n  ga_net_ucomp, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#9cde18\",\n  vertex.cex = rescale( closeness( ga_net_ucomp, gmode=\"graph\" ), 0.4, 3 ),\n  main = \"First Component of Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by closeness centrality\"\n  )\n\n\n\n\n\n\nPower and Influence Network (Directed Network)\nFor the power and influence network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. We will keep this asymmetry so that we can treat the network as directed.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-power-w1-adj.csv\"\n\n# read in the .csv file\npi_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# create the network object\npi_net_d &lt;- as.network( pi_mat, directed = TRUE )\n\nNow, we have created a directed network where ties represent “power and influence” nominations from i to j.\nAs before, we need to extract the first component:\n\n\n\n\n\nIn the plot above, the first component (i.e. the largest subgraph) is shown in red. Now, let’s again use the get.inducedSubgraph() function in the sna package to extract a subgraph that meets the first component condition.\n\n# find the component membership\ncd &lt;- component.dist( as.matrix( pi_net_d ), connected=\"weak\" )\n\n# find which component is the largest\nsort( table( cd$membership ) )\n\n\n  2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 22  23  24  25  26  27  28  29  30  31  32  33  34  36  37  38  39  40  41  42 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 63  64  65  66  67  68  69  71  72  73  74  75  76  77  78  79  80  81  82  83 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n104 105 106 107 108  35  70   1 \n  1   1   1   1   1   2   3  95 \n\n# we can see that group number 1 is the largest group. This is the first component.\n# so, we can assign the membership in the first component\nfirst_comp &lt;- cd$membership\nfirst_comp[ cd$membership != 1 ] &lt;- 0\nfirst_comp[ cd$membership == 1 ] &lt;- 1\n\n# now we set this as a network attribute\npi_net_d %v% \"first_comp\" &lt;- first_comp\n\n# Now, remove those not in the first component by using the get.inducedSubgraph() function.\n# Specifically, we stipulate in the v= argument that we only want vertices that are in the first component.\npi_net_d_comp &lt;- get.inducedSubgraph( \n  pi_net_d, # the network                 \n  v = which( pi_net_d %v% \"first_comp\" == 1 )  # the condition\n  )\n\n# Now, take a look at the plot\ngplot( \n  pi_net_d_comp, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ab163b\", \n  main = \"First Component of Power\\n Network (Directed)\" )\n\n\n\n\nNow, let’s calculate our closeness scores. Note a slight change though. In the closeness() function, there is the gmode= argument where we specify whether the graph is directed (i.e. \"digraph\" or undirected \"graph\". If we use gmode = \"digraph\" we will get all zeros because it is using the directionality of the network. For our purposes here, we will set it to gmode = \"graph\" so we can actually get values:\n\n# get the number of nodes\nn_nodes &lt;- dim( as.matrix( pi_net_d_comp ) )[1]\n\n#unstandardized closeness\ncloseness( pi_net_d_comp, gmode=\"graph\" ) / ( n_nodes - 1 ) \n\n [1] 0.003367003 0.003891051 0.002857143 0.002824859 0.003311258 0.002531646\n [7] 0.003215434 0.002652520 0.002932551 0.002544529 0.002941176 0.002958580\n[13] 0.002531646 0.003831418 0.003215434 0.001754386 0.002659574 0.002666667\n[19] 0.003968254 0.003154574 0.002439024 0.002659574 0.003030303 0.002881844\n[25] 0.002793296 0.002994012 0.002985075 0.002237136 0.003311258 0.003571429\n[31] 0.002617801 0.004149378 0.002994012 0.003802281 0.003448276 0.002824859\n[37] 0.002881844 0.002127660 0.002604167 0.002331002 0.003289474 0.003030303\n[43] 0.002127660 0.003436426 0.003174603 0.002217295 0.002770083 0.002857143\n[49] 0.002531646 0.003205128 0.002985075 0.003436426 0.002237136 0.003649635\n[55] 0.002881844 0.003816794 0.002531646 0.002793296 0.003546099 0.002336449\n[61] 0.002570694 0.001754386 0.003460208 0.002976190 0.002898551 0.002217295\n[67] 0.002320186 0.002092050 0.003460208 0.003484321 0.003076923 0.003937008\n[73] 0.003389831 0.002341920 0.004048583 0.003745318 0.003533569 0.003984064\n[79] 0.002976190 0.002127660 0.002881844 0.002392344 0.002531646 0.002433090\n[85] 0.002057613 0.002985075 0.002824859 0.004132231 0.003436426 0.002985075\n[91] 0.002564103 0.003058104 0.002777778 0.002857143 0.003472222\n\n#standardized closeness\ncloseness( pi_net_d_comp, gmode=\"graph\" ) \n\n [1] 0.3164983 0.3657588 0.2685714 0.2655367 0.3112583 0.2379747 0.3022508\n [8] 0.2493369 0.2756598 0.2391858 0.2764706 0.2781065 0.2379747 0.3601533\n[15] 0.3022508 0.1649123 0.2500000 0.2506667 0.3730159 0.2965300 0.2292683\n[22] 0.2500000 0.2848485 0.2708934 0.2625698 0.2814371 0.2805970 0.2102908\n[29] 0.3112583 0.3357143 0.2460733 0.3900415 0.2814371 0.3574144 0.3241379\n[36] 0.2655367 0.2708934 0.2000000 0.2447917 0.2191142 0.3092105 0.2848485\n[43] 0.2000000 0.3230241 0.2984127 0.2084257 0.2603878 0.2685714 0.2379747\n[50] 0.3012821 0.2805970 0.3230241 0.2102908 0.3430657 0.2708934 0.3587786\n[57] 0.2379747 0.2625698 0.3333333 0.2196262 0.2416452 0.1649123 0.3252595\n[64] 0.2797619 0.2724638 0.2084257 0.2180974 0.1966527 0.3252595 0.3275261\n[71] 0.2892308 0.3700787 0.3186441 0.2201405 0.3805668 0.3520599 0.3321555\n[78] 0.3745020 0.2797619 0.2000000 0.2708934 0.2248804 0.2379747 0.2287105\n[85] 0.1934156 0.2805970 0.2655367 0.3884298 0.3230241 0.2805970 0.2410256\n[92] 0.2874618 0.2611111 0.2685714 0.3263889\n\n# Group Closeness Centralization\ncentralization( pi_net_d_comp, closeness, mode=\"graph\" )\n\n[1] 0.2273318\n\n# Now, take a look at the plot\ngplot( \n  pi_net_d_comp, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ab163b\",\n  vertex.cex = rescale( closeness( pi_net_d_comp, gmode=\"graph\" ), 0.4, 3 ),\n  main = \"First Component of Power\\n Network (Directed)\",\n  sub = \"node sized by closeness centrality\"\n  )\n\n\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the closeness centralization score of 0.23 indicate?"
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#test-your-knowledge-excercises",
    "href": "snaca-r-closeness-centrality.html#test-your-knowledge-excercises",
    "title": "Closeness Centrality and Centralization",
    "section": "Test Your Knowledge Excercises",
    "text": "Test Your Knowledge Excercises\n\nExplain the concept of closeness centrality in your own words. How does it differ from degree centrality?\nUsing the u_mat matrix in the tutorial, manually calculate the closeness centrality for the node “Jen.” Show your calculations step by step.\nUsing the “Get Along With” network, identify why only the largest component is analyzed for closeness centrality. What are the potential consequences of ignoring smaller components?\nIn the “Power and Influence Network,” why do we adjust the gmode argument when calculating closeness centrality? What are the implications of analyzing a directed network as undirected?\nFor both the “Get Along With” and “Power and Influence” networks, calculate the standardized closeness centrality for a specific node of your choice. Compare the results between the two networks.\nInterpret the group closeness centralization score for the “Get Along With” network. What does this score reveal about the structure of the network?\nExplain why Inf values appear in the geodesic distance matrix for directed graphs and how these values are handled during calculations.\nUsing the “Power and Influence Network,” examine the visual representation of the first component. What structural patterns do you observe, and how do these relate to the closeness centrality scores?\nAfter calculating the closeness centralization scores for both networks, compare their values. What do the differences in scores suggest about the overall structure of the two networks?"
  },
  {
    "objectID": "snaca-r-closeness-centrality.html#tutorial-summary",
    "href": "snaca-r-closeness-centrality.html#tutorial-summary",
    "title": "Closeness Centrality and Centralization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial provided an introduction to calculating closeness centrality and centralization in network analysis using R. It begins by explaining the theoretical foundation of closeness centrality, emphasizing its distinction from degree centrality by focusing on the inverse of the average distance between nodes. The tutorial demonstrates how to manually compute closeness centrality using the geodist() function from the sna package and visualize results through network plots. It covered both undirected and directed graphs, highlighting the nuances of analyzing asymmetric relationships and handling disconnected components. Additionally, the tutorial introduced the concept of group closeness centralization, which measures the variability in closeness scores across the network, and explains how to compute it using the centralization() function. Real-world examples, such as the “Get Along With” and “Power and Influence” networks from the Prison Inmate Networks Study (PINS), illustrate the practical application of these metrics.\n\n\n\n\nWasserman, Stanley, and Katherine Faust. 1994. Social Network Analysis: Methods and Applications. Vol. 8. Structural Analysis in the Social Sciences. Cambridge, UK: Cambridge University Press."
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#betweenness-centrality-undirected-binary-graphs",
    "href": "snaca-r-betweenness-centrality.html#betweenness-centrality-undirected-binary-graphs",
    "title": "Betweenness Centrality and Centralization",
    "section": "Betweenness Centrality (Undirected Binary Graphs)",
    "text": "Betweenness Centrality (Undirected Binary Graphs)\nBetweenness centrality is based on the number of shortest paths between j and k that actor i resides on.\nBetweenness centrality is calculated as:\n\\[C_B(n_i) = \\sum\\limits_{j&lt;k} g_{jk}(n_i) / g_{jk}\\]\nWhere \\(g_{jk}\\) represents the number of geodesics linking j to k and \\(g_{jk}(n_i)\\) is the number of geodesics linking j and k that contain i. So, betweenness centrality is the ratio of the geodesics between j and k that contain i to the geodesics between j and k that do not contain i.\nThe standardized betweenness centrality score is calculated by:\n\\[C'_B(n_i) = \\frac{\\sum\\limits_{j&lt;k} g_{jk}(n_i) / g_{jk}}{[(g-1)(g-2)/2]}\\]\nThe difference here is that we are dividing by \\((g-1)(g-2)/2\\) which is the number of pairs of actors not including i.\n\nUsing the sna Package\nLet’s go ahead and set up a simple matrix and see how we use can calculate betweenness centrality using the betweenness() function in the sna package:\n\n# set up the matrix\nu_mat &lt;- rbind(\n  c( 0,1,0,0,0 ),\n  c( 1,0,1,0,0 ),\n  c( 0,1,0,1,1 ),\n  c( 0,0,1,0,1 ),\n  c( 0,0,1,1,0 ))\n\n# now set the names\nmat_names &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\nrownames( u_mat ) &lt;- mat_names\ncolnames( u_mat ) &lt;- mat_names\n\n# define the number of nodes in the graph\ng &lt;- dim( u_mat )[1]\n\nNow, let’s take a look at the betweenness() function:\n\n?betweenness\n\n# raw\nbetweenness( u_mat, gmode=\"graph\" )\n\n[1] 0 3 4 0 0\n\n# standardized\nbetweenness( u_mat, gmode=\"graph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n[1] 0.0000000 0.5000000 0.6666667 0.0000000 0.0000000\n\n\nNow, let’s plot the graph so we can visualize what the betweenness score is showing. To make it easier to see, let’s add the betweenness centrality info to the labels and size the nodes by betweenness centrality. That will make it easier to visualize.\n\n# create an object that is the scores\nnode_betweenness &lt;- betweenness( u_mat,gmode=\"graph\" )\n\n# create a vector of labels that combines the name with the betweeness scores\n# use the paste() function to put characters and numbers together\nnames_between &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( node_betweenness, 0 ), # add the rounded distance\n  sep = \"\" ) # remove the space between the two inputs \n\n# set the seed to reproduce the same layout\nset.seed( 507 )\n\n# render the plot\ngplot( \n  u_mat,\n  gmode = \"graph\",\n  label = names_between,\n  label.cex = 0.6,\n  vertex.col = \"lightblue\"\n  )\n\n\n\n\nIn this plot, we see that Tom and Bob both have scores of 3 and 4, respectively, whereas Jen, Leaf, and Jim have scores of 0. Why do Jen, Leaf, and Jim have scores of 0? Because nobody has to go “between” them to reach other nodes.\n\n\nBetweenness Centralization\nWe can also summarize the entire network, in terms of betweenness. Group betweenness centralization tells us how much variation there is in the betweenness scores. As we saw in the chapters on Degree Centrality and Closeness Centrality, this measure is bound between 0 and 1 where a value of 0 indicates complete uniformity across nodes in their centrality scores and a value of 1 indicates that one node has the highest possible centrality score, and all others are at the minimum.\nFor betweenness centrality, this is calculated as:\n\\[C_B = \\frac{\\sum\\limits_{i=1}^g[C'_B(n^*)-C'_B(n_i)]}{(g-1)}\\]\nWhere \\(C'_B(n^*)\\) is the maximum or largest standardized betweenness centrality score. To calculate the group betweenness centrality, we can use the centralization() function in sna and specify betweenness in the FUN argument.\n\n?centralization\n\ncentralization( u_mat, betweenness, mode=\"graph\" )\n\n[1] 0.5416667\n\n\nWhat does the centralization score of 0.54 tell us?"
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#betweenness-centrality-directed-binary-graphs",
    "href": "snaca-r-betweenness-centrality.html#betweenness-centrality-directed-binary-graphs",
    "title": "Betweenness Centrality and Centralization",
    "section": "Betweenness Centrality (Directed Binary Graphs)",
    "text": "Betweenness Centrality (Directed Binary Graphs)\nAs with undirected graphs, we can calculate betweenness centrality scores for directed graphs. In a directed binary graph, betweenness centrality has the same interpretation, but it takes into account the directional nature of the graph.\nFor example, consider two scenarios:\n\nSuppose Laura sends a tie to Miguel and he sends a tie to Bruce (i.e. Laura -&gt; Miguel -&gt; Bruce). Here, Miguel is between Laura and Bruce and has a betweeness score of 1.\nNow suppose Laura sends a tie to Miguel and Bruce sends a tie to Miguel (i.e. Laura -&gt; Miguel &lt;- Bruce).\nIs Miguel between Laura and Bruce now?\n\nLet’s take a look at this using the network from the Betweenness Centrality chapter.\n\n# build the matrix\nd_mat &lt;- rbind(\n  c(0,1,0,0,0),\n  c(0,0,1,0,0),\n  c(0,0,0,1,1),\n  c(0,0,1,0,1),\n  c(0,0,1,1,0)\n  )\n\n# attach the names\nrownames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\ncolnames( d_mat ) &lt;- c( \"Jen\",\"Tom\",\"Bob\",\"Leaf\",\"Jim\" )\n\nNow, let’s use the same code we used above to calculate the betweenness centrality scores. Note, however, that we have to change the gmode= argument in the betweenness() and centralization() functions to be digraph since the graph is directed and we want to include the information on directionality in the calculations (recall that for undirected graphs we use graph).\n\n# define the number of nodes in the graph for our calculation\ng &lt;- dim( d_mat )[1]\n\n# unstandardized\nbetweenness( d_mat, gmode=\"digraph\" )\n\n[1] 0 3 4 0 0\n\n# standardized\nbetweenness( d_mat, gmode=\"digraph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n[1] 0.0000000 0.5000000 0.6666667 0.0000000 0.0000000\n\n\nLet’s plot this to better visualize the scores:\n\n# create an object that is the scores\nnode_betweenness &lt;- betweenness( d_mat, gmode=\"digraph\" )\n\n# create a vector of labels that combines the name with the betweeness scores\n# use the paste() function to put characters and numbers together\nnames_between &lt;- paste( \n  mat_names, # the names of the vertices\n  \", \", # add a comma to separate name from degree\n  round( node_betweenness, 0 ), # add the rounded distance\n  sep = \"\" ) # remove the space between the two inputs \n\n# set the seed to reproduce the same layout\nset.seed( 507 )\n\n# render the plot\ngplot( \n  d_mat,\n  gmode = \"digraph\",\n  label = names_between,\n  label.cex = 0.6,\n  arrowhead.cex = 0.5,\n  vertex.col = \"#2e5087\"\n  )\n\n\n\n\nFinally, let’s examine the betweenness centralization score:\n\n# Group Betweenness Centralization.\ncentralization( d_mat, betweenness, mode=\"digraph\" ) \n\n[1] 0.2708333\n\n\nWhat does the centralization score of 0.27 tell us?\nCompare the centralization score of 0.54 for the undirected graph above and the centralization score of 0.27 for the directed graph we just calculated.\nBonus question: Which one is larger? What does the difference in the values mean in terms of how betweenness scores are distributed in the graph?"
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#betweenness-centrality-in-pins-get-along-with-network",
    "href": "snaca-r-betweenness-centrality.html#betweenness-centrality-in-pins-get-along-with-network",
    "title": "Betweenness Centrality and Centralization",
    "section": "Betweenness Centrality in PINS Get Along With Network",
    "text": "Betweenness Centrality in PINS Get Along With Network\nThe Prison Inmate Networks Study (PINS) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collection sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:\n\nThe get along with network was created by asking individuals whom they “get along with” on the unit. We can think of this as “friends” in a prison setting. (People don’t really have “friends” in prison, but there are people they “get along with”)\nThe power and influence network was created by asking individuals whom they believed was “powerful and influential” on the unit.\n\nLet’s examine the betweenness centrality scores for both of these networks.\n\nGet Along with Network (Undirected Network)\nFor the get along with network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. But, we are going to symmetrize the network by only taking ties for which both i and j indicated that the get along with the other person. This will give us an undirected network.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-getalong-w1-adj.csv\"\n\n# read in the .csv file\nga_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# use the symmetrize() function to create an undirected matrix\nga_mat_u &lt;- symmetrize( ga_mat, rule = \"strong\" )\n\nNow, let’s calculate our betweenness scores:\n\n# define the number of nodes in the graph for our calculation\ng &lt;- dim( ga_mat_u )[1]\n\n# unstandardized\nbetweenness( ga_mat_u, gmode=\"graph\" )\n\n  [1]   0.000000   0.000000   0.000000 140.000000   0.000000   0.000000\n  [7]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [13]  94.000000   0.000000   0.000000   0.000000 291.866667   0.000000\n [19]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [25]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [31]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [37]   0.000000   0.000000   0.000000 242.666667  48.000000  86.216667\n [43] 209.966667   1.000000   0.000000 237.333333 335.366667   0.000000\n [49]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [55]   0.000000  27.200000   0.000000   0.000000   0.000000   0.000000\n [61]   0.000000  51.516667   0.000000   0.000000   0.000000   0.000000\n [67]  19.166667  16.700000 140.000000 141.150000   0.000000   0.000000\n [73]   0.000000   0.000000   0.000000   0.000000   1.000000   0.000000\n [79]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n [85]   0.000000   2.000000   0.000000   0.000000   0.000000   0.000000\n [91]   0.000000   0.000000   0.000000   0.000000 180.000000   4.033333\n [97]   0.000000   0.000000   0.000000   3.000000   0.000000  48.000000\n[103]   0.000000  48.000000   0.000000   0.000000   0.000000 272.200000\n[109]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[115]   0.000000   0.000000   0.000000   0.000000   2.000000   0.000000\n[121]   0.000000 358.733333   0.000000   0.000000  26.166667   0.000000\n[127]   3.983333   0.000000  39.200000   0.000000   0.000000   0.000000\n[133]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[139]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[145]   0.000000   0.000000   0.000000  19.166667   0.000000   0.000000\n[151]  11.000000   0.000000   0.000000   0.000000 681.733333   0.000000\n[157]   0.000000 302.000000   0.000000   0.000000   0.000000  95.000000\n[163] 343.966667   0.000000   0.000000 184.666667   0.000000   0.000000\n[169]   0.000000   0.000000   0.000000   0.000000   0.000000   2.000000\n[175]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[181]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[187]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[193]   1.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[199]   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000\n[205]   0.000000\n\n# standardized\nbetweenness( ga_mat_u, gmode=\"graph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n  [1] 0.000000e+00 0.000000e+00 0.000000e+00 6.761325e-03 0.000000e+00\n  [6] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [11] 0.000000e+00 0.000000e+00 4.539747e-03 0.000000e+00 0.000000e+00\n [16] 0.000000e+00 1.409575e-02 0.000000e+00 0.000000e+00 0.000000e+00\n [21] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [26] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [31] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [36] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 1.171963e-02\n [41] 2.318169e-03 4.163849e-03 1.014038e-02 4.829518e-05 0.000000e+00\n [46] 1.146206e-02 1.619659e-02 0.000000e+00 0.000000e+00 0.000000e+00\n [51] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [56] 1.313629e-03 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [61] 0.000000e+00 2.488007e-03 0.000000e+00 0.000000e+00 0.000000e+00\n [66] 0.000000e+00 9.256576e-04 8.065295e-04 6.761325e-03 6.816865e-03\n [71] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [76] 0.000000e+00 4.829518e-05 0.000000e+00 0.000000e+00 0.000000e+00\n [81] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [86] 9.659036e-05 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [91] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 8.693132e-03\n [96] 1.947906e-04 0.000000e+00 0.000000e+00 0.000000e+00 1.448855e-04\n[101] 0.000000e+00 2.318169e-03 0.000000e+00 2.318169e-03 0.000000e+00\n[106] 0.000000e+00 0.000000e+00 1.314595e-02 0.000000e+00 0.000000e+00\n[111] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[116] 0.000000e+00 0.000000e+00 0.000000e+00 9.659036e-05 0.000000e+00\n[121] 0.000000e+00 1.732509e-02 0.000000e+00 0.000000e+00 1.263724e-03\n[126] 0.000000e+00 1.923758e-04 0.000000e+00 1.893171e-03 0.000000e+00\n[131] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[136] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[141] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[146] 0.000000e+00 0.000000e+00 9.256576e-04 0.000000e+00 0.000000e+00\n[151] 5.312470e-04 0.000000e+00 0.000000e+00 0.000000e+00 3.292443e-02\n[156] 0.000000e+00 0.000000e+00 1.458514e-02 0.000000e+00 0.000000e+00\n[161] 0.000000e+00 4.588042e-03 1.661193e-02 0.000000e+00 0.000000e+00\n[166] 8.918510e-03 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[171] 0.000000e+00 0.000000e+00 0.000000e+00 9.659036e-05 0.000000e+00\n[176] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[181] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[186] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[191] 0.000000e+00 0.000000e+00 4.829518e-05 0.000000e+00 0.000000e+00\n[196] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[201] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n\n\nLet’s create a plot that has the nodes sized by their betweenness centrality score.\n\ngplot( \n  ga_mat_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ba491c\",\n  vertex.cex = betweenness( ga_mat_u, gmode=\"graph\" ),\n  main = \"Get Along With Network (Undirected)\",\n  sub = \"node sized by betweenness centrality\"\n  )\n\n\n\n\nWait? Something isn’t right…All I see is a blob of color. This is because the size of the nodes in the plot are HUGE! We can see this by using the max() function. The max() function finds the maximum value of a vector:\n\nmax( betweenness( ga_mat_u, gmode=\"graph\" ) )\n\n[1] 681.7333\n\n\nThe largest betweenness centrality score is 681.7333333, so the plot is using this value. What we need is to adjust the centrality scores so that they are not so large. Fortunately, there is a simple function we can write to do this.\nLet’s use the rescale() function to adjust the node sizes in our plot:\n\nrescale &lt;- function( nchar, low, high ){\n  min_d &lt;- min( nchar )\n  max_d &lt;- max( nchar )\n  rscl  &lt;- ( ( high - low )*( nchar - min_d ) ) / ( max_d - min_d ) + low\n  rscl\n}\n\nNow, use the function we created to rescale the size of the nodes:\n\ngplot( \n  ga_mat_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ba491c\",\n  vertex.cex = rescale( betweenness( ga_mat_u, gmode=\"graph\" ), 0.5, 2.5 ),\n  main = \"Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by betweenness centrality\"\n  )\n\n\n\n\nMuch better. Yet, it is still a bit difficult to see the differences due to the number of isolates (i.e. nodes without any edges). Let’s remove them using the displayisolates = argument. We will set it to FALSE to not display nodes that are isolates.\n\ngplot( \n  ga_mat_u, \n  gmode = \"graph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#ba491c\",\n  vertex.cex = rescale( betweenness( ga_mat_u, gmode=\"graph\" ), 0.5, 2.5 ),\n  main = \"Get\\n Along With Network (Undirected)\",\n  sub = \"node sized by betweenness centrality\",\n  displayisolates = FALSE # here we set it to FALSE, TRUE is the default\n  )\n\n\n\n\nNow we can examine the centralization score for the network:\n\ncentralization( ga_mat_u, betweenness, mode=\"graph\" ) \n\n[1] 0.03197054\n\n\nWhat does the centralization score of 0.03 tell us?\n\n\nPower and Influence Network (Directed Network)\nFor the power and influence network, individuals could have asymmetric nominations. That is, i could nominate j and j didn’t necessarily nominate i. We will keep this asymmetry so that we can treat the network as directed.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-PINS-power-w1-adj.csv\"\n\n# read in the .csv file\npi_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\nWe have created a directed network where ties represent “power and influence” nominations from i to j. Now, let’s calculate our betweenness scores.\n\n# define the number of nodes in the graph for our calculation\ng &lt;- dim( pi_mat )[1]\n\n# unstandardized\nbetweenness( pi_mat, gmode=\"digraph\" )\n\n  [1]  9.0  0.0  0.0 59.5  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [16]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  7.0  0.0  0.0  0.0  0.0  0.0\n [31]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  7.0  0.0  0.0  0.0  0.0  0.0\n [46] 49.5  5.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [61]  0.0  0.0  0.0  0.0  0.0  0.0 28.5  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [76]  0.0  0.0  0.0  0.0  0.0  3.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n [91]  0.0  0.0  0.0  0.0  0.0  0.0  0.0 19.0  0.0  0.0  0.0  2.0  0.0  0.0  0.0\n[106]  0.0  0.0  4.0  0.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 12.0  0.0\n[121]  2.0  7.0  0.0  0.0  0.0  0.0  0.0  0.0  5.5  1.5  0.0  0.0  0.0  1.0  0.0\n[136]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 10.0  0.0  0.0\n[151]  0.0  0.0  5.0  0.0  0.0  4.0  0.0  0.0  0.0  0.0  0.0  7.5  0.0  0.0  0.0\n[166] 51.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  4.0  0.0  0.0  0.0\n[181]  0.0  0.0  0.0  0.0  0.0  0.0 77.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n[196]  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n# standardized\nbetweenness( pi_mat, gmode=\"digraph\" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )\n\n  [1] 4.346566e-04 0.000000e+00 0.000000e+00 2.873563e-03 0.000000e+00\n  [6] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [11] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [16] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [21] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 3.380663e-04\n [26] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [31] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [36] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 3.380663e-04\n [41] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [46] 2.390611e-03 2.414759e-04 0.000000e+00 0.000000e+00 0.000000e+00\n [51] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [56] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [61] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [66] 0.000000e+00 1.376413e-03 0.000000e+00 0.000000e+00 0.000000e+00\n [71] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [76] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [81] 1.448855e-04 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [86] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [91] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n [96] 0.000000e+00 0.000000e+00 9.176084e-04 0.000000e+00 0.000000e+00\n[101] 0.000000e+00 9.659036e-05 0.000000e+00 0.000000e+00 0.000000e+00\n[106] 0.000000e+00 0.000000e+00 1.931807e-04 0.000000e+00 2.897711e-04\n[111] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[116] 0.000000e+00 0.000000e+00 0.000000e+00 5.795422e-04 0.000000e+00\n[121] 9.659036e-05 3.380663e-04 0.000000e+00 0.000000e+00 0.000000e+00\n[126] 0.000000e+00 0.000000e+00 0.000000e+00 2.656235e-04 7.244277e-05\n[131] 0.000000e+00 0.000000e+00 0.000000e+00 4.829518e-05 0.000000e+00\n[136] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[141] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[146] 0.000000e+00 0.000000e+00 4.829518e-04 0.000000e+00 0.000000e+00\n[151] 0.000000e+00 0.000000e+00 2.414759e-04 0.000000e+00 0.000000e+00\n[156] 1.931807e-04 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[161] 0.000000e+00 3.622139e-04 0.000000e+00 0.000000e+00 0.000000e+00\n[166] 2.463054e-03 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[171] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[176] 0.000000e+00 1.931807e-04 0.000000e+00 0.000000e+00 0.000000e+00\n[181] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[186] 0.000000e+00 3.718729e-03 0.000000e+00 0.000000e+00 0.000000e+00\n[191] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[196] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n[201] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00\n\n\nNow, we can plot it to examine the scores:\n\ngplot( \n  pi_mat, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#0b7344\",\n  vertex.cex = rescale( betweenness( pi_mat, gmode=\"digraph\" ), 0.5, 2.5 ),\n  arrowhead.cex = 0.5,\n  main = \"Power/Influence Network (Directed)\",\n  sub = \"node sized by betweenness centrality\"\n  )\n\n\n\n\nAgain, let’s remove the isolates:\n\ngplot( \n  pi_mat, \n  gmode = \"digraph\",\n  edge.col=\"grey40\", \n  vertex.col=\"#0b7344\",\n  vertex.cex = rescale( betweenness( pi_mat, gmode=\"digraph\" ), 0.5, 2.5 ),\n  arrowhead.cex = 0.5,\n  main = \"Power/Influence Network (Directed)\",\n  sub = \"node sized by betweenness centrality\",\n  displayisolates = FALSE\n  )\n\n\n\n\nExamine the centralization score for the network:\n\ncentralization( pi_mat, betweenness, mode=\"digraph\" ) \n\n[1] 0.00182267\n\n\nA few questions:\n\nWhat do we see in the plot?\nWhat does the closeness centralization score of 0.0018 indicate?"
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#test-your-knowledge-excercises",
    "href": "snaca-r-betweenness-centrality.html#test-your-knowledge-excercises",
    "title": "Betweenness Centrality and Centralization",
    "section": "Test Your Knowledge Excercises",
    "text": "Test Your Knowledge Excercises\n\nDefine betweenness centrality and explain its importance in network analysis.\nModify the matrix u_mat to include a new node and recalculate the betweenness centrality scores. How do the scores change?\nFor the directed graph d_mat, calculate the betweenness centrality and plot the graph. How does the directionality affect the results?\nCompare the centralization scores of u_mat (undirected) and d_mat (directed). What does the difference indicate about the distribution of betweenness scores?\nVisualize the “Power and Influence Network” as a directed graph with node sizes proportional to their betweenness centrality scores. Describe key observations from the plot.\nDiscuss the implications of removing isolates from a network visualization using the “Get Along With Network” as an example.\nExplain the meaning of the betweenness centralization score for the “Power and Influence Network” and how it compares to the betweenness centralization score for the “Get Along With Network”.\nInterpret the maximum betweenness centrality score for the “Get Along With Network” and discuss its implications for network structure. Do the same for the “Power and Influence Network”."
  },
  {
    "objectID": "snaca-r-betweenness-centrality.html#tutorial-summary",
    "href": "snaca-r-betweenness-centrality.html#tutorial-summary",
    "title": "Betweenness Centrality and Centralization",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced the concept of betweenness centrality and centralization and how it can be calculated using the betweenness() function in the sna package in R., key measures in social network analysis used to identify important nodes in a network based on their intermediary roles. We reviewed this calculation for both undirected and directed networks, illustrating how directionality influences betweenness scores and centralization metrics.These exercises demonstrated how betweenness centrality and centralization provide valuable insights into social dynamics and power structures within criminal justice contexts."
  },
  {
    "objectID": "snaca-r-bipartite.html#bipartite-graphstwo-mode-networks",
    "href": "snaca-r-bipartite.html#bipartite-graphstwo-mode-networks",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Bipartite Graphs/Two-Mode Networks",
    "text": "Bipartite Graphs/Two-Mode Networks\nTo begin, let’s build the example bipartite graph from the Bipartite Graphs & Two-Mode Networks chapter:\n\n# create the example network\nbipartite_example &lt;- rbind(\n  c( 1,1,0,0,0 ),\n  c( 1,0,0,0,0 ),\n  c( 1,1,0,0,0 ),\n  c( 0,1,1,1,1 ),\n  c( 0,0,1,0,0 ), \n  c( 0,0,1,0,1 ) )\n\n# assign names to the rows\nrownames( bipartite_example ) &lt;- c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\" )\n\n# assign names to the columns\ncolnames( bipartite_example ) &lt;- c( \"1\",\"2\",\"3\",\"4\",\"5\" )\n\n# print out the object\nbipartite_example\n\n  1 2 3 4 5\nA 1 1 0 0 0\nB 1 0 0 0 0\nC 1 1 0 0 0\nD 0 1 1 1 1\nE 0 0 1 0 0\nF 0 0 1 0 1\n\n\nAs we can see, the matrix has 6 rows and 5 columns. So, the order of the matrix is 6 x 5.\n\nUsing the network Package\nWe can create an object of class network by using the as.network() function in the network package. First, take a look at the help for the as.network() function, paying particular attention to the bipartite= argument.\n\n# call the network package\nlibrary( network )\n\n# pull up the help for the as.network() function\n?as.network\n\nIn looking through the help file for the as.network() function, we see that the bipartite= argument says that this argument allows the count of the number of actors in the bipartite network. A bipartite adjacency matrix has order NxM, where N represents the number of rows (e.g. actors) and M represents the number of columns (e.g. events). In the bipartite= argument, we can specify the count of actors as N.\nFor example:\n\n# identify the number of actors in the example\nN &lt;- dim( bipartite_example )[1]\n\n# create a network object\nbipartite_example_net &lt;- as.network(\n  bipartite_example, # here is our matrix\n  bipartite = N      # define the number of actors\n  )\n\n# there 11 vertices, 6 are bipartite (in the first mode), and 12 edges\nbipartite_example_net\n\n Network attributes:\n  vertices = 11 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = 6 \n  total edges= 12 \n    missing edges= 0 \n    non-missing edges= 12 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\n\n\nUsing gplot() in the sna Package\nNow that our object is created, we can take a look at a plot of the network using the gplot() function. Before we do so, let’s take a look at a few changes we need to make. First, note that the gplot() function reads the labels by starting with the names in the first mode, then the names in the second mode. We can see this by printing the vertex labels the function assigns with the network.vertex.names() function.\n\n# look how it reads the labels\nnetwork.vertex.names( bipartite_example_net ) \n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\nWe can see that it first labels the actor nodes (i.e. A, B, C, D, E, and F) and then names the event nodes (i.e. 1, 2, 3, 4, 5).\nSecond, we need to tell the gplot() function that the network has two modes, not one mode. We do this using the gmode= argument, which automatically changes the colors and the shapes of the nodes when we specify that the graph is twomode. Third, we need to set the usearrows= argument to FALSE so that the arrowheads are turned off. (Note that there are directed two-mode networks in which you would use arrowheads, but we will skip that for now). Let’s check it out:\n\n# load the sna library to get the gplot() function\nlibrary( sna )\n\n# set the seed to reproduce the plot layout\nset.seed( 507 )\n\n# execute the plot\ngplot(\n  bipartite_example_net,                                  # our network to plot\n  label = network.vertex.names( bipartite_example_net ),  # the labels we want\n  gmode = \"twomode\",                                      # indicate it is two modes\n  usearrows = FALSE,                                      # turn off the arrowheads\n  vertex.cex=2,                                           # size the nodes     \n  label.cex=1.2,                                          # size the labels\n  main=\"Bipartite Graph of Example Graph\"                 # add a title\n)\n\n\n\n\nAs we saw in the Basics of Network Visualization tutorial, there are a lot of options that help us convey important information about a network. When we are working with a two mode network object, we need to make sure that whatever information we pass to the nodes matches the order of the nodes in the network. For example, we saw above that the network first labels the actor nodes and then labels the event nodes. If we wanted to choose a different set of colors, for example, using the vertex.col= argument, then we would want a set of colors for the actors and a set of colors for the events. Then, we would want these combined into a single object. Let’s do that here to demonstrate:\n\n# identify the number of actors in the example\nN &lt;- dim( bipartite_example )[1]\n\n# identify the number of events in the example\nM &lt;- dim( bipartite_example )[2]\n\n# set the actor colors\nactor.col &lt;- rep( \"#1fdeb1\", N )\n\n# set the event colors\nevent.col &lt;- rep( \"#bab4de\", M )\n\n# now combine them into a single vector of colors\nnode_col &lt;- c( actor.col, event.col )\n\n# take a look\nnode_col\n\n [1] \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#1fdeb1\" \"#bab4de\"\n [8] \"#bab4de\" \"#bab4de\" \"#bab4de\" \"#bab4de\"\n\n\nNow that we have a set of colors that match the order of the nodes, we can pass it into the gplot() function using the vertex.col= argument:\n\n# set the seed to reproduce the plot layout\nset.seed( 507 )\n\n# execute the plot\ngplot(\n  bipartite_example_net,                                  # our network to plot\n  label = network.vertex.names( bipartite_example_net ),  # the labels we want\n  gmode = \"twomode\",                                      # indicate it is two modes\n  usearrows = FALSE,                                      # turn off the arrowheads\n  vertex.cex = 3,                                         # size the nodes     \n  label.cex = 1.2,                                        # size the labels\n  label.pos = 5,                                          # position the labels on the nodes\n  main=\"Bipartite Graph of Example Graph\",                # add a title\n  \n  # here is the addition to what we had above:\n  vertex.col = node_col                                   # add the colors\n)\n\n\n\n\nThis setup, where we define the actor properties and event properties and combine them into a vector will be used for any attribute we want to attach to the nodes. We will work through more examples below illustrating this point."
  },
  {
    "objectID": "snaca-r-bipartite.html#structural-properties-of-bipartite-graphstwo-mode-networks",
    "href": "snaca-r-bipartite.html#structural-properties-of-bipartite-graphstwo-mode-networks",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Structural Properties of Bipartite Graphs/Two-Mode Networks",
    "text": "Structural Properties of Bipartite Graphs/Two-Mode Networks\nAs reviewed in the Bipartite Graphs & Two-Mode Networks chapter of the textbook, there are multiple structural properties of bipartite graphs that we can examine to help us describe the network.\n\nDensity\nThe density of a bipartite graph is the number of observed edges in the graph, L, divided by the number of nodes in the first mode, N, multiplied by the number of nodes in the second mode, M. That is:\n\\[\\frac{L}{N \\times M}\\]\nIn other words, the density of the graph is the number of edges we observed divided by the maximum number of possible edges in the graph. We can calculate this using the sum() and dim() functions.\n\n# identify the number of edges in the graph\nL &lt;- sum( bipartite_example )\n\n# identify the number of actors in the example\nN &lt;- dim( bipartite_example )[1]\n\n# identify the number of events in the example\nM &lt;- dim( bipartite_example )[2]\n\n# calculate the density\ndensity_bipartite_example &lt;- L / ( N * M )\n\n# check it out\ndensity_bipartite_example\n\n[1] 0.4\n\n\nWhat is the interpretation of the density?\n\n\nDegree Centrality\nFor a bipartite graph there are two degree distributions:\n\nThe distribution of ties in the first mode\nThe distribution of ties in the second mode\n\nWe can calculate the degree centrality scores for each node in each corresponding vertex set by taking the row sum for N nodes in the first mode and taking the column sum for M nodes in the second mode. We can do so using the rowSums() and colSums() functions, recspectively.\n\n# raw scores for actors\nactor_deg &lt;- rowSums( bipartite_example )\nactor_deg\n\nA B C D E F \n2 1 2 4 1 2 \n\n# raw scores for events\nevent_deg &lt;- colSums( bipartite_example )\nevent_deg\n\n1 2 3 4 5 \n3 3 3 1 2 \n\n\nHow should we interpret the centrality scores for each node set? Well, it is a bit difficult when just looking at it here. So, we can calculate a summary statistic, such as the mean, to evaluate the distribution of centrality scores for each node set.\n\nMean Degree Centrality\nAs before, we could examine the central tendency by examining the mean degree for each node/vertex set. We take the sum of the edges, \\(L\\) and:\n\nfor the first node set we divide by \\(\\frac{L}{N}\\), the number of nodes in that set.\nfor the second node set we divide by \\(\\frac{L}{M}\\), the number of nodes in that set.\n\n\n# mean degree for actors\nmean_actor_deg &lt;- L / N\n\n# mean degree for events\nmean_event_deg &lt;- L / M\n\n# an alternative is to just use the mean() function with the degree data\nmean( actor_deg )\n\n[1] 2\n\nmean( event_deg )\n\n[1] 2.4\n\n\nHow should we interpret the mean centrality score for each node set? The mean for the actor node set indicates that, on average, each node has 2 ties. The mean for the event node set indicates that, on average, each event has 2.4 ties.\n\n\nStandardized Degree Centrality\nDegree centrality scores for each node/vertex set not only reflects each node’s connectivity to nodes in the other set, but also depend on the size of that set. As a result, larger networks will have a higher maximum possible degree centrality value. Solution?\nStandardize!!!\nAs we saw for unipartite graphs, we can adjust the raw degree centrality scores by taking into account the size of the graph. In a bipartite graph, we can standardize, or normalize, by dividing the raw centrality scores by the number of nodes in the opposite vertex set. That is, for the centrality scores in the first mode we divide by M and for the centrality scores in the second mode we divide by N.\n\n# standardized score for actors\nactor_deg / M\n\n  A   B   C   D   E   F \n0.4 0.2 0.4 0.8 0.2 0.4 \n\n# standardized score for events\nevent_deg / N\n\n        1         2         3         4         5 \n0.5000000 0.5000000 0.5000000 0.1666667 0.3333333 \n\n\nIn networks with lots of nodes, this information might be useful for visualizing differences in nodes degree centrality. Let’s create a plot with the standardized scores where larger degree centrality influences the size of the nodes. As we did above, we will want to create a single object that has these sizes. We can do this using the c() function.\n\n# define the standardized scores for actors\nactor_size &lt;- actor_deg / M\n\n# define the standardized scores for events\nevent_size &lt;- event_deg / N\n\n# combine these to use in the plot\nv_size &lt;- c( actor_size, event_size )\n\n# set the seed to reproduce the plot layout\nset.seed( 507 )\n\n# execute the plot\ngplot(\n  bipartite_example_net,                                  # our network to plot\n  label = network.vertex.names( bipartite_example_net ),  # the labels we want\n  gmode = \"twomode\",                                      # indicate it is two modes\n  usearrows = FALSE,                                      # turn off the arrowheads\n  label.cex = 1.2,                                        # size the labels\n  main = \"Bipartite Graph of Example Graph\",              # add a title\n  vertex.col = node_col,                                  # add the colors\n  \n  # here is the addition to what we had above:\n  vertex.cex = v_size + 0.5                               # set the size (add 0.5 so it is not too small) \n)"
  },
  {
    "objectID": "snaca-r-bipartite.html#structural-properties-of-young-ready-2015-police-officer-network",
    "href": "snaca-r-bipartite.html#structural-properties-of-young-ready-2015-police-officer-network",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Structural Properties of Young & Ready (2015) Police Officer Network",
    "text": "Structural Properties of Young & Ready (2015) Police Officer Network\nNow, let’s work with a real example. As discussed in the Bipartite Graphs & Two-Mode Networks chapter, Young and Ready (2015) examined how police officers develop cognitive frames about the usefulness of body-worn cameras. They argued that police officers views of body-worn cameras influence whether they use their cameras in incidents and that these views partly result from sharing incidents with other officers where they exchanged views about the legitimacy of body-worn cameras.\nLet’s import the the matrix, create a network, assign an attribute, and plot it. Then, we will work through the structural properties.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-officer-events-adj.csv\"\n\n# read in the .csv file\ncam_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\n# identify the number of police officers\nN &lt;- dim( cam_mat )[1]\n\n# identify the number of incidents\nM &lt;- dim( cam_mat )[2]\n\nNow, we want to coerce this to an object of class network.\n\n# create the network object\nofficer_event_net &lt;- as.network( \n  cam_mat,\n  bipartite = N\n)\n\n# take a look\nofficer_event_net\n\n Network attributes:\n  vertices = 234 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = 81 \n  total edges= 346 \n    missing edges= 0 \n    non-missing edges= 346 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\n\nPlotting the Network\nNow, let’s create a plot of the network. To aid in visualization, we need to create a variable indicating whether the officer was in the treatment (i.e. received a body-cam) or control group. If you look at the network.vertex.names( officer_event_net ) object, you will see that the officer ids start with “C” or “T”. The “C” prefix indicates a control officer and a “T” prefix indicates a treatment officer. The first 44 ids are for control officers and the subsequent 37 ids are for treatment officers. The remaining 153 correspond to events. We can use this info to create a variable that indicates treatment status.\nWe will use this information to create an attribute. To do so, we will use the rep() function which repeats a sequence of numbers of characters.\n\n# create a variable using the information in the ids\nstatus &lt;- c( \n  rep( \"Control\", 44 ),   # repeat \"Control\" 44 times because there are 44 control officers\n  rep( \"Treatment\", 37 ), # repeat \"Treatment\" 37 times because there are 37 control officers\n  rep( \"Incident\", 153 )     # repeat \"Incident\" 153 times because there are 153 incident\n  )\n\n# create colors for the plot\nvcol &lt;- status\nvcol[ status == \"Control\" ]   &lt;- \"green\" # make controls green\nvcol[ status == \"Treatment\" ] &lt;- \"red\"   # make treatment group red\nvcol[ status == \"Incident\" ]  &lt;- \"white\" # make events white\n\n# create the shapes\nvsides &lt;- rep( 0, length( status ) )\nvsides[ status == \"Control\" ]   &lt;- 3  # make controls triangles\nvsides[ status == \"Treatment\" ] &lt;- 4  # make treatment group squares\nvsides[ status == \"Incident\" ]  &lt;- 50 # make events circles\n\n# create the node sizes\nnsize &lt;- c(\n  rep( 2,   N ), # sizes for officers\n  rep( 1.2, M )  # size for the events\n  ) \n\nNow, we can plot this using the gplot() function.\n\n# set the seed for the plot\nset.seed( 507 )\n\n# plot it\ngplot(\n  officer_event_net,\n  gmode=\"twomode\",\n  usearrows=FALSE,\n  displayisolates=FALSE,\n    vertex.col=vcol,\n    vertex.sides=vsides,\n    edge.col=\"grey60\",\n    edge.lwd=1.2,\n    vertex.cex = nsize,\n  main = \"Plot of Officers and Events\"\n)\n\n\n\n\n\n\nStructural Properties of the Network\nNow, let’s take a look at several properties of the graph: density, degree centrality, and mean degree centrality.\n\nDensity\nRemember, the density is the total number of edges divided by N x M.\n\n# identify the number of edges in the graph\nL &lt;- sum( cam_mat )\n\nL / ( N * M )\n\n[1] 0.02791899\n\n\nThe density for the this network is 0.03. What is the interpretation of the density for this network?\n\n\nDegree\nNow, let’s take a look at the degree distributions.\n\n# raw scores for officers\nofficer_deg &lt;- rowSums( cam_mat )\n\n# raw scores for incidents\nincident_deg &lt;- colSums( cam_mat )\n\n\n\nMean Degree Centrality\nNow, we can examine the central tendency by examining the mean degree for each node/vertex set. We take the sum of the edges, \\(L\\) and:\n\nfor the first node set we divide by \\(\\frac{L}{N}\\), the number of nodes in that set.\nfor the second node set we divide by \\(\\frac{L}{M}\\), the number of nodes in that set.\n\n\n# mean degree for officers\nmean_officer_deg &lt;- L / N\nmean_officer_deg\n\n[1] 4.271605\n\n# mean degree for incidents\nmean_incident_deg &lt;- L / M\nmean_incident_deg\n\n[1] 2.261438\n\n# an alternative is to just use the mean() function with the degree data\nmean( mean_officer_deg )\n\n[1] 4.271605\n\nmean( mean_incident_deg )\n\n[1] 2.261438\n\n\nWhat is the interpretation of the mean degree for each node set?"
  },
  {
    "objectID": "snaca-r-bipartite.html#test-your-knowledge-excercises",
    "href": "snaca-r-bipartite.html#test-your-knowledge-excercises",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Test Your Knowledge Excercises",
    "text": "Test Your Knowledge Excercises\n\nExplain the difference between bipartite graphs and unipartite graphs. Provide examples of contexts where each might be used.\nWhat is the purpose of the bipartite argument in the as.network() function? How does it relate to the dimensions of the adjacency matrix?\nDescribe the role of the gmode argument in the gplot() function. What happens when it is set to \"twomode\"?\nHow would you create a set of colors for the nodes in a bipartite graph, ensuring that actor nodes and event nodes have different colors? Write the R code to demonstrate this.\nHow do you compute the degree centrality for actor nodes and event nodes in a bipartite graph? Provide the R code to do this.\nInterpret the mean degree centrality for the officer and incident nodes in the police officer network. What do these values tell you about the structure of the network?\nWhen visualizing a bipartite graph, why is it important to ensure that node attributes (e.g., color, size) are correctly ordered? What steps would you take to ensure this in R?\nCreate a plot of a bipartite graph where node sizes reflect their standardized degree centrality and node colors differentiate between actors and events.\nWhy is it important to examine both the raw and mean degree centrality scores when analyzing bipartite graphs? What insights can each provide?"
  },
  {
    "objectID": "snaca-r-bipartite.html#tutorial-summary",
    "href": "snaca-r-bipartite.html#tutorial-summary",
    "title": "Bipartite Graphs & Two-Mode Networks",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial explored bipartite graphs, or two-mode networks, as a foundational tool for representing relationships between two distinct node sets, such as individuals and events. Crime analysts often work with these graph structures, so we learned in this tutorial how to construct these networks through adjacency matrices, transform them into network objects, and visualize them using the gplot() function from the sna package. We also reviewed several propoerties of these networks, such as calculating network density and degree centrality.\n\n\n\n\nYoung, Jacob T. N., and Justin T. Ready. 2015. “Diffusion of Ideas and Technology: The Role of Networks in Influencing the Endorsement and Use of on-Officer Video Cameras.” Journal of Contemporary Criminal Justice 31 (3): 243–61. https://doi.org/10.1177/1043986214553380."
  },
  {
    "objectID": "snaca-r-projection.html#one-mode-networks-by-projection",
    "href": "snaca-r-projection.html#one-mode-networks-by-projection",
    "title": "Projection & Weighted Graphs",
    "section": "One-Mode Networks by Projection",
    "text": "One-Mode Networks by Projection\nFollowing Breiger (1974), we can build the adjacency matrix for each projected network through matrix algebra. Specifically, multiplying an adjacency matrix by it’s transpose. The transpose of a matrix A simply reverses the columns and rows: \\(\\sf{A^T_{ij}}\\) = \\(\\sf{A_{ji}}\\).\nThe two-mode, NxM, adjacency matrix, when multiplied by it’s transpose, produces either:\n\nAn NxN matrix (ties among N nodes via M)\nAn MxM matrix (ties among M nodes via N)\n\nTo examine how this works, let’s first set up an example:\n\n# create an example matrix\nA &lt;- rbind(\n  c( 1,1,0,0,0 ),\n  c( 1,0,0,0,0 ),\n  c( 1,1,0,0,0 ),\n  c( 0,1,1,1,1 ),\n  c( 0,0,1,0,0 ),\n  c( 0,0,1,0,1 )\n  )\n\n# name the rows and columns \nrownames( A ) &lt;- c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\" )\ncolnames( A ) &lt;- c( \"1\",\"2\",\"3\",\"4\",\"5\" )\n\n# print out the matrix\nA\n\n  1 2 3 4 5\nA 1 1 0 0 0\nB 1 0 0 0 0\nC 1 1 0 0 0\nD 0 1 1 1 1\nE 0 0 1 0 0\nF 0 0 1 0 1\n\n\n\nTransposition\nIn R, the t() function, or transpose() returns the transposition of a matrix. To see the the help on the transpose() function, just use ?t to pull up the help page.\n\n# print the transpose of our example\nt( A )\n\n  A B C D E F\n1 1 1 1 0 0 0\n2 1 0 1 1 0 0\n3 0 0 0 1 1 1\n4 0 0 0 1 0 0\n5 0 0 0 1 0 1\n\n\nWhat is different? Compare the difference between A and t( A ).\n\nMatrix Multiplication in R\nTo create the project, we need to use matrix algebra. To multiply matrices in R, we have to use the following operator: %*%. This is different then * in that %*% tells R to use matrix multiplication. For example, compare the differences:\n\n# create two matrices\na &lt;- matrix( c(1,1,1,1), nrow=2, byrow=TRUE )\nb &lt;- matrix( c(2,2,2,2), nrow=2, byrow=TRUE )\n\n# multiply the first element in a by the first element in b\na * b\n\n     [,1] [,2]\n[1,]    2    2\n[2,]    2    2\n\n# multiply the matrix a by the matrix b\na %*% b\n\n     [,1] [,2]\n[1,]    4    4\n[2,]    4    4\n\n\nWhat is the difference? When we use a * b, it is not using matrix multiplication.\nTo multiply two matrices, the number of columns in the first matrix must match the number of rows in the second matrix. This is called conformability. Only matrices with conformable dimensions can be multiplied. For example, 5x6 X 6x5 works, but not 5x6 X 5x6. When two matrices are multiplied by each other, this renders the product matrix. The product matrix has the number of rows equal to the first matrix and the number of columns equal to the second matrix.\nRecall that from the two-mode, NxM, adjacency matrix, we can produce two different matrices:\n\nAn NxN matrix (ties among N nodes via M)\n\nThis is created by using NxM X t(NxM), or NxM X MxN\n\nAn MxM matrix (ties among M nodes via N)\n\nThis is created by using t(NxM) X NxM, or MxN X NxM\n\n\nLet’s create each of these with our example network.\n\n# create the NxN matrix\nA %*% t( A )\n\n  A B C D E F\nA 2 1 2 1 0 0\nB 1 1 1 0 0 0\nC 2 1 2 1 0 0\nD 1 0 1 4 1 2\nE 0 0 0 1 1 1\nF 0 0 0 2 1 2\n\n# create the MxM matrix\nt( A ) %*% A\n\n  1 2 3 4 5\n1 3 2 0 0 0\n2 2 3 1 1 1\n3 0 1 3 1 2\n4 0 1 1 1 1\n5 0 1 2 1 2"
  },
  {
    "objectID": "snaca-r-projection.html#projections",
    "href": "snaca-r-projection.html#projections",
    "title": "Projection & Weighted Graphs",
    "section": "Projections",
    "text": "Projections\n\nThe Person Matrix\nOk, so we have created the projections, which are the one-mode networks that represent information in the two-mode networks. Recall from the Projection chapter that Breiger (1974) referred to the person matrix (i.e. the NxN matrix) and the group matrix (i.e. the MxM matrix).\n\n# create the \"person\" matrix: recall this is A X t(A)\nP &lt;- A %*% t( A )\n\nP\n\n  A B C D E F\nA 2 1 2 1 0 0\nB 1 1 1 0 0 0\nC 2 1 2 1 0 0\nD 1 0 1 4 1 2\nE 0 0 0 1 1 1\nF 0 0 0 2 1 2\n\n\nWhat does the diagonal represent in this matrix? What do the off-diagonal elements represent?\nThe diagonal elements represent the number of nodes in the second mode of the bipartite graph to which a node is connected. Put differently, if we have a two-mode network where one set of nodes are individuals and the other set of nodes are events, then the diagonal of the projection for the “person” matrix represents the number of events that an individual attended.\nThe off-diagonal elements represent the ties between nodes in the same node set of the bipartite graph. That is, ties between individuals.\nTo visualize this by plotting each network, then we can better see what is happening. We will use the gplot() function, so be sure to call the sna package library.\n\n# call the library\nlibrary( sna )\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 1, 2 ),\n  mar = c( 0, 1, 4, 1)\n  )\n\n# set the seed to reproduce the plot\nset.seed( 507 )\n\n# plot the bipartite network\ngplot( A,\n       gmode = \"twomode\",\n       main = NA,\n       usearrows = FALSE,\n       label = c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\", \"1\",\"2\",\"3\",\"4\",\"5\" ),\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = c(                   # create a vector of colors\n         rep( \"#fa6e7a\", dim( A )[1] ),  # the first color is the number of nodes in the first mode\n         rep( \"#00aaff\", dim( A )[2] ) ) # the second color is the number of nodes in the second mode\n       )\ntitle( \"Bipartite Matrix\", line = 1 )\n\n# plot the person matrix\ngplot( P,\n       gmode = \"graph\",\n       label = c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\" ),\n       main = NA,\n       usearrows = FALSE,\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = \"#fa6e7a\",\n       vertex.sides = 99.      # set the shapes to be circles\n       )\ntitle( \"Unipartite Projection of\\n Person Matrix\", line = -1 )\n\n\n\n\nFrom the plots we can see what the projection is doing. It is creating a unipartite graph based on the ties in the bipartite graph. For example, consider nodes A, B, and C. In the bipartite graph, B, is connected to A and C through node 1. We see this in the unipartite graph where A, B, and C are connected. In other words, we have taken the links between A, B, and C in the bipartite graph and reproduced them in a unipartite graph.\n\n\nThe Group Matrix\nNow, let’s take a look at the “group” matrix. The projection for the “group” matrix has a different interpretation. Let’s work through this to see it.\n\n# create the \"group\" matrix: recall this is t(A) X A\nG &lt;- t( A ) %*% A\n\nG\n\n  1 2 3 4 5\n1 3 2 0 0 0\n2 2 3 1 1 1\n3 0 1 3 1 2\n4 0 1 1 1 1\n5 0 1 2 1 2\n\n\nWhat does the diagonal represent in this matrix? What do the off-diagonal elements represent?\nThe diagonal elements represent the number of nodes in the first mode of the bipartite graph to which a node is connected. If we have a two-mode network where one set of nodes are individuals and the other set of nodes are events, then the diagonal of the projection for the “group” matrix represents the number of individuals that attend an event. The off-diagonal elements represent the ties between events. Essentially, how events are connected by people attending them. Let’s plot this to see it.\n\n# call the library\nlibrary( sna )\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 1, 2 ),\n  mar = c( 0, 1, 4, 1)\n  )\n\n# set the seed to reproduce the plot\nset.seed( 507 )\n\n# plot the bipartite network\ngplot( A,\n       gmode = \"twomode\",\n       main = NA,\n       usearrows = FALSE,\n       label = c( \"A\",\"B\",\"C\",\"D\",\"E\",\"F\", \"1\",\"2\",\"3\",\"4\",\"5\" ),\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = c( \n         rep( \"#fa6e7a\", dim( A )[1] ), \n         rep( \"#00aaff\", dim( A )[2] ) )\n       )\ntitle( \"Bipartite Matrix\", line = 1 )\n\n# plot the person matrix\ngplot( G,\n       gmode = \"graph\",\n       label = c( \"1\",\"2\",\"3\",\"4\",\"5\" ),\n       main = NA,\n       usearrows = FALSE,\n       label.pos = 5,\n       vertex.cex = 2,\n       vertex.col = \"#00aaff\",\n       vertex.sides = 4        # set the shape to be a square\n       )\ntitle( \"Unipartite Projection of\\n Group Matrix\", line = -1 )\n\n\n\n\nFrom the plots we can see what the projection is doing. It is creating a unipartite graph based on the ties in the bipartite graph, but this time it is for the other node set. For example, consider nodes 1, 2, and 3. In the bipartite graph, 1, is connected to 2 through node A and C. Node 2 and 3 are connected through node D. We see this in the unipartite graph where 1 is connected to 2 and 2 is connected to 3. In other words, we have taken the links between 1, 2, and 3 in the bipartite graph and reproduced them in a unipartite graph."
  },
  {
    "objectID": "snaca-r-projection.html#projecting-young-readys-2015-police-officer-network",
    "href": "snaca-r-projection.html#projecting-young-readys-2015-police-officer-network",
    "title": "Projection & Weighted Graphs",
    "section": "Projecting Young & Ready’s (2015) Police Officer Network",
    "text": "Projecting Young & Ready’s (2015) Police Officer Network\nNow, let’s work with a real example. As discussed in the Bipartite Graphs & Two-Mode Networks chapter, Young and Ready (2015) examined how police officers develop cognitive frames about the usefulness of body-worn cameras. They argued that police officers views of body-worn cameras influence whether they use their cameras in incidents and that these views partly result from sharing incidents with other officers where they exchanged views about the legitimacy of body-worn cameras.\nLet’s import the the matrix, create a network, assign an attribute, and plot it. Then, we will work create the projection.\n\n# set the location for the file\nloc &lt;- \"https://github.com/jacobtnyoung/snaca-r/raw/main/data/data-officer-events-adj.csv\"\n\n# read in the .csv file\ncam_mat &lt;- as.matrix(\n  read.csv( \n    loc,\n    as.is = TRUE,\n    header = TRUE,\n    row.names = 1 \n    )\n  )\n\nWe can check the dimensions of the matrix using the dim() function. The cam_mat matrix has 81 rows and 153 columns. Recall that this is police officers and incidents, so there are 81 police officers and 153 incidents that connect officers.\n\n# identify the number of police officers\nN &lt;- dim( cam_mat )[1]\n\n# identify the number of incidents\nM &lt;- dim( cam_mat )[2]\n\n\nCreate the Projections\nNow that we have it put together, let’s create the projections. To do this, we just need to employ matrix multiplication on the cam_mat matrix.\n\n# create the \"person\" matrix\ncam_mat_P &lt;- cam_mat %*% t( cam_mat )\n\n# create the \"group\" matrix\ncam_mat_G &lt;- t( cam_mat ) %*% cam_mat\n\nNow, let’s plot the networks!\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 2, 2 ),\n  mar = c( 2, 1, 4, 1)\n  )\n\n# set the seed to reproduce the plot\nset.seed( 507 )\n\n# plot the bipartite network\ngplot( cam_mat,\n       gmode=\"twomode\",\n       usearrows=FALSE,\n       edge.col=\"grey60\",\n       vertex.col = c( \n         rep( \"#34e5eb\", dim( cam_mat )[1] ), \n         rep( \"#4f0a1a\", dim( cam_mat )[2] ) ),\n       edge.lwd=1.2\n       )\ntitle( \"Bipartite Matrix of Officers and Incidents\", line = 1 )\n\n# plot the person matrix\ngplot( cam_mat_P,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col=\"grey60\",\n       edge.lwd=1.2,\n       vertex.col = \"#34e5eb\"\n       )\ntitle( \"Unipartite Projection of\\n Officers (Person) Matrix\", line = 1 )\n\n# plot the group matrix\ngplot( cam_mat_G,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col=\"grey60\",\n       edge.lwd=1.2,\n       vertex.col = \"#4f0a1a\",\n       vertex.sides = 4\n       )\ntitle( \"Unipartite Projection of\\n Incidents (Group) Matrix\", line = 1 )\n\n\n\n\nNow that we have reduced our bipartite graph to a unipartite graph, we can employ the same descriptive tools we have previously used.\n\n\nUsing the Weights in the Plot\nNote that when we create the projection, the matrix is actually a weighted matrix. We saw this in the Projection chapter. We can use this information in our plot. That is, we can use the weighted matrix to shade the edges (darker are larger weights) and size the edges (where larger are bigger weights). To see how this works, let’s build a few functions.\n\nReworking the rescale() function to incorporate edge weights\nFirst, we will create the edge.rescale() function to help us here. This function returns a weighted edgelist that can be used to aid with plotting. Then, we will create the edge.shade() function that shades the edges based on the size of the edge.\n\nedge.rescale &lt;- function( uni_mat, low, high ){\n  diag( uni_mat ) &lt;- 0\n  min_w &lt;- min( uni_mat[uni_mat != 0] )\n  max_w &lt;- max( uni_mat[uni_mat != 0] )\n  rscl &lt;- ( ( high-low )  * ( uni_mat[uni_mat != 0] - min_w ) ) / ( max_w - min_w ) + low\n  rscl\n}\n\nedge.shade &lt;- function( uni_mat ){\n  net_edges &lt;- edge.rescale( uni_mat, 0.01, 1 )\n  vec_to_color &lt;- as.vector( abs( net_edges ) )\n  vec_to_color &lt;- 1 - vec_to_color # subtract 1 to flip the grey function scale.\n  edge_cols &lt;- grey( vec_to_color )\n  return( edge_cols )\n}\n\nNow, let’s plot the networks with the edges adjusted. We will plot the bipartite graph, the officer network, and the officer network with the shading.\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 1, 3 ),\n  mar = c( 2, 1, 5, 1)\n  )\n\n# plot the bipartite network\ngplot( cam_mat,\n       gmode=\"twomode\",\n       usearrows=FALSE,\n       edge.col=\"grey60\",\n       vertex.col = c( \n         rep( \"#34e5eb\", dim( cam_mat )[1] ), \n         rep( \"#4f0a1a\", dim( cam_mat )[2] ) ),\n       edge.lwd=1.2\n       )\ntitle( \"Bipartite Matrix of Officers and Incidents\", line = 1 )\n\n# plot the person matrix\nset.seed( 507 )\ngplot( cam_mat_P,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       vertex.col = \"#34e5eb\"\n       )\ntitle( \"Unipartite Projection of\\n Officers (Person) Matrix\\n (no shading)\", line = 1 )\n\n# plot the person matrix\nset.seed( 507 )\ngplot( cam_mat_P,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col = edge.shade( cam_mat_P ),           # note the usage here\n       edge.lwd = edge.rescale( cam_mat_P, 0.1, 5 ), # note the usage here\n       vertex.col = \"#34e5eb\"\n       )\ntitle( \"Unipartite Projection of\\n Officers (Person) Matrix\", line = 1 )\n\n\n\n\nNow, we will plot the bipartite graph, the incident network, and the incident network with the shading.\n\n# set the plot regions to ease with visualization\npar( \n  mfrow = c( 1, 3 ),\n  mar = c( 2, 1, 4, 1)\n  )\n\n# plot the bipartite network\ngplot( cam_mat,\n       gmode=\"twomode\",\n       usearrows=FALSE,\n       edge.col=\"grey60\",\n       vertex.col = c( \n         rep( \"#34e5eb\", dim( cam_mat )[1] ), \n         rep( \"#4f0a1a\", dim( cam_mat )[2] ) ),\n       edge.lwd=1.2\n       )\ntitle( \"Bipartite Matrix of Officers and Incidents\", line = 1 )\n\n# plot the group matrix\nset.seed( 507 )\ngplot( cam_mat_G,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       vertex.col = \"#4f0a1a\",\n       vertex.sides = 4\n       )\ntitle( \"Unipartite Projection of\\n Incidents (Group) Matrix\\n (no shading)\", line = 1 )\n\n\n# plot the group matrix\nset.seed( 507 )\ngplot( cam_mat_G,\n       gmode = \"graph\",\n       usearrows = FALSE,\n       edge.col = edge.shade( cam_mat_G ),           # note the usage here\n       edge.lwd = edge.rescale( cam_mat_G, 0.1, 5 ), # note the usage here\n       vertex.col = \"#4f0a1a\",\n       vertex.sides = 4\n       )\ntitle( \"Unipartite Projection of\\n Incidents (Group) Matrix\", line = 1 )"
  },
  {
    "objectID": "snaca-r-projection.html#test-your-knowledge-excercises",
    "href": "snaca-r-projection.html#test-your-knowledge-excercises",
    "title": "Projection & Weighted Graphs",
    "section": "Test Your Knowledge Excercises",
    "text": "Test Your Knowledge Excercises\n\nExplain the process of projection in the context of bipartite graphs. Why is it useful for crime analysts?\nUsing R, describe the difference between the t() function and %*% operator. Provide an example illustrating their use.\nWhat are the conditions required for two matrices to be conformable for matrix multiplication? Why is this important when creating projections?\nCreate R code to generate the “person” matrix (NxN) and “group” matrix (MxM) from a given bipartite adjacency matrix. What do the diagonal and off-diagonal elements represent in each projection?\nWhat is the significance of the diagonal elements in the “person” matrix for crime analysts studying shared events?\nWrite R code to visualize the “group” matrix using the gplot() function. How would you ensure that event nodes have distinct shapes and colors?\nWhat are edge weights in a projection, and how can they be represented visually in R?\nDescribe how the edge.rescale() and edge.shade() functions created above work to adjust edge properties in a weighted graph. Why might this be helpful in a crime analysis context?\nWhy might a crime analyst choose to visualize both weighted and unweighted projections of a bipartite network? What insights can be gained from each?\nWhen plotting the unipartite projections, why is it important to use consistent colors and shapes for nodes? How does this enhance the interpretation of the graph?"
  },
  {
    "objectID": "snaca-r-projection.html#tutorial-summary",
    "href": "snaca-r-projection.html#tutorial-summary",
    "title": "Projection & Weighted Graphs",
    "section": "Tutorial Summary",
    "text": "Tutorial Summary\nThis tutorial introduced crime analysts to the concept of projecting bipartite networks into unipartite networks, a critical technique for analyzing relational structures involving two distinct sets of nodes, such as people and events. We showed how analysts can create projections by multiplying an adjacency matrix with its transpose to generate either a “person” matrix, representing relationships between individuals, or a “group” matrix, representing connections between events. Visualization techniques using the gplot() function were demonstrated, showing how unipartite graphs are derived from bipartite structures and how weighted edges can be used to represent the strength of connections. Through these methods, crime analysts gained tools to investigate patterns of collaboration, shared events, and broader social structures, providing valuable perspectives for understanding crime and enforcement dynamics.\n\n\n\n\nBreiger, Ronald L. 1974. “The Duality of Persons and Groups.” Social Forces 53 (2): 181–90. https://doi.org/10.1093/sf/53.2.181.\n\n\nYoung, Jacob T. N., and Justin T. Ready. 2015. “Diffusion of Ideas and Technology: The Role of Networks in Influencing the Endorsement and Use of on-Officer Video Cameras.” Journal of Contemporary Criminal Justice 31 (3): 243–61. https://doi.org/10.1177/1043986214553380."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Breiger, Ronald L. 1974. “The Duality of Persons and\nGroups.” Social Forces 53 (2): 181–90. https://doi.org/10.1093/sf/53.2.181.\n\n\nWasserman, Stanley, and Katherine Faust. 1994. Social Network\nAnalysis: Methods and Applications. Vol. 8. Structural Analysis in\nthe Social Sciences. Cambridge, UK: Cambridge University Press.\n\n\nYoung, Jacob T. N., and Justin T. Ready. 2015. “Diffusion of Ideas\nand Technology: The Role of Networks in Influencing the Endorsement and\nUse of on-Officer Video Cameras.” Journal of Contemporary\nCriminal Justice 31 (3): 243–61. https://doi.org/10.1177/1043986214553380."
  }
]